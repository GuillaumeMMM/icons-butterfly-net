const visitSkip = Symbol(), visit = (e, t, n) => { const r = t[e.type]; if (r?.enter) { if (r.enter(e, n) === visitSkip) return } if ("root" === e.type) for (const n of e.children) visit(n, t, e); if ("element" === e.type && n.children.includes(e)) for (const n of e.children) visit(n, t, e); r?.exit && r.exit(e, n) }, invokePlugins = (e, t, n, r, a) => { for (const o of n) { const n = r?.[o.name]; if (!1 === n) continue; const i = { ...o.params, ...a, ...n }, s = o.fn(e, i, t); null != s && visit(e, s) } }, createPreset = ({ name: e, plugins: t }) => ({ name: e, isPreset: !0, plugins: Object.freeze(t), fn: (n, r, a) => { const { floatPrecision: o, overrides: i } = r, s = {}; if (null != o && (s.floatPrecision = o), i) { const n = t.map((({ name: e }) => e)); for (const t of Object.keys(i)) n.includes(t) || console.warn(`You are trying to configure ${t} which is not part of ${e}.\nTry to put it before or after, for example\n\nplugins: [\n  {\n    name: '${e}',\n  },\n  '${t}'\n]\n`) } invokePlugins(n, a, t, i, s) } }); var ElementType; function isTag$2(e) { return e.type === ElementType.Tag || e.type === ElementType.Script || e.type === ElementType.Style } !function (e) { e.Root = "root", e.Text = "text", e.Directive = "directive", e.Comment = "comment", e.Script = "script", e.Style = "style", e.Tag = "tag", e.CDATA = "cdata", e.Doctype = "doctype" }(ElementType || (ElementType = {})); const Root = ElementType.Root, Text = ElementType.Text, Directive = ElementType.Directive, Comment$4 = ElementType.Comment, Script = ElementType.Script, Style = ElementType.Style, Tag = ElementType.Tag, CDATA = ElementType.CDATA, Doctype = ElementType.Doctype; function isTag$1(e) { return isTag$2(e) } function isCDATA(e) { return e.type === ElementType.CDATA } function isText(e) { return e.type === ElementType.Text } function isComment(e) { return e.type === ElementType.Comment } function isDocument(e) { return e.type === ElementType.Root } function hasChildren(e) { return Object.prototype.hasOwnProperty.call(e, "children") } const xmlReplacer = /["&'<>$\x80-\uFFFF]/g, xmlCodeMap = new Map([[34, "&quot;"], [38, "&amp;"], [39, "&apos;"], [60, "&lt;"], [62, "&gt;"]]), getCodePoint = null != String.prototype.codePointAt ? (e, t) => e.codePointAt(t) : (e, t) => 55296 == (64512 & e.charCodeAt(t)) ? 1024 * (e.charCodeAt(t) - 55296) + e.charCodeAt(t + 1) - 56320 + 65536 : e.charCodeAt(t); function encodeXML(e) { let t, n = "", r = 0; for (; null !== (t = xmlReplacer.exec(e));) { const a = t.index, o = e.charCodeAt(a), i = xmlCodeMap.get(o); void 0 !== i ? (n += e.substring(r, a) + i, r = a + 1) : (n += `${e.substring(r, a)}&#x${getCodePoint(e, a).toString(16)};`, r = xmlReplacer.lastIndex += Number(55296 == (64512 & o))) } return n + e.substr(r) } function getEscaper(e, t) { return function (n) { let r, a = 0, o = ""; for (; r = e.exec(n);)a !== r.index && (o += n.substring(a, r.index)), o += t.get(r[0].charCodeAt(0)), a = r.index + 1; return o + n.substring(a) } } const escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([[34, "&quot;"], [38, "&amp;"], [160, "&nbsp;"]])), escapeText = getEscaper(/[&<>\u00A0]/g, new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [160, "&nbsp;"]])), elementNames = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map((e => [e.toLowerCase(), e]))), attributeNames = new Map(["definitionURL", "attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map((e => [e.toLowerCase(), e]))), unencodedElements = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]); function replaceQuotes(e) { return e.replace(/"/g, "&quot;") } function formatAttributes(e, t) { var n; if (!e) return; const r = !1 === (null !== (n = t.encodeEntities) && void 0 !== n ? n : t.decodeEntities) ? replaceQuotes : t.xmlMode || "utf8" !== t.encodeEntities ? encodeXML : escapeAttribute; return Object.keys(e).map((n => { var a, o; const i = null !== (a = e[n]) && void 0 !== a ? a : ""; return "foreign" === t.xmlMode && (n = null !== (o = attributeNames.get(n)) && void 0 !== o ? o : n), t.emptyAttrs || t.xmlMode || "" !== i ? `${n}="${r(i)}"` : n })).join(" ") } const singleTag = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]); function render(e, t = {}) { const n = "length" in e ? e : [e]; let r = ""; for (let e = 0; e < n.length; e++)r += renderNode(n[e], t); return r } function renderNode(e, t) { switch (e.type) { case Root: return render(e.children, t); case Doctype: case Directive: return renderDirective(e); case Comment$4: return renderComment(e); case CDATA: return renderCdata(e); case Script: case Style: case Tag: return renderTag(e, t); case Text: return renderText(e, t) } } const foreignModeIntegrationPoints = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]), foreignElements = new Set(["svg", "math"]); function renderTag(e, t) { var n; "foreign" === t.xmlMode && (e.name = null !== (n = elementNames.get(e.name)) && void 0 !== n ? n : e.name, e.parent && foreignModeIntegrationPoints.has(e.parent.name) && (t = { ...t, xmlMode: !1 })), !t.xmlMode && foreignElements.has(e.name) && (t = { ...t, xmlMode: "foreign" }); let r = `<${e.name}`; const a = formatAttributes(e.attribs, t); return a && (r += ` ${a}`), 0 === e.children.length && (t.xmlMode ? !1 !== t.selfClosingTags : t.selfClosingTags && singleTag.has(e.name)) ? (t.xmlMode || (r += " "), r += "/>") : (r += ">", e.children.length > 0 && (r += render(e.children, t)), !t.xmlMode && singleTag.has(e.name) || (r += `</${e.name}>`)), r } function renderDirective(e) { return `<${e.data}>` } function renderText(e, t) { var n; let r = e.data || ""; return !1 === (null !== (n = t.encodeEntities) && void 0 !== n ? n : t.decodeEntities) || !t.xmlMode && e.parent && unencodedElements.has(e.parent.name) || (r = t.xmlMode || "utf8" !== t.encodeEntities ? encodeXML(r) : escapeText(r)), r } function renderCdata(e) { return `<![CDATA[${e.children[0].data}]]>` } function renderComment(e) { return `\x3c!--${e.data}--\x3e` } function getOuterHTML(e, t) { return render(e, t) } function getInnerHTML(e, t) { return hasChildren(e) ? e.children.map((e => getOuterHTML(e, t))).join("") : "" } function getText$1(e) { return Array.isArray(e) ? e.map(getText$1).join("") : isTag$1(e) ? "br" === e.name ? "\n" : getText$1(e.children) : isCDATA(e) ? getText$1(e.children) : isText(e) ? e.data : "" } function textContent(e) { return Array.isArray(e) ? e.map(textContent).join("") : hasChildren(e) && !isComment(e) ? textContent(e.children) : isText(e) ? e.data : "" } function innerText(e) { return Array.isArray(e) ? e.map(innerText).join("") : hasChildren(e) && (e.type === ElementType.Tag || isCDATA(e)) ? innerText(e.children) : isText(e) ? e.data : "" } function getChildren$1(e) { return hasChildren(e) ? e.children : [] } function getParent(e) { return e.parent || null } function getSiblings(e) { const t = getParent(e); if (null != t) return getChildren$1(t); const n = [e]; let { prev: r, next: a } = e; for (; null != r;)n.unshift(r), ({ prev: r } = r); for (; null != a;)n.push(a), ({ next: a } = a); return n } function getAttributeValue$1(e, t) { var n; return null === (n = e.attribs) || void 0 === n ? void 0 : n[t] } function hasAttrib$1(e, t) { return null != e.attribs && Object.prototype.hasOwnProperty.call(e.attribs, t) && null != e.attribs[t] } function getName$1(e) { return e.name } function nextElementSibling(e) { let { next: t } = e; for (; null !== t && !isTag$1(t);)({ next: t } = t); return t } function prevElementSibling(e) { let { prev: t } = e; for (; null !== t && !isTag$1(t);)({ prev: t } = t); return t } function removeElement(e) { if (e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e.parent) { const t = e.parent.children, n = t.lastIndexOf(e); n >= 0 && t.splice(n, 1) } e.next = null, e.prev = null, e.parent = null } function replaceElement(e, t) { const n = t.prev = e.prev; n && (n.next = t); const r = t.next = e.next; r && (r.prev = t); const a = t.parent = e.parent; if (a) { const n = a.children; n[n.lastIndexOf(e)] = t, e.parent = null } } function appendChild(e, t) { if (removeElement(t), t.next = null, t.parent = e, e.children.push(t) > 1) { const n = e.children[e.children.length - 2]; n.next = t, t.prev = n } else t.prev = null } function append$1(e, t) { removeElement(t); const { parent: n } = e, r = e.next; if (t.next = r, t.prev = e, e.next = t, t.parent = n, r) { if (r.prev = t, n) { const e = n.children; e.splice(e.lastIndexOf(r), 0, t) } } else n && n.children.push(t) } function prependChild(e, t) { if (removeElement(t), t.parent = e, t.prev = null, 1 !== e.children.unshift(t)) { const n = e.children[1]; n.prev = t, t.next = n } else t.next = null } function prepend(e, t) { removeElement(t); const { parent: n } = e; if (n) { const r = n.children; r.splice(r.indexOf(e), 0, t) } e.prev && (e.prev.next = t), t.parent = n, t.prev = e.prev, t.next = e, e.prev = t } function filter(e, t, n = !0, r = 1 / 0) { return find$3(e, Array.isArray(t) ? t : [t], n, r) } function find$3(e, t, n, r) { const a = [], o = [t], i = [0]; for (; ;) { if (i[0] >= o[0].length) { if (1 === i.length) return a; o.shift(), i.shift(); continue } const t = o[0][i[0]++]; if (e(t) && (a.push(t), --r <= 0)) return a; n && hasChildren(t) && t.children.length > 0 && (i.unshift(0), o.unshift(t.children)) } } function findOneChild(e, t) { return t.find(e) } function findOne$1(e, t, n = !0) { let r = null; for (let a = 0; a < t.length && !r; a++) { const o = t[a]; isTag$1(o) && (e(o) ? r = o : n && o.children.length > 0 && (r = findOne$1(e, o.children, !0))) } return r } function existsOne$1(e, t) { return t.some((t => isTag$1(t) && (e(t) || existsOne$1(e, t.children)))) } function findAll$4(e, t) { const n = [], r = [t], a = [0]; for (; ;) { if (a[0] >= r[0].length) { if (1 === r.length) return n; r.shift(), a.shift(); continue } const t = r[0][a[0]++]; isTag$1(t) && (e(t) && n.push(t), t.children.length > 0 && (a.unshift(0), r.unshift(t.children))) } } const Checks = { tag_name: e => "function" == typeof e ? t => isTag$1(t) && e(t.name) : "*" === e ? isTag$1 : t => isTag$1(t) && t.name === e, tag_type: e => "function" == typeof e ? t => e(t.type) : t => t.type === e, tag_contains: e => "function" == typeof e ? t => isText(t) && e(t.data) : t => isText(t) && t.data === e }; function getAttribCheck(e, t) { return "function" == typeof t ? n => isTag$1(n) && t(n.attribs[e]) : n => isTag$1(n) && n.attribs[e] === t } function combineFuncs(e, t) { return n => e(n) || t(n) } function compileTest(e) { const t = Object.keys(e).map((t => { const n = e[t]; return Object.prototype.hasOwnProperty.call(Checks, t) ? Checks[t](n) : getAttribCheck(t, n) })); return 0 === t.length ? null : t.reduce(combineFuncs) } function testElement(e, t) { const n = compileTest(e); return !n || n(t) } function getElements(e, t, n, r = 1 / 0) { const a = compileTest(e); return a ? filter(a, t, n, r) : [] } function getElementById(e, t, n = !0) { return Array.isArray(t) || (t = [t]), findOne$1(getAttribCheck("id", e), t, n) } function getElementsByTagName(e, t, n = !0, r = 1 / 0) { return filter(Checks.tag_name(e), t, n, r) } function getElementsByTagType(e, t, n = !0, r = 1 / 0) { return filter(Checks.tag_type(e), t, n, r) } function removeSubsets(e) { let t = e.length; for (; --t >= 0;) { const n = e[t]; if (t > 0 && e.lastIndexOf(n, t - 1) >= 0) e.splice(t, 1); else for (let r = n.parent; r; r = r.parent)if (e.includes(r)) { e.splice(t, 1); break } } return e } var DocumentPosition; function compareDocumentPosition(e, t) { const n = [], r = []; if (e === t) return 0; let a = hasChildren(e) ? e : e.parent; for (; a;)n.unshift(a), a = a.parent; for (a = hasChildren(t) ? t : t.parent; a;)r.unshift(a), a = a.parent; const o = Math.min(n.length, r.length); let i = 0; for (; i < o && n[i] === r[i];)i++; if (0 === i) return DocumentPosition.DISCONNECTED; const s = n[i - 1], l = s.children, c = n[i], u = r[i]; return l.indexOf(c) > l.indexOf(u) ? s === t ? DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY : DocumentPosition.FOLLOWING : s === e ? DocumentPosition.PRECEDING | DocumentPosition.CONTAINS : DocumentPosition.PRECEDING } function uniqueSort(e) { return e = e.filter(((e, t, n) => !n.includes(e, t + 1))), e.sort(((e, t) => { const n = compareDocumentPosition(e, t); return n & DocumentPosition.PRECEDING ? -1 : n & DocumentPosition.FOLLOWING ? 1 : 0 })), e } function getFeed(e) { const t = getOneElement(isValidFeed, e); return t ? "feed" === t.name ? getAtomFeed(t) : getRssFeed(t) : null } function getAtomFeed(e) { var t; const n = e.children, r = { type: "atom", items: getElementsByTagName("entry", n).map((e => { var t; const { children: n } = e, r = { media: getMediaElements(n) }; addConditionally(r, "id", "id", n), addConditionally(r, "title", "title", n); const a = null === (t = getOneElement("link", n)) || void 0 === t ? void 0 : t.attribs.href; a && (r.link = a); const o = fetch("summary", n) || fetch("content", n); o && (r.description = o); const i = fetch("updated", n); return i && (r.pubDate = new Date(i)), r })) }; addConditionally(r, "id", "id", n), addConditionally(r, "title", "title", n); const a = null === (t = getOneElement("link", n)) || void 0 === t ? void 0 : t.attribs.href; a && (r.link = a), addConditionally(r, "description", "subtitle", n); const o = fetch("updated", n); return o && (r.updated = new Date(o)), addConditionally(r, "author", "email", n, !0), r } function getRssFeed(e) { var t, n; const r = null !== (n = null === (t = getOneElement("channel", e.children)) || void 0 === t ? void 0 : t.children) && void 0 !== n ? n : [], a = { type: e.name.substr(0, 3), id: "", items: getElementsByTagName("item", e.children).map((e => { const { children: t } = e, n = { media: getMediaElements(t) }; addConditionally(n, "id", "guid", t), addConditionally(n, "title", "title", t), addConditionally(n, "link", "link", t), addConditionally(n, "description", "description", t); const r = fetch("pubDate", t) || fetch("dc:date", t); return r && (n.pubDate = new Date(r)), n })) }; addConditionally(a, "title", "title", r), addConditionally(a, "link", "link", r), addConditionally(a, "description", "description", r); const o = fetch("lastBuildDate", r); return o && (a.updated = new Date(o)), addConditionally(a, "author", "managingEditor", r, !0), a } !function (e) { e[e.DISCONNECTED = 1] = "DISCONNECTED", e[e.PRECEDING = 2] = "PRECEDING", e[e.FOLLOWING = 4] = "FOLLOWING", e[e.CONTAINS = 8] = "CONTAINS", e[e.CONTAINED_BY = 16] = "CONTAINED_BY" }(DocumentPosition || (DocumentPosition = {})); const MEDIA_KEYS_STRING = ["url", "type", "lang"], MEDIA_KEYS_INT = ["fileSize", "bitrate", "framerate", "samplingrate", "channels", "duration", "height", "width"]; function getMediaElements(e) { return getElementsByTagName("media:content", e).map((e => { const { attribs: t } = e, n = { medium: t.medium, isDefault: !!t.isDefault }; for (const e of MEDIA_KEYS_STRING) t[e] && (n[e] = t[e]); for (const e of MEDIA_KEYS_INT) t[e] && (n[e] = parseInt(t[e], 10)); return t.expression && (n.expression = t.expression), n })) } function getOneElement(e, t) { return getElementsByTagName(e, t, !0, 1)[0] } function fetch(e, t, n = !1) { return textContent(getElementsByTagName(e, t, n, 1)).trim() } function addConditionally(e, t, n, r, a = !1) { const o = fetch(n, r, a); o && (e[t] = o) } function isValidFeed(e) { return "rss" === e || "feed" === e || "rdf:RDF" === e } var DomUtils = Object.freeze({ __proto__: null, get DocumentPosition() { return DocumentPosition }, append: append$1, appendChild: appendChild, compareDocumentPosition: compareDocumentPosition, existsOne: existsOne$1, filter: filter, find: find$3, findAll: findAll$4, findOne: findOne$1, findOneChild: findOneChild, getAttributeValue: getAttributeValue$1, getChildren: getChildren$1, getElementById: getElementById, getElements: getElements, getElementsByTagName: getElementsByTagName, getElementsByTagType: getElementsByTagType, getFeed: getFeed, getInnerHTML: getInnerHTML, getName: getName$1, getOuterHTML: getOuterHTML, getParent: getParent, getSiblings: getSiblings, getText: getText$1, hasAttrib: hasAttrib$1, hasChildren: hasChildren, innerText: innerText, isCDATA: isCDATA, isComment: isComment, isDocument: isDocument, isTag: isTag$1, isText: isText, nextElementSibling: nextElementSibling, prepend: prepend, prependChild: prependChild, prevElementSibling: prevElementSibling, removeElement: removeElement, removeSubsets: removeSubsets, replaceElement: replaceElement, testElement: testElement, textContent: textContent, uniqueSort: uniqueSort }); function getDefaultExportFromCjs(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var SelectorType, AttributeAction, boolbase = { trueFunc: function () { return !0 }, falseFunc: function () { return !1 } }, boolbase$1 = getDefaultExportFromCjs(boolbase); !function (e) { e.Attribute = "attribute", e.Pseudo = "pseudo", e.PseudoElement = "pseudo-element", e.Tag = "tag", e.Universal = "universal", e.Adjacent = "adjacent", e.Child = "child", e.Descendant = "descendant", e.Parent = "parent", e.Sibling = "sibling", e.ColumnCombinator = "column-combinator" }(SelectorType || (SelectorType = {})), function (e) { e.Any = "any", e.Element = "element", e.End = "end", e.Equals = "equals", e.Exists = "exists", e.Hyphen = "hyphen", e.Not = "not", e.Start = "start" }(AttributeAction || (AttributeAction = {})); const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, actionTypes = new Map([[126, AttributeAction.Element], [94, AttributeAction.Start], [36, AttributeAction.End], [42, AttributeAction.Any], [33, AttributeAction.Not], [124, AttributeAction.Hyphen]]), unpackPseudos = new Set(["has", "not", "matches", "is", "where", "host", "host-context"]); function isTraversal$1(e) { switch (e.type) { case SelectorType.Adjacent: case SelectorType.Child: case SelectorType.Descendant: case SelectorType.Parent: case SelectorType.Sibling: case SelectorType.ColumnCombinator: return !0; default: return !1 } } const stripQuotesFromPseudos = new Set(["contains", "icontains"]); function funescape(e, t, n) { const r = parseInt(t, 16) - 65536; return r != r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320) } function unescapeCSS(e) { return e.replace(reEscape, funescape) } function isQuote(e) { return 39 === e || 34 === e } function isWhitespace(e) { return 32 === e || 9 === e || 10 === e || 12 === e || 13 === e } function parse$1w(e) { const t = [], n = parseSelector(t, `${e}`, 0); if (n < e.length) throw new Error(`Unmatched selector: ${e.slice(n)}`); return t } function parseSelector(e, t, n) { let r = []; function a(e) { const r = t.slice(n + e).match(reName); if (!r) throw new Error(`Expected name, found ${t.slice(n)}`); const [a] = r; return n += e + a.length, unescapeCSS(a) } function o(e) { for (n += e; n < t.length && isWhitespace(t.charCodeAt(n));)n++ } function i() { const e = n += 1; let r = 1; for (; r > 0 && n < t.length; n++)40 !== t.charCodeAt(n) || s(n) ? 41 !== t.charCodeAt(n) || s(n) || r-- : r++; if (r) throw new Error("Parenthesis not matched"); return unescapeCSS(t.slice(e, n - 1)) } function s(e) { let n = 0; for (; 92 === t.charCodeAt(--e);)n++; return 1 == (1 & n) } function l() { if (r.length > 0 && isTraversal$1(r[r.length - 1])) throw new Error("Did not expect successive traversals.") } function c(e) { r.length > 0 && r[r.length - 1].type === SelectorType.Descendant ? r[r.length - 1].type = e : (l(), r.push({ type: e })) } function u(e, t) { r.push({ type: SelectorType.Attribute, name: e, action: t, value: a(1), namespace: null, ignoreCase: "quirks" }) } function d() { if (r.length && r[r.length - 1].type === SelectorType.Descendant && r.pop(), 0 === r.length) throw new Error("Empty sub-selector"); e.push(r) } if (o(0), t.length === n) return n; e: for (; n < t.length;) { const e = t.charCodeAt(n); switch (e) { case 32: case 9: case 10: case 12: case 13: 0 !== r.length && r[0].type === SelectorType.Descendant || (l(), r.push({ type: SelectorType.Descendant })), o(1); break; case 62: c(SelectorType.Child), o(1); break; case 60: c(SelectorType.Parent), o(1); break; case 126: c(SelectorType.Sibling), o(1); break; case 43: c(SelectorType.Adjacent), o(1); break; case 46: u("class", AttributeAction.Element); break; case 35: u("id", AttributeAction.Equals); break; case 91: { let e; o(1); let i = null; 124 === t.charCodeAt(n) ? e = a(1) : t.startsWith("*|", n) ? (i = "*", e = a(2)) : (e = a(0), 124 === t.charCodeAt(n) && 61 !== t.charCodeAt(n + 1) && (i = e, e = a(1))), o(0); let l = AttributeAction.Exists; const c = actionTypes.get(t.charCodeAt(n)); if (c) { if (l = c, 61 !== t.charCodeAt(n + 1)) throw new Error("Expected `=`"); o(2) } else 61 === t.charCodeAt(n) && (l = AttributeAction.Equals, o(1)); let u = "", d = null; if ("exists" !== l) { if (isQuote(t.charCodeAt(n))) { const e = t.charCodeAt(n); let r = n + 1; for (; r < t.length && (t.charCodeAt(r) !== e || s(r));)r += 1; if (t.charCodeAt(r) !== e) throw new Error("Attribute value didn't end"); u = unescapeCSS(t.slice(n + 1, r)), n = r + 1 } else { const e = n; for (; n < t.length && (!isWhitespace(t.charCodeAt(n)) && 93 !== t.charCodeAt(n) || s(n));)n += 1; u = unescapeCSS(t.slice(e, n)) } o(0); const e = 32 | t.charCodeAt(n); 115 === e ? (d = !1, o(1)) : 105 === e && (d = !0, o(1)) } if (93 !== t.charCodeAt(n)) throw new Error("Attribute selector didn't terminate"); n += 1; const p = { type: SelectorType.Attribute, name: e, action: l, value: u, namespace: i, ignoreCase: d }; r.push(p); break } case 58: { if (58 === t.charCodeAt(n + 1)) { r.push({ type: SelectorType.PseudoElement, name: a(2).toLowerCase(), data: 40 === t.charCodeAt(n) ? i() : null }); continue } const e = a(1).toLowerCase(); let o = null; if (40 === t.charCodeAt(n)) if (unpackPseudos.has(e)) { if (isQuote(t.charCodeAt(n + 1))) throw new Error(`Pseudo-selector ${e} cannot be quoted`); if (o = [], n = parseSelector(o, t, n + 1), 41 !== t.charCodeAt(n)) throw new Error(`Missing closing parenthesis in :${e} (${t})`); n += 1 } else { if (o = i(), stripQuotesFromPseudos.has(e)) { const e = o.charCodeAt(0); e === o.charCodeAt(o.length - 1) && isQuote(e) && (o = o.slice(1, -1)) } o = unescapeCSS(o) } r.push({ type: SelectorType.Pseudo, name: e, data: o }); break } case 44: d(), r = [], o(1); break; default: { if (t.startsWith("/*", n)) { const e = t.indexOf("*/", n + 2); if (e < 0) throw new Error("Comment was not terminated"); n = e + 2, 0 === r.length && o(0); break } let i, s = null; if (42 === e) n += 1, i = "*"; else if (124 === e) { if (i = "", 124 === t.charCodeAt(n + 1)) { c(SelectorType.ColumnCombinator), o(2); break } } else { if (!reName.test(t.slice(n))) break e; i = a(0) } 124 === t.charCodeAt(n) && 124 !== t.charCodeAt(n + 1) && (s = i, 42 === t.charCodeAt(n + 1) ? (i = "*", n += 2) : i = a(1)), r.push("*" === i ? { type: SelectorType.Universal, namespace: s } : { type: SelectorType.Tag, name: i, namespace: s }) } } } return d(), n } const procedure = new Map([[SelectorType.Universal, 50], [SelectorType.Tag, 30], [SelectorType.Attribute, 1], [SelectorType.Pseudo, 0]]); function isTraversal(e) { return !procedure.has(e.type) } const attributes = new Map([[AttributeAction.Exists, 10], [AttributeAction.Equals, 8], [AttributeAction.Not, 7], [AttributeAction.Start, 6], [AttributeAction.End, 6], [AttributeAction.Any, 5]]); function sortByProcedure(e) { const t = e.map(getProcedure); for (let n = 1; n < e.length; n++) { const r = t[n]; if (!(r < 0)) for (let a = n - 1; a >= 0 && r < t[a]; a--) { const n = e[a + 1]; e[a + 1] = e[a], e[a] = n, t[a + 1] = t[a], t[a] = r } } } function getProcedure(e) { var t, n; let r = null !== (t = procedure.get(e.type)) && void 0 !== t ? t : -1; return e.type === SelectorType.Attribute ? (r = null !== (n = attributes.get(e.action)) && void 0 !== n ? n : 4, e.action === AttributeAction.Equals && "id" === e.name && (r = 9), e.ignoreCase && (r >>= 1)) : e.type === SelectorType.Pseudo && (e.data ? "has" === e.name || "contains" === e.name ? r = 0 : Array.isArray(e.data) ? (r = Math.min(...e.data.map((e => Math.min(...e.map(getProcedure))))), r < 0 && (r = 0)) : r = 2 : r = 3), r } const reChars = /[-[\]{}()*+?.,\\^$|#\s]/g; function escapeRegex(e) { return e.replace(reChars, "\\$&") } const caseInsensitiveAttributes = new Set(["accept", "accept-charset", "align", "alink", "axis", "bgcolor", "charset", "checked", "clear", "codetype", "color", "compact", "declare", "defer", "dir", "direction", "disabled", "enctype", "face", "frame", "hreflang", "http-equiv", "lang", "language", "link", "media", "method", "multiple", "nohref", "noresize", "noshade", "nowrap", "readonly", "rel", "rev", "rules", "scope", "scrolling", "selected", "shape", "target", "text", "type", "valign", "valuetype", "vlink"]); function shouldIgnoreCase(e, t) { return "boolean" == typeof e.ignoreCase ? e.ignoreCase : "quirks" === e.ignoreCase ? !!t.quirksMode : !t.xmlMode && caseInsensitiveAttributes.has(e.name) } const attributeRules = { equals(e, t, n) { const { adapter: r } = n, { name: a } = t; let { value: o } = t; return shouldIgnoreCase(t, n) ? (o = o.toLowerCase(), t => { const n = r.getAttributeValue(t, a); return null != n && n.length === o.length && n.toLowerCase() === o && e(t) }) : t => r.getAttributeValue(t, a) === o && e(t) }, hyphen(e, t, n) { const { adapter: r } = n, { name: a } = t; let { value: o } = t; const i = o.length; return shouldIgnoreCase(t, n) ? (o = o.toLowerCase(), function (t) { const n = r.getAttributeValue(t, a); return null != n && (n.length === i || "-" === n.charAt(i)) && n.substr(0, i).toLowerCase() === o && e(t) }) : function (t) { const n = r.getAttributeValue(t, a); return null != n && (n.length === i || "-" === n.charAt(i)) && n.substr(0, i) === o && e(t) } }, element(e, t, n) { const { adapter: r } = n, { name: a, value: o } = t; if (/\s/.test(o)) return boolbase$1.falseFunc; const i = new RegExp(`(?:^|\\s)${escapeRegex(o)}(?:$|\\s)`, shouldIgnoreCase(t, n) ? "i" : ""); return function (t) { const n = r.getAttributeValue(t, a); return null != n && n.length >= o.length && i.test(n) && e(t) } }, exists: (e, { name: t }, { adapter: n }) => r => n.hasAttrib(r, t) && e(r), start(e, t, n) { const { adapter: r } = n, { name: a } = t; let { value: o } = t; const i = o.length; return 0 === i ? boolbase$1.falseFunc : shouldIgnoreCase(t, n) ? (o = o.toLowerCase(), t => { const n = r.getAttributeValue(t, a); return null != n && n.length >= i && n.substr(0, i).toLowerCase() === o && e(t) }) : t => { var n; return !!(null === (n = r.getAttributeValue(t, a)) || void 0 === n ? void 0 : n.startsWith(o)) && e(t) } }, end(e, t, n) { const { adapter: r } = n, { name: a } = t; let { value: o } = t; const i = -o.length; return 0 === i ? boolbase$1.falseFunc : shouldIgnoreCase(t, n) ? (o = o.toLowerCase(), t => { var n; return (null === (n = r.getAttributeValue(t, a)) || void 0 === n ? void 0 : n.substr(i).toLowerCase()) === o && e(t) }) : t => { var n; return !!(null === (n = r.getAttributeValue(t, a)) || void 0 === n ? void 0 : n.endsWith(o)) && e(t) } }, any(e, t, n) { const { adapter: r } = n, { name: a, value: o } = t; if ("" === o) return boolbase$1.falseFunc; if (shouldIgnoreCase(t, n)) { const t = new RegExp(escapeRegex(o), "i"); return function (n) { const i = r.getAttributeValue(n, a); return null != i && i.length >= o.length && t.test(i) && e(n) } } return t => { var n; return !!(null === (n = r.getAttributeValue(t, a)) || void 0 === n ? void 0 : n.includes(o)) && e(t) } }, not(e, t, n) { const { adapter: r } = n, { name: a } = t; let { value: o } = t; return "" === o ? t => !!r.getAttributeValue(t, a) && e(t) : shouldIgnoreCase(t, n) ? (o = o.toLowerCase(), t => { const n = r.getAttributeValue(t, a); return (null == n || n.length !== o.length || n.toLowerCase() !== o) && e(t) }) : t => r.getAttributeValue(t, a) !== o && e(t) } }, whitespace = new Set([9, 10, 12, 13, 32]), ZERO = "0".charCodeAt(0), NINE = "9".charCodeAt(0); function parse$1v(e) { if ("even" === (e = e.trim().toLowerCase())) return [2, 0]; if ("odd" === e) return [2, 1]; let t = 0, n = 0, r = o(), a = i(); if (t < e.length && "n" === e.charAt(t) && (t++, n = r * (null != a ? a : 1), s(), t < e.length ? (r = o(), s(), a = i()) : r = a = 0), null === a || t < e.length) throw new Error(`n-th rule couldn't be parsed ('${e}')`); return [n, r * a]; function o() { return "-" === e.charAt(t) ? (t++, -1) : ("+" === e.charAt(t) && t++, 1) } function i() { const n = t; let r = 0; for (; t < e.length && e.charCodeAt(t) >= ZERO && e.charCodeAt(t) <= NINE;)r = 10 * r + (e.charCodeAt(t) - ZERO), t++; return t === n ? null : r } function s() { for (; t < e.length && whitespace.has(e.charCodeAt(t));)t++ } } function compile$1(e) { const t = e[0], n = e[1] - 1; if (n < 0 && t <= 0) return boolbase$1.falseFunc; if (-1 === t) return e => e <= n; if (0 === t) return e => e === n; if (1 === t) return n < 0 ? boolbase$1.trueFunc : e => e >= n; const r = Math.abs(t), a = (n % r + r) % r; return t > 1 ? e => e >= n && e % r === a : e => e <= n && e % r === a } function nthCheck(e) { return compile$1(parse$1v(e)) } function getChildFunc(e, t) { return n => { const r = t.getParent(n); return null != r && t.isTag(r) && e(n) } } const filters$1 = { contains: (e, t, { adapter: n }) => function (r) { return e(r) && n.getText(r).includes(t) }, icontains(e, t, { adapter: n }) { const r = t.toLowerCase(); return function (t) { return e(t) && n.getText(t).toLowerCase().includes(r) } }, "nth-child"(e, t, { adapter: n, equals: r }) { const a = nthCheck(t); return a === boolbase$1.falseFunc ? boolbase$1.falseFunc : a === boolbase$1.trueFunc ? getChildFunc(e, n) : function (t) { const o = n.getSiblings(t); let i = 0; for (let e = 0; e < o.length && !r(t, o[e]); e++)n.isTag(o[e]) && i++; return a(i) && e(t) } }, "nth-last-child"(e, t, { adapter: n, equals: r }) { const a = nthCheck(t); return a === boolbase$1.falseFunc ? boolbase$1.falseFunc : a === boolbase$1.trueFunc ? getChildFunc(e, n) : function (t) { const o = n.getSiblings(t); let i = 0; for (let e = o.length - 1; e >= 0 && !r(t, o[e]); e--)n.isTag(o[e]) && i++; return a(i) && e(t) } }, "nth-of-type"(e, t, { adapter: n, equals: r }) { const a = nthCheck(t); return a === boolbase$1.falseFunc ? boolbase$1.falseFunc : a === boolbase$1.trueFunc ? getChildFunc(e, n) : function (t) { const o = n.getSiblings(t); let i = 0; for (let e = 0; e < o.length; e++) { const a = o[e]; if (r(t, a)) break; n.isTag(a) && n.getName(a) === n.getName(t) && i++ } return a(i) && e(t) } }, "nth-last-of-type"(e, t, { adapter: n, equals: r }) { const a = nthCheck(t); return a === boolbase$1.falseFunc ? boolbase$1.falseFunc : a === boolbase$1.trueFunc ? getChildFunc(e, n) : function (t) { const o = n.getSiblings(t); let i = 0; for (let e = o.length - 1; e >= 0; e--) { const a = o[e]; if (r(t, a)) break; n.isTag(a) && n.getName(a) === n.getName(t) && i++ } return a(i) && e(t) } }, root: (e, t, { adapter: n }) => t => { const r = n.getParent(t); return (null == r || !n.isTag(r)) && e(t) }, scope(e, t, n, r) { const { equals: a } = n; return r && 0 !== r.length ? 1 === r.length ? t => a(r[0], t) && e(t) : t => r.includes(t) && e(t) : filters$1.root(e, t, n) }, hover: dynamicStatePseudo("isHovered"), visited: dynamicStatePseudo("isVisited"), active: dynamicStatePseudo("isActive") }; function dynamicStatePseudo(e) { return function (t, n, { adapter: r }) { const a = r[e]; return "function" != typeof a ? boolbase$1.falseFunc : function (e) { return a(e) && t(e) } } } const pseudos = { empty: (e, { adapter: t }) => !t.getChildren(e).some((e => t.isTag(e) || "" !== t.getText(e))), "first-child"(e, { adapter: t, equals: n }) { if (t.prevElementSibling) return null == t.prevElementSibling(e); const r = t.getSiblings(e).find((e => t.isTag(e))); return null != r && n(e, r) }, "last-child"(e, { adapter: t, equals: n }) { const r = t.getSiblings(e); for (let a = r.length - 1; a >= 0; a--) { if (n(e, r[a])) return !0; if (t.isTag(r[a])) break } return !1 }, "first-of-type"(e, { adapter: t, equals: n }) { const r = t.getSiblings(e), a = t.getName(e); for (let o = 0; o < r.length; o++) { const i = r[o]; if (n(e, i)) return !0; if (t.isTag(i) && t.getName(i) === a) break } return !1 }, "last-of-type"(e, { adapter: t, equals: n }) { const r = t.getSiblings(e), a = t.getName(e); for (let o = r.length - 1; o >= 0; o--) { const i = r[o]; if (n(e, i)) return !0; if (t.isTag(i) && t.getName(i) === a) break } return !1 }, "only-of-type"(e, { adapter: t, equals: n }) { const r = t.getName(e); return t.getSiblings(e).every((a => n(e, a) || !t.isTag(a) || t.getName(a) !== r)) }, "only-child": (e, { adapter: t, equals: n }) => t.getSiblings(e).every((r => n(e, r) || !t.isTag(r))) }; function verifyPseudoArgs(e, t, n, r) { if (null === n) { if (e.length > r) throw new Error(`Pseudo-class :${t} requires an argument`) } else if (e.length === r) throw new Error(`Pseudo-class :${t} doesn't have any arguments`) } const aliases = { "any-link": ":is(a, area, link)[href]", link: ":any-link:not(:visited)", disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )", enabled: ":not(:disabled)", checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)", required: ":is(input, select, textarea)[required]", optional: ":is(input, select, textarea):not([required])", selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)", checkbox: "[type=checkbox]", file: "[type=file]", password: "[type=password]", radio: "[type=radio]", reset: "[type=reset]", image: "[type=image]", submit: "[type=submit]", parent: ":not(:empty)", header: ":is(h1, h2, h3, h4, h5, h6)", button: ":is(button, input[type=button])", input: ":is(input, textarea, select, button)", text: "input:is(:not([type!='']), [type=text])" }, PLACEHOLDER_ELEMENT = {}; function ensureIsTag(e, t) { return e === boolbase$1.falseFunc ? boolbase$1.falseFunc : n => t.isTag(n) && e(n) } function getNextSiblings(e, t) { const n = t.getSiblings(e); if (n.length <= 1) return []; const r = n.indexOf(e); return r < 0 || r === n.length - 1 ? [] : n.slice(r + 1).filter(t.isTag) } function copyOptions(e) { return { xmlMode: !!e.xmlMode, lowerCaseAttributeNames: !!e.lowerCaseAttributeNames, lowerCaseTags: !!e.lowerCaseTags, quirksMode: !!e.quirksMode, cacheResults: !!e.cacheResults, pseudos: e.pseudos, adapter: e.adapter, equals: e.equals } } const is$1 = (e, t, n, r, a) => { const o = a(t, copyOptions(n), r); return o === boolbase$1.trueFunc ? e : o === boolbase$1.falseFunc ? boolbase$1.falseFunc : t => o(t) && e(t) }, subselects = { is: is$1, matches: is$1, where: is$1, not(e, t, n, r, a) { const o = a(t, copyOptions(n), r); return o === boolbase$1.falseFunc ? e : o === boolbase$1.trueFunc ? boolbase$1.falseFunc : t => !o(t) && e(t) }, has(e, t, n, r, a) { const { adapter: o } = n, i = copyOptions(n); i.relativeSelector = !0; const s = t.some((e => e.some(isTraversal))) ? [PLACEHOLDER_ELEMENT] : void 0, l = a(t, i, s); if (l === boolbase$1.falseFunc) return boolbase$1.falseFunc; const c = ensureIsTag(l, o); if (s && l !== boolbase$1.trueFunc) { const { shouldTestNextSiblings: t = !1 } = l; return n => { if (!e(n)) return !1; s[0] = n; const r = o.getChildren(n), a = t ? [...r, ...getNextSiblings(n, o)] : r; return o.existsOne(c, a) } } return t => e(t) && o.existsOne(c, o.getChildren(t)) } }; function compilePseudoSelector(e, t, n, r, a) { var o; const { name: i, data: s } = t; if (Array.isArray(s)) { if (!(i in subselects)) throw new Error(`Unknown pseudo-class :${i}(${s})`); return subselects[i](e, s, n, r, a) } const l = null === (o = n.pseudos) || void 0 === o ? void 0 : o[i], c = "string" == typeof l ? l : aliases[i]; if ("string" == typeof c) { if (null != s) throw new Error(`Pseudo ${i} doesn't have any arguments`); const t = parse$1w(c); return subselects.is(e, t, n, r, a) } if ("function" == typeof l) return verifyPseudoArgs(l, i, s, 1), t => l(t, s) && e(t); if (i in filters$1) return filters$1[i](e, s, n, r); if (i in pseudos) { const t = pseudos[i]; return verifyPseudoArgs(t, i, s, 2), r => t(r, n, s) && e(r) } throw new Error(`Unknown pseudo-class :${i}`) } function getElementParent(e, t) { const n = t.getParent(e); return n && t.isTag(n) ? n : null } function compileGeneralSelector(e, t, n, r, a) { const { adapter: o, equals: i } = n; switch (t.type) { case SelectorType.PseudoElement: throw new Error("Pseudo-elements are not supported by css-select"); case SelectorType.ColumnCombinator: throw new Error("Column combinators are not yet supported by css-select"); case SelectorType.Attribute: if (null != t.namespace) throw new Error("Namespaced attributes are not yet supported by css-select"); return n.xmlMode && !n.lowerCaseAttributeNames || (t.name = t.name.toLowerCase()), attributeRules[t.action](e, t, n); case SelectorType.Pseudo: return compilePseudoSelector(e, t, n, r, a); case SelectorType.Tag: { if (null != t.namespace) throw new Error("Namespaced tag names are not yet supported by css-select"); let { name: r } = t; return n.xmlMode && !n.lowerCaseTags || (r = r.toLowerCase()), function (t) { return o.getName(t) === r && e(t) } } case SelectorType.Descendant: { if (!1 === n.cacheResults || "undefined" == typeof WeakSet) return function (t) { let n = t; for (; n = getElementParent(n, o);)if (e(n)) return !0; return !1 }; const t = new WeakSet; return function (n) { let r = n; for (; r = getElementParent(r, o);)if (!t.has(r)) { if (o.isTag(r) && e(r)) return !0; t.add(r) } return !1 } } case "_flexibleDescendant": return function (t) { let n = t; do { if (e(n)) return !0 } while (n = getElementParent(n, o)); return !1 }; case SelectorType.Parent: return function (t) { return o.getChildren(t).some((t => o.isTag(t) && e(t))) }; case SelectorType.Child: return function (t) { const n = o.getParent(t); return null != n && o.isTag(n) && e(n) }; case SelectorType.Sibling: return function (t) { const n = o.getSiblings(t); for (let r = 0; r < n.length; r++) { const a = n[r]; if (i(t, a)) break; if (o.isTag(a) && e(a)) return !0 } return !1 }; case SelectorType.Adjacent: return o.prevElementSibling ? function (t) { const n = o.prevElementSibling(t); return null != n && e(n) } : function (t) { const n = o.getSiblings(t); let r; for (let e = 0; e < n.length; e++) { const a = n[e]; if (i(t, a)) break; o.isTag(a) && (r = a) } return !!r && e(r) }; case SelectorType.Universal: if (null != t.namespace && "*" !== t.namespace) throw new Error("Namespaced universal selectors are not yet supported by css-select"); return e } } function compile(e, t, n) { return ensureIsTag(compileUnsafe(e, t, n), t.adapter) } function compileUnsafe(e, t, n) { return compileToken("string" == typeof e ? parse$1w(e) : e, t, n) } function includesScopePseudo(e) { return e.type === SelectorType.Pseudo && ("scope" === e.name || Array.isArray(e.data) && e.data.some((e => e.some(includesScopePseudo)))) } const DESCENDANT_TOKEN = { type: SelectorType.Descendant }, FLEXIBLE_DESCENDANT_TOKEN = { type: "_flexibleDescendant" }, SCOPE_TOKEN = { type: SelectorType.Pseudo, name: "scope", data: null }; function absolutize(e, { adapter: t }, n) { const r = !!(null == n ? void 0 : n.every((e => { const n = t.isTag(e) && t.getParent(e); return e === PLACEHOLDER_ELEMENT || n && t.isTag(n) }))); for (const t of e) { if (t.length > 0 && isTraversal(t[0]) && t[0].type !== SelectorType.Descendant); else { if (!r || t.some(includesScopePseudo)) continue; t.unshift(DESCENDANT_TOKEN) } t.unshift(SCOPE_TOKEN) } } function compileToken(e, t, n) { var r; e.forEach(sortByProcedure), n = null !== (r = t.context) && void 0 !== r ? r : n; const a = Array.isArray(n), o = n && (Array.isArray(n) ? n : [n]); if (!1 !== t.relativeSelector) absolutize(e, t, o); else if (e.some((e => e.length > 0 && isTraversal(e[0])))) throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled"); let i = !1; const s = e.map((e => { if (e.length >= 2) { const [t, n] = e; t.type !== SelectorType.Pseudo || "scope" !== t.name || (a && n.type === SelectorType.Descendant ? e[1] = FLEXIBLE_DESCENDANT_TOKEN : n.type !== SelectorType.Adjacent && n.type !== SelectorType.Sibling || (i = !0)) } return compileRules(e, t, o) })).reduce(reduceRules, boolbase$1.falseFunc); return s.shouldTestNextSiblings = i, s } function compileRules(e, t, n) { var r; return e.reduce(((e, r) => e === boolbase$1.falseFunc ? boolbase$1.falseFunc : compileGeneralSelector(e, r, t, n, compileToken)), null !== (r = t.rootFunc) && void 0 !== r ? r : boolbase$1.trueFunc) } function reduceRules(e, t) { return t === boolbase$1.falseFunc || e === boolbase$1.trueFunc ? e : e === boolbase$1.falseFunc || t === boolbase$1.trueFunc ? t : function (n) { return e(n) || t(n) } } const defaultEquals = (e, t) => e === t, defaultOptions = { adapter: DomUtils, equals: defaultEquals }; function convertOptionFormats(e) { var t, n, r, a; const o = null != e ? e : defaultOptions; return null !== (t = o.adapter) && void 0 !== t || (o.adapter = DomUtils), null !== (n = o.equals) && void 0 !== n || (o.equals = null !== (a = null === (r = o.adapter) || void 0 === r ? void 0 : r.equals) && void 0 !== a ? a : defaultEquals), o } function getSelectorFunc(e) { return function (t, n, r) { const a = convertOptionFormats(r); "function" != typeof t && (t = compileUnsafe(t, a, n)); const o = prepareContext(n, a.adapter, t.shouldTestNextSiblings); return e(t, o, a) } } function prepareContext(e, t, n = !1) { return n && (e = appendNextSiblings(e, t)), Array.isArray(e) ? t.removeSubsets(e) : t.getChildren(e) } function appendNextSiblings(e, t) { const n = Array.isArray(e) ? e.slice(0) : [e], r = n.length; for (let e = 0; e < r; e++) { const r = getNextSiblings(n[e], t); n.push(...r) } return n } const selectAll = getSelectorFunc(((e, t, n) => e !== boolbase$1.falseFunc && t && 0 !== t.length ? n.adapter.findAll(e, t) : [])), selectOne = getSelectorFunc(((e, t, n) => e !== boolbase$1.falseFunc && t && 0 !== t.length ? n.adapter.findOne(e, t) : null)); function is(e, t, n) { const r = convertOptionFormats(n); return ("function" == typeof t ? t : compile(t, r))(e) } function mapNodesToParents(e) { const t = new Map; for (const n of e.children) t.set(n, e), visit(n, { element: { enter: (e, n) => { t.set(e, n) } } }, e); return t } const isTag = e => "element" === e.type, existsOne = (e, t) => t.some((t => isTag(t) && (e(t) || existsOne(e, getChildren(t))))), getAttributeValue = (e, t) => e.attributes[t], getChildren = e => e.children || [], getName = e => e.name, getText = e => "text" === e.children[0].type || "cdata" === e.children[0].type ? e.children[0].value : "", hasAttrib = (e, t) => void 0 !== e.attributes[t], findAll$3 = (e, t) => { const n = []; for (const r of t) isTag(r) && (e(r) && n.push(r), n.push(...findAll$3(e, getChildren(r)))); return n }, findOne = (e, t) => { for (const n of t) if (isTag(n)) { if (e(n)) return n; const t = findOne(e, getChildren(n)); if (t) return t } return null }; function createAdapter(e, t) { const n = n => (t || (t = mapNodesToParents(e)), t.get(n) || null); return { isTag: isTag, existsOne: existsOne, getAttributeValue: getAttributeValue, getChildren: getChildren, getName: getName, getParent: n, getSiblings: e => { const t = n(e); return t ? getChildren(t) : [] }, getText: getText, hasAttrib: hasAttrib, removeSubsets: e => { let t, r, a, o = e.length; for (; --o > -1;) { for (t = r = e[o], e[o] = null, a = !0; r;) { if (e.includes(r)) { a = !1, e.splice(o, 1); break } r = n(r) } a && (e[o] = t) } return e }, findAll: findAll$3, findOne: findOne } } function createCssSelectOptions(e, t) { return { xmlMode: !0, adapter: createAdapter(e, t) } } const querySelectorAll = (e, t, n) => selectAll(t, e, createCssSelectOptions(e, n)), querySelector = (e, t, n) => selectOne(t, e, createCssSelectOptions(e, n)), matches = (e, t, n) => is(e, t, createCssSelectOptions(e, n)), detachNodeFromParent = (e, t) => { t.children = t.children.filter((t => t !== e)) }, name$2d = "removeDoctype", description$Q = "removes doctype declaration", fn$Q = () => ({ doctype: { enter: (e, t) => { detachNodeFromParent(e, t) } } }); var removeDoctype = Object.freeze({ __proto__: null, description: description$Q, fn: fn$Q, name: name$2d }); const name$2c = "removeXMLProcInst", description$P = "removes XML processing instructions", fn$P = () => ({ instruction: { enter: (e, t) => { "xml" === e.name && detachNodeFromParent(e, t) } } }); var removeXMLProcInst = Object.freeze({ __proto__: null, description: description$P, fn: fn$P, name: name$2c }); const name$2b = "removeComments", description$O = "removes comments", DEFAULT_PRESERVE_PATTERNS = [/^!/], fn$O = (e, t) => { const { preservePatterns: n = DEFAULT_PRESERVE_PATTERNS } = t; return { comment: { enter: (e, t) => { if (n) { if (!Array.isArray(n)) throw Error(`Expected array in removeComments preservePatterns parameter but received ${n}`); if (n.some((t => new RegExp(t).test(e.value)))) return } detachNodeFromParent(e, t) } } } }; var removeComments = Object.freeze({ __proto__: null, description: description$O, fn: fn$O, name: name$2b }); const elemsGroups = { animation: new Set(["animate", "animateColor", "animateMotion", "animateTransform", "set"]), descriptive: new Set(["desc", "metadata", "title"]), shape: new Set(["circle", "ellipse", "line", "path", "polygon", "polyline", "rect"]), structural: new Set(["defs", "g", "svg", "symbol", "use"]), paintServer: new Set(["hatch", "linearGradient", "meshGradient", "pattern", "radialGradient", "solidColor"]), nonRendering: new Set(["clipPath", "filter", "linearGradient", "marker", "mask", "pattern", "radialGradient", "solidColor", "symbol"]), container: new Set(["a", "defs", "foreignObject", "g", "marker", "mask", "missing-glyph", "pattern", "svg", "switch", "symbol"]), textContent: new Set(["a", "altGlyph", "altGlyphDef", "altGlyphItem", "glyph", "glyphRef", "text", "textPath", "tref", "tspan"]), textContentChild: new Set(["altGlyph", "textPath", "tref", "tspan"]), lightSource: new Set(["feDiffuseLighting", "feDistantLight", "fePointLight", "feSpecularLighting", "feSpotLight"]), filterPrimitive: new Set(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "feSpecularLighting", "feTile", "feTurbulence"]) }, textElems = new Set([...elemsGroups.textContent, "pre", "title"]), pathElems = new Set(["glyph", "missing-glyph", "path"]), attrsGroups = { animationAddition: new Set(["additive", "accumulate"]), animationAttributeTarget: new Set(["attributeType", "attributeName"]), animationEvent: new Set(["onbegin", "onend", "onrepeat", "onload"]), animationTiming: new Set(["begin", "dur", "end", "fill", "max", "min", "repeatCount", "repeatDur", "restart"]), animationValue: new Set(["by", "calcMode", "from", "keySplines", "keyTimes", "to", "values"]), conditionalProcessing: new Set(["requiredExtensions", "requiredFeatures", "systemLanguage"]), core: new Set(["id", "tabindex", "xml:base", "xml:lang", "xml:space"]), graphicalEvent: new Set(["onactivate", "onclick", "onfocusin", "onfocusout", "onload", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup"]), presentation: new Set(["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "clip", "color-interpolation-filters", "color-interpolation", "color-profile", "color-rendering", "color", "cursor", "direction", "display", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "fill", "filter", "flood-color", "flood-opacity", "font-family", "font-size-adjust", "font-size", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-orientation-horizontal", "glyph-orientation-vertical", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "stroke", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform-origin", "transform", "unicode-bidi", "vector-effect", "visibility", "word-spacing", "writing-mode"]), xlink: new Set(["xlink:actuate", "xlink:arcrole", "xlink:href", "xlink:role", "xlink:show", "xlink:title", "xlink:type"]), documentEvent: new Set(["onabort", "onerror", "onresize", "onscroll", "onunload", "onzoom"]), documentElementEvent: new Set(["oncopy", "oncut", "onpaste"]), globalEvent: new Set(["oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncuechange", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onseeked", "onseeking", "onselect", "onshow", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "onvolumechange", "onwaiting"]), filterPrimitive: new Set(["x", "y", "width", "height", "result"]), transferFunction: new Set(["amplitude", "exponent", "intercept", "offset", "slope", "tableValues", "type"]) }, attrsGroupsDefaults = { core: { "xml:space": "default" }, presentation: { clip: "auto", "clip-path": "none", "clip-rule": "nonzero", mask: "none", opacity: "1", "stop-color": "#000", "stop-opacity": "1", "fill-opacity": "1", "fill-rule": "nonzero", fill: "#000", stroke: "none", "stroke-width": "1", "stroke-linecap": "butt", "stroke-linejoin": "miter", "stroke-miterlimit": "4", "stroke-dasharray": "none", "stroke-dashoffset": "0", "stroke-opacity": "1", "paint-order": "normal", "vector-effect": "none", display: "inline", visibility: "visible", "marker-start": "none", "marker-mid": "none", "marker-end": "none", "color-interpolation": "sRGB", "color-interpolation-filters": "linearRGB", "color-rendering": "auto", "shape-rendering": "auto", "text-rendering": "auto", "image-rendering": "auto", "font-style": "normal", "font-variant": "normal", "font-weight": "normal", "font-stretch": "normal", "font-size": "medium", "font-size-adjust": "none", kerning: "auto", "letter-spacing": "normal", "word-spacing": "normal", "text-decoration": "none", "text-anchor": "start", "text-overflow": "clip", "writing-mode": "lr-tb", "glyph-orientation-vertical": "auto", "glyph-orientation-horizontal": "0deg", direction: "ltr", "unicode-bidi": "normal", "dominant-baseline": "auto", "alignment-baseline": "baseline", "baseline-shift": "baseline" }, transferFunction: { slope: "1", intercept: "0", amplitude: "1", exponent: "1", offset: "0" } }, attrsGroupsDeprecated = { animationAttributeTarget: { unsafe: new Set(["attributeType"]) }, conditionalProcessing: { unsafe: new Set(["requiredFeatures"]) }, core: { unsafe: new Set(["xml:base", "xml:lang", "xml:space"]) }, presentation: { unsafe: new Set(["clip", "color-profile", "enable-background", "glyph-orientation-horizontal", "glyph-orientation-vertical", "kerning"]) } }, elems = { a: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation", "xlink"]), attrs: new Set(["class", "externalResourcesRequired", "style", "target", "transform"]), defaults: { target: "_self" }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view", "tspan"]) }, altGlyph: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation", "xlink"]), attrs: new Set(["class", "dx", "dy", "externalResourcesRequired", "format", "glyphRef", "rotate", "style", "x", "y"]) }, altGlyphDef: { attrsGroups: new Set(["core"]), content: new Set(["glyphRef"]) }, altGlyphItem: { attrsGroups: new Set(["core"]), content: new Set(["glyphRef", "altGlyphItem"]) }, animate: { attrsGroups: new Set(["animationAddition", "animationAttributeTarget", "animationEvent", "animationTiming", "animationValue", "conditionalProcessing", "core", "presentation", "xlink"]), attrs: new Set(["externalResourcesRequired"]), contentGroups: new Set(["descriptive"]) }, animateColor: { attrsGroups: new Set(["animationAddition", "animationAttributeTarget", "animationEvent", "animationTiming", "animationValue", "conditionalProcessing", "core", "presentation", "xlink"]), attrs: new Set(["externalResourcesRequired"]), contentGroups: new Set(["descriptive"]) }, animateMotion: { attrsGroups: new Set(["animationAddition", "animationEvent", "animationTiming", "animationValue", "conditionalProcessing", "core", "xlink"]), attrs: new Set(["externalResourcesRequired", "keyPoints", "origin", "path", "rotate"]), defaults: { rotate: "0" }, contentGroups: new Set(["descriptive"]), content: new Set(["mpath"]) }, animateTransform: { attrsGroups: new Set(["animationAddition", "animationAttributeTarget", "animationEvent", "animationTiming", "animationValue", "conditionalProcessing", "core", "xlink"]), attrs: new Set(["externalResourcesRequired", "type"]), contentGroups: new Set(["descriptive"]) }, circle: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "cx", "cy", "externalResourcesRequired", "r", "style", "transform"]), defaults: { cx: "0", cy: "0" }, contentGroups: new Set(["animation", "descriptive"]) }, clipPath: { attrsGroups: new Set(["conditionalProcessing", "core", "presentation"]), attrs: new Set(["class", "clipPathUnits", "externalResourcesRequired", "style", "transform"]), defaults: { clipPathUnits: "userSpaceOnUse" }, contentGroups: new Set(["animation", "descriptive", "shape"]), content: new Set(["text", "use"]) }, "color-profile": { attrsGroups: new Set(["core", "xlink"]), attrs: new Set(["local", "name", "rendering-intent"]), defaults: { name: "sRGB", "rendering-intent": "auto" }, deprecated: { unsafe: new Set(["name"]) }, contentGroups: new Set(["descriptive"]) }, cursor: { attrsGroups: new Set(["core", "conditionalProcessing", "xlink"]), attrs: new Set(["externalResourcesRequired", "x", "y"]), defaults: { x: "0", y: "0" }, contentGroups: new Set(["descriptive"]) }, defs: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "style", "transform"]), contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, desc: { attrsGroups: new Set(["core"]), attrs: new Set(["class", "style"]) }, ellipse: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "cx", "cy", "externalResourcesRequired", "rx", "ry", "style", "transform"]), defaults: { cx: "0", cy: "0" }, contentGroups: new Set(["animation", "descriptive"]) }, feBlend: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style", "in", "in2", "mode"]), defaults: { mode: "normal" }, content: new Set(["animate", "set"]) }, feColorMatrix: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style", "in", "type", "values"]), defaults: { type: "matrix" }, content: new Set(["animate", "set"]) }, feComponentTransfer: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style", "in"]), content: new Set(["feFuncA", "feFuncB", "feFuncG", "feFuncR"]) }, feComposite: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "in", "in2", "k1", "k2", "k3", "k4", "operator", "style"]), defaults: { operator: "over", k1: "0", k2: "0", k3: "0", k4: "0" }, content: new Set(["animate", "set"]) }, feConvolveMatrix: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "in", "kernelMatrix", "order", "style", "bias", "divisor", "edgeMode", "targetX", "targetY", "kernelUnitLength", "preserveAlpha"]), defaults: { order: "3", bias: "0", edgeMode: "duplicate", preserveAlpha: "false" }, content: new Set(["animate", "set"]) }, feDiffuseLighting: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "diffuseConstant", "in", "kernelUnitLength", "style", "surfaceScale"]), defaults: { surfaceScale: "1", diffuseConstant: "1" }, contentGroups: new Set(["descriptive"]), content: new Set(["feDistantLight", "fePointLight", "feSpotLight"]) }, feDisplacementMap: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "in", "in2", "scale", "style", "xChannelSelector", "yChannelSelector"]), defaults: { scale: "0", xChannelSelector: "A", yChannelSelector: "A" }, content: new Set(["animate", "set"]) }, feDistantLight: { attrsGroups: new Set(["core"]), attrs: new Set(["azimuth", "elevation"]), defaults: { azimuth: "0", elevation: "0" }, content: new Set(["animate", "set"]) }, feFlood: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style"]), content: new Set(["animate", "animateColor", "set"]) }, feFuncA: { attrsGroups: new Set(["core", "transferFunction"]), content: new Set(["set", "animate"]) }, feFuncB: { attrsGroups: new Set(["core", "transferFunction"]), content: new Set(["set", "animate"]) }, feFuncG: { attrsGroups: new Set(["core", "transferFunction"]), content: new Set(["set", "animate"]) }, feFuncR: { attrsGroups: new Set(["core", "transferFunction"]), content: new Set(["set", "animate"]) }, feGaussianBlur: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style", "in", "stdDeviation"]), defaults: { stdDeviation: "0" }, content: new Set(["set", "animate"]) }, feImage: { attrsGroups: new Set(["core", "presentation", "filterPrimitive", "xlink"]), attrs: new Set(["class", "externalResourcesRequired", "href", "preserveAspectRatio", "style", "xlink:href"]), defaults: { preserveAspectRatio: "xMidYMid meet" }, content: new Set(["animate", "animateTransform", "set"]) }, feMerge: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style"]), content: new Set(["feMergeNode"]) }, feMergeNode: { attrsGroups: new Set(["core"]), attrs: new Set(["in"]), content: new Set(["animate", "set"]) }, feMorphology: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style", "in", "operator", "radius"]), defaults: { operator: "erode", radius: "0" }, content: new Set(["animate", "set"]) }, feOffset: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style", "in", "dx", "dy"]), defaults: { dx: "0", dy: "0" }, content: new Set(["animate", "set"]) }, fePointLight: { attrsGroups: new Set(["core"]), attrs: new Set(["x", "y", "z"]), defaults: { x: "0", y: "0", z: "0" }, content: new Set(["animate", "set"]) }, feSpecularLighting: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "in", "kernelUnitLength", "specularConstant", "specularExponent", "style", "surfaceScale"]), defaults: { surfaceScale: "1", specularConstant: "1", specularExponent: "1" }, contentGroups: new Set(["descriptive", "lightSource"]) }, feSpotLight: { attrsGroups: new Set(["core"]), attrs: new Set(["limitingConeAngle", "pointsAtX", "pointsAtY", "pointsAtZ", "specularExponent", "x", "y", "z"]), defaults: { x: "0", y: "0", z: "0", pointsAtX: "0", pointsAtY: "0", pointsAtZ: "0", specularExponent: "1" }, content: new Set(["animate", "set"]) }, feTile: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["class", "style", "in"]), content: new Set(["animate", "set"]) }, feTurbulence: { attrsGroups: new Set(["core", "presentation", "filterPrimitive"]), attrs: new Set(["baseFrequency", "class", "numOctaves", "seed", "stitchTiles", "style", "type"]), defaults: { baseFrequency: "0", numOctaves: "1", seed: "0", stitchTiles: "noStitch", type: "turbulence" }, content: new Set(["animate", "set"]) }, filter: { attrsGroups: new Set(["core", "presentation", "xlink"]), attrs: new Set(["class", "externalResourcesRequired", "filterRes", "filterUnits", "height", "href", "primitiveUnits", "style", "width", "x", "xlink:href", "y"]), defaults: { primitiveUnits: "userSpaceOnUse", x: "-10%", y: "-10%", width: "120%", height: "120%" }, deprecated: { unsafe: new Set(["filterRes"]) }, contentGroups: new Set(["descriptive", "filterPrimitive"]), content: new Set(["animate", "set"]) }, font: { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "horiz-adv-x", "horiz-origin-x", "horiz-origin-y", "style", "vert-adv-y", "vert-origin-x", "vert-origin-y"]), defaults: { "horiz-origin-x": "0", "horiz-origin-y": "0" }, deprecated: { unsafe: new Set(["horiz-origin-x", "horiz-origin-y", "vert-adv-y", "vert-origin-x", "vert-origin-y"]) }, contentGroups: new Set(["descriptive"]), content: new Set(["font-face", "glyph", "hkern", "missing-glyph", "vkern"]) }, "font-face": { attrsGroups: new Set(["core"]), attrs: new Set(["font-family", "font-style", "font-variant", "font-weight", "font-stretch", "font-size", "unicode-range", "units-per-em", "panose-1", "stemv", "stemh", "slope", "cap-height", "x-height", "accent-height", "ascent", "descent", "widths", "bbox", "ideographic", "alphabetic", "mathematical", "hanging", "v-ideographic", "v-alphabetic", "v-mathematical", "v-hanging", "underline-position", "underline-thickness", "strikethrough-position", "strikethrough-thickness", "overline-position", "overline-thickness"]), defaults: { "font-style": "all", "font-variant": "normal", "font-weight": "all", "font-stretch": "normal", "unicode-range": "U+0-10FFFF", "units-per-em": "1000", "panose-1": "0 0 0 0 0 0 0 0 0 0", slope: "0" }, deprecated: { unsafe: new Set(["accent-height", "alphabetic", "ascent", "bbox", "cap-height", "descent", "hanging", "ideographic", "mathematical", "panose-1", "slope", "stemh", "stemv", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "widths", "x-height"]) }, contentGroups: new Set(["descriptive"]), content: new Set(["font-face-src"]) }, "font-face-format": { attrsGroups: new Set(["core"]), attrs: new Set(["string"]), deprecated: { unsafe: new Set(["string"]) } }, "font-face-name": { attrsGroups: new Set(["core"]), attrs: new Set(["name"]), deprecated: { unsafe: new Set(["name"]) } }, "font-face-src": { attrsGroups: new Set(["core"]), content: new Set(["font-face-name", "font-face-uri"]) }, "font-face-uri": { attrsGroups: new Set(["core", "xlink"]), attrs: new Set(["href", "xlink:href"]), content: new Set(["font-face-format"]) }, foreignObject: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "height", "style", "transform", "width", "x", "y"]), defaults: { x: "0", y: "0" } }, g: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "style", "transform"]), contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, glyph: { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["arabic-form", "class", "d", "glyph-name", "horiz-adv-x", "lang", "orientation", "style", "unicode", "vert-adv-y", "vert-origin-x", "vert-origin-y"]), defaults: { "arabic-form": "initial" }, deprecated: { unsafe: new Set(["arabic-form", "glyph-name", "horiz-adv-x", "orientation", "unicode", "vert-adv-y", "vert-origin-x", "vert-origin-y"]) }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, glyphRef: { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["class", "d", "horiz-adv-x", "style", "vert-adv-y", "vert-origin-x", "vert-origin-y"]), deprecated: { unsafe: new Set(["horiz-adv-x", "vert-adv-y", "vert-origin-x", "vert-origin-y"]) }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, hatch: { attrsGroups: new Set(["core", "presentation", "xlink"]), attrs: new Set(["class", "hatchContentUnits", "hatchUnits", "pitch", "rotate", "style", "transform", "x", "y"]), defaults: { hatchUnits: "objectBoundingBox", hatchContentUnits: "userSpaceOnUse", x: "0", y: "0", pitch: "0", rotate: "0" }, contentGroups: new Set(["animation", "descriptive"]), content: new Set(["hatchPath"]) }, hatchPath: { attrsGroups: new Set(["core", "presentation", "xlink"]), attrs: new Set(["class", "style", "d", "offset"]), defaults: { offset: "0" }, contentGroups: new Set(["animation", "descriptive"]) }, hkern: { attrsGroups: new Set(["core"]), attrs: new Set(["u1", "g1", "u2", "g2", "k"]), deprecated: { unsafe: new Set(["g1", "g2", "k", "u1", "u2"]) } }, image: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation", "xlink"]), attrs: new Set(["class", "externalResourcesRequired", "height", "href", "preserveAspectRatio", "style", "transform", "width", "x", "xlink:href", "y"]), defaults: { x: "0", y: "0", preserveAspectRatio: "xMidYMid meet" }, contentGroups: new Set(["animation", "descriptive"]) }, line: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "style", "transform", "x1", "x2", "y1", "y2"]), defaults: { x1: "0", y1: "0", x2: "0", y2: "0" }, contentGroups: new Set(["animation", "descriptive"]) }, linearGradient: { attrsGroups: new Set(["core", "presentation", "xlink"]), attrs: new Set(["class", "externalResourcesRequired", "gradientTransform", "gradientUnits", "href", "spreadMethod", "style", "x1", "x2", "xlink:href", "y1", "y2"]), defaults: { x1: "0", y1: "0", x2: "100%", y2: "0", spreadMethod: "pad" }, contentGroups: new Set(["descriptive"]), content: new Set(["animate", "animateTransform", "set", "stop"]) }, marker: { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "markerHeight", "markerUnits", "markerWidth", "orient", "preserveAspectRatio", "refX", "refY", "style", "viewBox"]), defaults: { markerUnits: "strokeWidth", refX: "0", refY: "0", markerWidth: "3", markerHeight: "3" }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, mask: { attrsGroups: new Set(["conditionalProcessing", "core", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "height", "mask-type", "maskContentUnits", "maskUnits", "style", "width", "x", "y"]), defaults: { maskUnits: "objectBoundingBox", maskContentUnits: "userSpaceOnUse", x: "-10%", y: "-10%", width: "120%", height: "120%" }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, metadata: { attrsGroups: new Set(["core"]) }, "missing-glyph": { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["class", "d", "horiz-adv-x", "style", "vert-adv-y", "vert-origin-x", "vert-origin-y"]), deprecated: { unsafe: new Set(["horiz-adv-x", "vert-adv-y", "vert-origin-x", "vert-origin-y"]) }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, mpath: { attrsGroups: new Set(["core", "xlink"]), attrs: new Set(["externalResourcesRequired", "href", "xlink:href"]), contentGroups: new Set(["descriptive"]) }, path: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "d", "externalResourcesRequired", "pathLength", "style", "transform"]), contentGroups: new Set(["animation", "descriptive"]) }, pattern: { attrsGroups: new Set(["conditionalProcessing", "core", "presentation", "xlink"]), attrs: new Set(["class", "externalResourcesRequired", "height", "href", "patternContentUnits", "patternTransform", "patternUnits", "preserveAspectRatio", "style", "viewBox", "width", "x", "xlink:href", "y"]), defaults: { patternUnits: "objectBoundingBox", patternContentUnits: "userSpaceOnUse", x: "0", y: "0", width: "0", height: "0", preserveAspectRatio: "xMidYMid meet" }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, polygon: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "points", "style", "transform"]), contentGroups: new Set(["animation", "descriptive"]) }, polyline: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "points", "style", "transform"]), contentGroups: new Set(["animation", "descriptive"]) }, radialGradient: { attrsGroups: new Set(["core", "presentation", "xlink"]), attrs: new Set(["class", "cx", "cy", "externalResourcesRequired", "fr", "fx", "fy", "gradientTransform", "gradientUnits", "href", "r", "spreadMethod", "style", "xlink:href"]), defaults: { gradientUnits: "objectBoundingBox", cx: "50%", cy: "50%", r: "50%" }, contentGroups: new Set(["descriptive"]), content: new Set(["animate", "animateTransform", "set", "stop"]) }, meshGradient: { attrsGroups: new Set(["core", "presentation", "xlink"]), attrs: new Set(["class", "style", "x", "y", "gradientUnits", "transform"]), contentGroups: new Set(["descriptive", "paintServer", "animation"]), content: new Set(["meshRow"]) }, meshRow: { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["class", "style"]), contentGroups: new Set(["descriptive"]), content: new Set(["meshPatch"]) }, meshPatch: { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["class", "style"]), contentGroups: new Set(["descriptive"]), content: new Set(["stop"]) }, rect: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "height", "rx", "ry", "style", "transform", "width", "x", "y"]), defaults: { x: "0", y: "0" }, contentGroups: new Set(["animation", "descriptive"]) }, script: { attrsGroups: new Set(["core", "xlink"]), attrs: new Set(["externalResourcesRequired", "type", "href", "xlink:href"]) }, set: { attrsGroups: new Set(["animation", "animationAttributeTarget", "animationTiming", "conditionalProcessing", "core", "xlink"]), attrs: new Set(["externalResourcesRequired", "to"]), contentGroups: new Set(["descriptive"]) }, solidColor: { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["class", "style"]), contentGroups: new Set(["paintServer"]) }, stop: { attrsGroups: new Set(["core", "presentation"]), attrs: new Set(["class", "style", "offset", "path"]), content: new Set(["animate", "animateColor", "set"]) }, style: { attrsGroups: new Set(["core"]), attrs: new Set(["type", "media", "title"]), defaults: { type: "text/css" } }, svg: { attrsGroups: new Set(["conditionalProcessing", "core", "documentEvent", "graphicalEvent", "presentation"]), attrs: new Set(["baseProfile", "class", "contentScriptType", "contentStyleType", "height", "preserveAspectRatio", "style", "version", "viewBox", "width", "x", "y", "zoomAndPan"]), defaults: { x: "0", y: "0", width: "100%", height: "100%", preserveAspectRatio: "xMidYMid meet", zoomAndPan: "magnify", version: "1.1", baseProfile: "none", contentScriptType: "application/ecmascript", contentStyleType: "text/css" }, deprecated: { safe: new Set(["version"]), unsafe: new Set(["baseProfile", "contentScriptType", "contentStyleType", "zoomAndPan"]) }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, switch: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "style", "transform"]), contentGroups: new Set(["animation", "descriptive", "shape"]), content: new Set(["a", "foreignObject", "g", "image", "svg", "switch", "text", "use"]) }, symbol: { attrsGroups: new Set(["core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "externalResourcesRequired", "preserveAspectRatio", "refX", "refY", "style", "viewBox"]), defaults: { refX: "0", refY: "0" }, contentGroups: new Set(["animation", "descriptive", "paintServer", "shape", "structural"]), content: new Set(["a", "altGlyphDef", "clipPath", "color-profile", "cursor", "filter", "font-face", "font", "foreignObject", "image", "marker", "mask", "pattern", "script", "style", "switch", "text", "view"]) }, text: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "dx", "dy", "externalResourcesRequired", "lengthAdjust", "rotate", "style", "textLength", "transform", "x", "y"]), defaults: { x: "0", y: "0", lengthAdjust: "spacing" }, contentGroups: new Set(["animation", "descriptive", "textContentChild"]), content: new Set(["a"]) }, textPath: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation", "xlink"]), attrs: new Set(["class", "d", "externalResourcesRequired", "href", "method", "spacing", "startOffset", "style", "xlink:href"]), defaults: { startOffset: "0", method: "align", spacing: "exact" }, contentGroups: new Set(["descriptive"]), content: new Set(["a", "altGlyph", "animate", "animateColor", "set", "tref", "tspan"]) }, title: { attrsGroups: new Set(["core"]), attrs: new Set(["class", "style"]) }, tref: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation", "xlink"]), attrs: new Set(["class", "externalResourcesRequired", "href", "style", "xlink:href"]), contentGroups: new Set(["descriptive"]), content: new Set(["animate", "animateColor", "set"]) }, tspan: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation"]), attrs: new Set(["class", "dx", "dy", "externalResourcesRequired", "lengthAdjust", "rotate", "style", "textLength", "x", "y"]), contentGroups: new Set(["descriptive"]), content: new Set(["a", "altGlyph", "animate", "animateColor", "set", "tref", "tspan"]) }, use: { attrsGroups: new Set(["conditionalProcessing", "core", "graphicalEvent", "presentation", "xlink"]), attrs: new Set(["class", "externalResourcesRequired", "height", "href", "style", "transform", "width", "x", "xlink:href", "y"]), defaults: { x: "0", y: "0" }, contentGroups: new Set(["animation", "descriptive"]) }, view: { attrsGroups: new Set(["core"]), attrs: new Set(["externalResourcesRequired", "preserveAspectRatio", "viewBox", "viewTarget", "zoomAndPan"]), deprecated: { unsafe: new Set(["viewTarget", "zoomAndPan"]) }, contentGroups: new Set(["descriptive"]) }, vkern: { attrsGroups: new Set(["core"]), attrs: new Set(["u1", "g1", "u2", "g2", "k"]), deprecated: { unsafe: new Set(["g1", "g2", "k", "u1", "u2"]) } } }, editorNamespaces = new Set(["http://creativecommons.org/ns#", "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd", "http://krita.org/namespaces/svg/krita", "http://ns.adobe.com/AdobeIllustrator/10.0/", "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/", "http://ns.adobe.com/Extensibility/1.0/", "http://ns.adobe.com/Flows/1.0/", "http://ns.adobe.com/GenericCustomNamespace/1.0/", "http://ns.adobe.com/Graphs/1.0/", "http://ns.adobe.com/ImageReplacement/1.0/", "http://ns.adobe.com/SaveForWeb/1.0/", "http://ns.adobe.com/Variables/1.0/", "http://ns.adobe.com/XPath/1.0/", "http://purl.org/dc/elements/1.1/", "http://schemas.microsoft.com/visio/2003/SVGExtensions/", "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd", "http://taptrix.com/vectorillustrator/svg_extensions", "http://www.bohemiancoding.com/sketch/ns", "http://www.figma.com/figma/ns", "http://www.inkscape.org/namespaces/inkscape", "http://www.serif.com/", "http://www.vector.evaxdesign.sk", "http://www.w3.org/1999/02/22-rdf-syntax-ns#", "https://boxy-svg.com"]), referencesProps = new Set(["clip-path", "color-profile", "fill", "filter", "marker-end", "marker-mid", "marker-start", "mask", "stroke", "style"]), inheritableAttrs = new Set(["clip-rule", "color-interpolation-filters", "color-interpolation", "color-profile", "color-rendering", "color", "cursor", "direction", "dominant-baseline", "fill-opacity", "fill-rule", "fill", "font-family", "font-size-adjust", "font-size", "font-stretch", "font-style", "font-variant", "font-weight", "font", "glyph-orientation-horizontal", "glyph-orientation-vertical", "image-rendering", "letter-spacing", "marker-end", "marker-mid", "marker-start", "marker", "paint-order", "pointer-events", "shape-rendering", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "stroke", "text-anchor", "text-rendering", "transform", "visibility", "word-spacing", "writing-mode"]), presentationNonInheritableGroupAttrs = new Set(["clip-path", "display", "filter", "mask", "opacity", "text-decoration", "transform", "unicode-bidi"]), colorsNames = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#0ff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000", blanchedalmond: "#ffebcd", blue: "#00f", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#0ff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#f0f", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#0f0", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#f0f", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#639", red: "#f00", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#fff", whitesmoke: "#f5f5f5", yellow: "#ff0", yellowgreen: "#9acd32" }, colorsShortNames = { "#f0ffff": "azure", "#f5f5dc": "beige", "#ffe4c4": "bisque", "#a52a2a": "brown", "#ff7f50": "coral", "#ffd700": "gold", "#808080": "gray", "#008000": "green", "#4b0082": "indigo", "#fffff0": "ivory", "#f0e68c": "khaki", "#faf0e6": "linen", "#800000": "maroon", "#000080": "navy", "#808000": "olive", "#ffa500": "orange", "#da70d6": "orchid", "#cd853f": "peru", "#ffc0cb": "pink", "#dda0dd": "plum", "#800080": "purple", "#f00": "red", "#ff0000": "red", "#fa8072": "salmon", "#a0522d": "sienna", "#c0c0c0": "silver", "#fffafa": "snow", "#d2b48c": "tan", "#008080": "teal", "#ff6347": "tomato", "#ee82ee": "violet", "#f5deb3": "wheat" }, colorsProps = new Set(["color", "fill", "flood-color", "lighting-color", "stop-color", "stroke"]), pseudoClasses = { displayState: new Set(["fullscreen", "modal", "picture-in-picture"]), input: new Set(["autofill", "blank", "checked", "default", "disabled", "enabled", "in-range", "indeterminate", "invalid", "optional", "out-of-range", "placeholder-shown", "read-only", "read-write", "required", "user-invalid", "valid"]), linguistic: new Set(["dir", "lang"]), location: new Set(["any-link", "link", "local-link", "scope", "target-within", "target", "visited"]), resourceState: new Set(["playing", "paused"]), timeDimensional: new Set(["current", "past", "future"]), treeStructural: new Set(["empty", "first-child", "first-of-type", "last-child", "last-of-type", "nth-child", "nth-last-child", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "root"]), userAction: new Set(["active", "focus-visible", "focus-within", "focus", "hover"]), functional: new Set(["is", "not", "where", "has"]) }; var _collections = Object.freeze({ __proto__: null, attrsGroups: attrsGroups, attrsGroupsDefaults: attrsGroupsDefaults, attrsGroupsDeprecated: attrsGroupsDeprecated, colorsNames: colorsNames, colorsProps: colorsProps, colorsShortNames: colorsShortNames, editorNamespaces: editorNamespaces, elems: elems, elemsGroups: elemsGroups, inheritableAttrs: inheritableAttrs, pathElems: pathElems, presentationNonInheritableGroupAttrs: presentationNonInheritableGroupAttrs, pseudoClasses: pseudoClasses, referencesProps: referencesProps, textElems: textElems }); const EOF$3 = 0, Ident$1 = 1, Function$3 = 2, AtKeyword$1 = 3, Hash$3 = 4, String$4 = 5, BadString$1 = 6, Url$4 = 7, BadUrl$1 = 8, Delim$1 = 9, Number$5 = 10, Percentage$3 = 11, Dimension$3 = 12, WhiteSpace$3 = 13, CDO$3 = 14, CDC$3 = 15, Colon$1 = 16, Semicolon$1 = 17, Comma$1 = 18, LeftSquareBracket$1 = 19, RightSquareBracket$1 = 20, LeftParenthesis$1 = 21, RightParenthesis$1 = 22, LeftCurlyBracket$1 = 23, RightCurlyBracket$1 = 24, Comment$3 = 25, EOF$2 = 0; function isDigit$2(e) { return e >= 48 && e <= 57 } function isHexDigit$1(e) { return isDigit$2(e) || e >= 65 && e <= 70 || e >= 97 && e <= 102 } function isUppercaseLetter$1(e) { return e >= 65 && e <= 90 } function isLowercaseLetter$1(e) { return e >= 97 && e <= 122 } function isLetter$1(e) { return isUppercaseLetter$1(e) || isLowercaseLetter$1(e) } function isNonAscii$1(e) { return e >= 128 } function isNameStart$1(e) { return isLetter$1(e) || isNonAscii$1(e) || 95 === e } function isName$1(e) { return isNameStart$1(e) || isDigit$2(e) || 45 === e } function isNonPrintable$1(e) { return e >= 0 && e <= 8 || 11 === e || e >= 14 && e <= 31 || 127 === e } function isNewline$1(e) { return 10 === e || 13 === e || 12 === e } function isWhiteSpace$2(e) { return isNewline$1(e) || 32 === e || 9 === e } function isValidEscape$1(e, t) { return 92 === e && (!isNewline$1(t) && t !== EOF$2) } function isIdentifierStart$1(e, t, n) { return 45 === e ? isNameStart$1(t) || 45 === t || isValidEscape$1(t, n) : !!isNameStart$1(e) || 92 === e && isValidEscape$1(e, t) } function isNumberStart$1(e, t, n) { return 43 === e || 45 === e ? isDigit$2(t) ? 2 : 46 === t && isDigit$2(n) ? 3 : 0 : 46 === e ? isDigit$2(t) ? 2 : 0 : isDigit$2(e) ? 1 : 0 } function isBOM$1(e) { return 65279 === e || 65534 === e ? 1 : 0 } const CATEGORY$1 = new Array(128), EofCategory$1 = 128, WhiteSpaceCategory$1 = 130, DigitCategory$1 = 131, NameStartCategory$1 = 132, NonPrintableCategory$1 = 133; for (let e = 0; e < CATEGORY$1.length; e++)CATEGORY$1[e] = isWhiteSpace$2(e) && WhiteSpaceCategory$1 || isDigit$2(e) && DigitCategory$1 || isNameStart$1(e) && NameStartCategory$1 || isNonPrintable$1(e) && NonPrintableCategory$1 || e || 128; function charCodeCategory$1(e) { return e < 128 ? CATEGORY$1[e] : NameStartCategory$1 } function getCharCode$1(e, t) { return t < e.length ? e.charCodeAt(t) : 0 } function getNewlineLength$1(e, t, n) { return 13 === n && 10 === getCharCode$1(e, t + 1) ? 2 : 1 } function cmpChar$1(e, t, n) { let r = e.charCodeAt(t); return isUppercaseLetter$1(r) && (r |= 32), r === n } function cmpStr$1(e, t, n, r) { if (n - t !== r.length) return !1; if (t < 0 || n > e.length) return !1; for (let a = t; a < n; a++) { const n = r.charCodeAt(a - t); let o = e.charCodeAt(a); if (isUppercaseLetter$1(o) && (o |= 32), o !== n) return !1 } return !0 } function findWhiteSpaceStart$1(e, t) { for (; t >= 0 && isWhiteSpace$2(e.charCodeAt(t)); t--); return t + 1 } function findWhiteSpaceEnd$1(e, t) { for (; t < e.length && isWhiteSpace$2(e.charCodeAt(t)); t++); return t } function findDecimalNumberEnd$1(e, t) { for (; t < e.length && isDigit$2(e.charCodeAt(t)); t++); return t } function consumeEscaped$1(e, t) { if (isHexDigit$1(getCharCode$1(e, (t += 2) - 1))) { for (const n = Math.min(e.length, t + 5); t < n && isHexDigit$1(getCharCode$1(e, t)); t++); const n = getCharCode$1(e, t); isWhiteSpace$2(n) && (t += getNewlineLength$1(e, t, n)) } return t } function consumeName$1(e, t) { for (; t < e.length; t++) { const n = e.charCodeAt(t); if (!isName$1(n)) { if (!isValidEscape$1(n, getCharCode$1(e, t + 1))) break; t = consumeEscaped$1(e, t) - 1 } } return t } function consumeNumber$2(e, t) { let n = e.charCodeAt(t); if (43 !== n && 45 !== n || (n = e.charCodeAt(t += 1)), isDigit$2(n) && (t = findDecimalNumberEnd$1(e, t + 1), n = e.charCodeAt(t)), 46 === n && isDigit$2(e.charCodeAt(t + 1)) && (t = findDecimalNumberEnd$1(e, t += 2)), cmpChar$1(e, t, 101)) { let r = 0; n = e.charCodeAt(t + 1), 45 !== n && 43 !== n || (r = 1, n = e.charCodeAt(t + 2)), isDigit$2(n) && (t = findDecimalNumberEnd$1(e, t + 1 + r + 1)) } return t } function consumeBadUrlRemnants$1(e, t) { for (; t < e.length; t++) { const n = e.charCodeAt(t); if (41 === n) { t++; break } isValidEscape$1(n, getCharCode$1(e, t + 1)) && (t = consumeEscaped$1(e, t)) } return t } function decodeEscaped$1(e) { if (1 === e.length && !isHexDigit$1(e.charCodeAt(0))) return e[0]; let t = parseInt(e, 16); return (0 === t || t >= 55296 && t <= 57343 || t > 1114111) && (t = 65533), String.fromCodePoint(t) } var tokenNames$1 = ["EOF-token", "ident-token", "function-token", "at-keyword-token", "hash-token", "string-token", "bad-string-token", "url-token", "bad-url-token", "delim-token", "number-token", "percentage-token", "dimension-token", "whitespace-token", "CDO-token", "CDC-token", "colon-token", "semicolon-token", "comma-token", "[-token", "]-token", "(-token", ")-token", "{-token", "}-token", "comment-token"]; const MIN_SIZE$1 = 16384; function adoptBuffer$1(e = null, t) { return null === e || e.length < t ? new Uint32Array(Math.max(t + 1024, MIN_SIZE$1)) : e } const N$9 = 10, F$5 = 12, R$5 = 13; function computeLinesAndColumns$1(e) { const t = e.source, n = t.length, r = t.length > 0 ? isBOM$1(t.charCodeAt(0)) : 0, a = adoptBuffer$1(e.lines, n), o = adoptBuffer$1(e.columns, n); let i = e.startLine, s = e.startColumn; for (let e = r; e < n; e++) { const r = t.charCodeAt(e); a[e] = i, o[e] = s++, 10 !== r && 13 !== r && 12 !== r || (13 === r && e + 1 < n && 10 === t.charCodeAt(e + 1) && (e++, a[e] = i, o[e] = s), i++, s = 1) } a[n] = i, o[n] = s, e.lines = a, e.columns = o, e.computed = !0 } let OffsetToLocation$1 = class { constructor() { this.lines = null, this.columns = null, this.computed = !1 } setSource(e, t = 0, n = 1, r = 1) { this.source = e, this.startOffset = t, this.startLine = n, this.startColumn = r, this.computed = !1 } getLocation(e, t) { return this.computed || computeLinesAndColumns$1(this), { source: t, offset: this.startOffset + e, line: this.lines[e], column: this.columns[e] } } getLocationRange(e, t, n) { return this.computed || computeLinesAndColumns$1(this), { source: n, start: { offset: this.startOffset + e, line: this.lines[e], column: this.columns[e] }, end: { offset: this.startOffset + t, line: this.lines[t], column: this.columns[t] } } } }; const OFFSET_MASK$1 = 16777215, TYPE_SHIFT$1 = 24, balancePair$3 = new Map([[Function$3, RightParenthesis$1], [LeftParenthesis$1, RightParenthesis$1], [LeftSquareBracket$1, RightSquareBracket$1], [LeftCurlyBracket$1, RightCurlyBracket$1]]); let TokenStream$1 = class { constructor(e, t) { this.setSource(e, t) } reset() { this.eof = !1, this.tokenIndex = -1, this.tokenType = 0, this.tokenStart = this.firstCharOffset, this.tokenEnd = this.firstCharOffset } setSource(e = "", t = (() => { })) { const n = (e = String(e || "")).length, r = adoptBuffer$1(this.offsetAndType, e.length + 1), a = adoptBuffer$1(this.balance, e.length + 1); let o = 0, i = 0, s = 0, l = -1; for (this.offsetAndType = null, this.balance = null, t(e, ((e, t, c) => { switch (e) { default: a[o] = n; break; case i: { let e = 16777215 & s; for (s = a[e], i = s >> 24, a[o] = e, a[e++] = o; e < o; e++)a[e] === n && (a[e] = o); break } case LeftParenthesis$1: case Function$3: case LeftSquareBracket$1: case LeftCurlyBracket$1: a[o] = s, i = balancePair$3.get(e), s = i << 24 | o }r[o++] = e << 24 | c, -1 === l && (l = t) })), r[o] = 0 | n, a[o] = n, a[n] = n; 0 !== s;) { const e = 16777215 & s; s = a[e], a[e] = n } this.source = e, this.firstCharOffset = -1 === l ? 0 : l, this.tokenCount = o, this.offsetAndType = r, this.balance = a, this.reset(), this.next() } lookupType(e) { return (e += this.tokenIndex) < this.tokenCount ? this.offsetAndType[e] >> 24 : 0 } lookupTypeNonSC(e) { for (let t = this.tokenIndex; t < this.tokenCount; t++) { const n = this.offsetAndType[t] >> 24; if (n !== WhiteSpace$3 && n !== Comment$3 && 0 == e--) return n } return 0 } lookupOffset(e) { return (e += this.tokenIndex) < this.tokenCount ? 16777215 & this.offsetAndType[e - 1] : this.source.length } lookupOffsetNonSC(e) { for (let t = this.tokenIndex; t < this.tokenCount; t++) { const n = this.offsetAndType[t] >> 24; if (n !== WhiteSpace$3 && n !== Comment$3 && 0 == e--) return t - this.tokenIndex } return 0 } lookupValue(e, t) { return (e += this.tokenIndex) < this.tokenCount && cmpStr$1(this.source, 16777215 & this.offsetAndType[e - 1], 16777215 & this.offsetAndType[e], t) } getTokenStart(e) { return e === this.tokenIndex ? this.tokenStart : e > 0 ? e < this.tokenCount ? 16777215 & this.offsetAndType[e - 1] : 16777215 & this.offsetAndType[this.tokenCount] : this.firstCharOffset } substrToCursor(e) { return this.source.substring(e, this.tokenStart) } isBalanceEdge(e) { return this.balance[this.tokenIndex] < e } isDelim(e, t) { return t ? this.lookupType(t) === Delim$1 && this.source.charCodeAt(this.lookupOffset(t)) === e : this.tokenType === Delim$1 && this.source.charCodeAt(this.tokenStart) === e } skip(e) { let t = this.tokenIndex + e; t < this.tokenCount ? (this.tokenIndex = t, this.tokenStart = 16777215 & this.offsetAndType[t - 1], t = this.offsetAndType[t], this.tokenType = t >> 24, this.tokenEnd = 16777215 & t) : (this.tokenIndex = this.tokenCount, this.next()) } next() { let e = this.tokenIndex + 1; e < this.tokenCount ? (this.tokenIndex = e, this.tokenStart = this.tokenEnd, e = this.offsetAndType[e], this.tokenType = e >> 24, this.tokenEnd = 16777215 & e) : (this.eof = !0, this.tokenIndex = this.tokenCount, this.tokenType = 0, this.tokenStart = this.tokenEnd = this.source.length) } skipSC() { for (; this.tokenType === WhiteSpace$3 || this.tokenType === Comment$3;)this.next() } skipUntilBalanced(e, t) { let n, r, a = e; e: for (; a < this.tokenCount && (n = this.balance[a], !(n < e)); a++)switch (r = a > 0 ? 16777215 & this.offsetAndType[a - 1] : this.firstCharOffset, t(this.source.charCodeAt(r))) { case 1: break e; case 2: a++; break e; default: this.balance[n] === a && (a = n) }this.skip(a - this.tokenIndex) } forEachToken(e) { for (let t = 0, n = this.firstCharOffset; t < this.tokenCount; t++) { const r = n, a = this.offsetAndType[t], o = 16777215 & a; n = o, e(a >> 24, r, o, t) } } dump() { const e = new Array(this.tokenCount); return this.forEachToken(((t, n, r, a) => { e[a] = { idx: a, type: tokenNames$1[t], chunk: this.source.substring(n, r), balance: this.balance[a] } })), e } }; function tokenize$4(e, t) { function n(t) { return t < i ? e.charCodeAt(t) : 0 } function r() { return c = consumeNumber$2(e, c), isIdentifierStart$1(n(c), n(c + 1), n(c + 2)) ? (s = Dimension$3, void (c = consumeName$1(e, c))) : 37 === n(c) ? (s = Percentage$3, void c++) : void (s = Number$5) } function a() { const t = c; return c = consumeName$1(e, c), cmpStr$1(e, t, c, "url") && 40 === n(c) ? (c = findWhiteSpaceEnd$1(e, c + 1), 34 === n(c) || 39 === n(c) ? (s = Function$3, void (c = t + 4)) : void function () { for (s = Url$4, c = findWhiteSpaceEnd$1(e, c); c < e.length; c++) { const t = e.charCodeAt(c); switch (charCodeCategory$1(t)) { case 41: return void c++; case WhiteSpaceCategory$1: return c = findWhiteSpaceEnd$1(e, c), 41 === n(c) || c >= e.length ? void (c < e.length && c++) : (c = consumeBadUrlRemnants$1(e, c), void (s = BadUrl$1)); case 34: case 39: case 40: case NonPrintableCategory$1: return c = consumeBadUrlRemnants$1(e, c), void (s = BadUrl$1); case 92: if (isValidEscape$1(t, n(c + 1))) { c = consumeEscaped$1(e, c) - 1; break } return c = consumeBadUrlRemnants$1(e, c), void (s = BadUrl$1) } } }()) : 40 === n(c) ? (s = Function$3, void c++) : void (s = Ident$1) } function o(t) { for (t || (t = n(c++)), s = String$4; c < e.length; c++) { const r = e.charCodeAt(c); switch (charCodeCategory$1(r)) { case t: return void c++; case WhiteSpaceCategory$1: if (isNewline$1(r)) return c += getNewlineLength$1(e, c, r), void (s = BadString$1); break; case 92: if (c === e.length - 1) break; const a = n(c + 1); isNewline$1(a) ? c += getNewlineLength$1(e, c + 1, a) : isValidEscape$1(r, a) && (c = consumeEscaped$1(e, c) - 1) } } } const i = (e = String(e || "")).length; let s, l = isBOM$1(n(0)), c = l; for (; c < i;) { const i = e.charCodeAt(c); switch (charCodeCategory$1(i)) { case WhiteSpaceCategory$1: s = WhiteSpace$3, c = findWhiteSpaceEnd$1(e, c + 1); break; case 34: o(); break; case 35: isName$1(n(c + 1)) || isValidEscape$1(n(c + 1), n(c + 2)) ? (s = Hash$3, c = consumeName$1(e, c + 1)) : (s = Delim$1, c++); break; case 39: o(); break; case 40: s = LeftParenthesis$1, c++; break; case 41: s = RightParenthesis$1, c++; break; case 43: isNumberStart$1(i, n(c + 1), n(c + 2)) ? r() : (s = Delim$1, c++); break; case 44: s = Comma$1, c++; break; case 45: isNumberStart$1(i, n(c + 1), n(c + 2)) ? r() : 45 === n(c + 1) && 62 === n(c + 2) ? (s = CDC$3, c += 3) : isIdentifierStart$1(i, n(c + 1), n(c + 2)) ? a() : (s = Delim$1, c++); break; case 46: isNumberStart$1(i, n(c + 1), n(c + 2)) ? r() : (s = Delim$1, c++); break; case 47: 42 === n(c + 1) ? (s = Comment$3, c = e.indexOf("*/", c + 2), c = -1 === c ? e.length : c + 2) : (s = Delim$1, c++); break; case 58: s = Colon$1, c++; break; case 59: s = Semicolon$1, c++; break; case 60: 33 === n(c + 1) && 45 === n(c + 2) && 45 === n(c + 3) ? (s = CDO$3, c += 4) : (s = Delim$1, c++); break; case 64: isIdentifierStart$1(n(c + 1), n(c + 2), n(c + 3)) ? (s = AtKeyword$1, c = consumeName$1(e, c + 1)) : (s = Delim$1, c++); break; case 91: s = LeftSquareBracket$1, c++; break; case 92: isValidEscape$1(i, n(c + 1)) ? a() : (s = Delim$1, c++); break; case 93: s = RightSquareBracket$1, c++; break; case 123: s = LeftCurlyBracket$1, c++; break; case 125: s = RightCurlyBracket$1, c++; break; case DigitCategory$1: r(); break; case NameStartCategory$1: a(); break; default: s = Delim$1, c++ }t(s, l, l = c) } } let releasedCursors$1 = null, List$1 = class e { static createItem(e) { return { prev: null, next: null, data: e } } constructor() { this.head = null, this.tail = null, this.cursor = null } createItem(t) { return e.createItem(t) } allocateCursor(e, t) { let n; return null !== releasedCursors$1 ? (n = releasedCursors$1, releasedCursors$1 = releasedCursors$1.cursor, n.prev = e, n.next = t, n.cursor = this.cursor) : n = { prev: e, next: t, cursor: this.cursor }, this.cursor = n, n } releaseCursor() { const { cursor: e } = this; this.cursor = e.cursor, e.prev = null, e.next = null, e.cursor = releasedCursors$1, releasedCursors$1 = e } updateCursors(e, t, n, r) { let { cursor: a } = this; for (; null !== a;)a.prev === e && (a.prev = t), a.next === n && (a.next = r), a = a.cursor } *[Symbol.iterator]() { for (let e = this.head; null !== e; e = e.next)yield e.data } get size() { let e = 0; for (let t = this.head; null !== t; t = t.next)e++; return e } get isEmpty() { return null === this.head } get first() { return this.head && this.head.data } get last() { return this.tail && this.tail.data } fromArray(t) { let n = null; this.head = null; for (let r of t) { const t = e.createItem(r); null !== n ? n.next = t : this.head = t, t.prev = n, n = t } return this.tail = n, this } toArray() { return [...this] } toJSON() { return [...this] } forEach(e, t = this) { const n = this.allocateCursor(null, this.head); for (; null !== n.next;) { const r = n.next; n.next = r.next, e.call(t, r.data, r, this) } this.releaseCursor() } forEachRight(e, t = this) { const n = this.allocateCursor(this.tail, null); for (; null !== n.prev;) { const r = n.prev; n.prev = r.prev, e.call(t, r.data, r, this) } this.releaseCursor() } reduce(e, t, n = this) { let r, a = this.allocateCursor(null, this.head), o = t; for (; null !== a.next;)r = a.next, a.next = r.next, o = e.call(n, o, r.data, r, this); return this.releaseCursor(), o } reduceRight(e, t, n = this) { let r, a = this.allocateCursor(this.tail, null), o = t; for (; null !== a.prev;)r = a.prev, a.prev = r.prev, o = e.call(n, o, r.data, r, this); return this.releaseCursor(), o } some(e, t = this) { for (let n = this.head; null !== n; n = n.next)if (e.call(t, n.data, n, this)) return !0; return !1 } map(t, n = this) { const r = new e; for (let e = this.head; null !== e; e = e.next)r.appendData(t.call(n, e.data, e, this)); return r } filter(t, n = this) { const r = new e; for (let e = this.head; null !== e; e = e.next)t.call(n, e.data, e, this) && r.appendData(e.data); return r } nextUntil(e, t, n = this) { if (null === e) return; const r = this.allocateCursor(null, e); for (; null !== r.next;) { const e = r.next; if (r.next = e.next, t.call(n, e.data, e, this)) break } this.releaseCursor() } prevUntil(e, t, n = this) { if (null === e) return; const r = this.allocateCursor(e, null); for (; null !== r.prev;) { const e = r.prev; if (r.prev = e.prev, t.call(n, e.data, e, this)) break } this.releaseCursor() } clear() { this.head = null, this.tail = null } copy() { const t = new e; for (let e of this) t.appendData(e); return t } prepend(e) { return this.updateCursors(null, e, this.head, e), null !== this.head ? (this.head.prev = e, e.next = this.head) : this.tail = e, this.head = e, this } prependData(t) { return this.prepend(e.createItem(t)) } append(e) { return this.insert(e) } appendData(t) { return this.insert(e.createItem(t)) } insert(e, t = null) { if (null !== t) if (this.updateCursors(t.prev, e, t, e), null === t.prev) { if (this.head !== t) throw new Error("before doesn't belong to list"); this.head = e, t.prev = e, e.next = t, this.updateCursors(null, e) } else t.prev.next = e, e.prev = t.prev, t.prev = e, e.next = t; else this.updateCursors(this.tail, e, null, e), null !== this.tail ? (this.tail.next = e, e.prev = this.tail) : this.head = e, this.tail = e; return this } insertData(t, n) { return this.insert(e.createItem(t), n) } remove(e) { if (this.updateCursors(e, e.prev, e, e.next), null !== e.prev) e.prev.next = e.next; else { if (this.head !== e) throw new Error("item doesn't belong to list"); this.head = e.next } if (null !== e.next) e.next.prev = e.prev; else { if (this.tail !== e) throw new Error("item doesn't belong to list"); this.tail = e.prev } return e.prev = null, e.next = null, e } push(t) { this.insert(e.createItem(t)) } pop() { return null !== this.tail ? this.remove(this.tail) : null } unshift(t) { this.prepend(e.createItem(t)) } shift() { return null !== this.head ? this.remove(this.head) : null } prependList(e) { return this.insertList(e, this.head) } appendList(e) { return this.insertList(e) } insertList(e, t) { return null === e.head || (null != t ? (this.updateCursors(t.prev, e.tail, t, e.head), null !== t.prev ? (t.prev.next = e.head, e.head.prev = t.prev) : this.head = e.head, t.prev = e.tail, e.tail.next = t) : (this.updateCursors(this.tail, e.tail, null, e.head), null !== this.tail ? (this.tail.next = e.head, e.head.prev = this.tail) : this.head = e.head, this.tail = e.tail), e.head = null, e.tail = null), this } replace(e, t) { "head" in t ? this.insertList(t, e) : this.insert(t, e), this.remove(e) } }; function createCustomError$1(e, t) { const n = Object.create(SyntaxError.prototype), r = new Error; return Object.assign(n, { name: e, message: t, get stack() { return (r.stack || "").replace(/^(.+\n){1,3}/, `${e}: ${t}\n`) } }) } const MAX_LINE_LENGTH$1 = 100, OFFSET_CORRECTION$1 = 60, TAB_REPLACEMENT$1 = "    "; function sourceFragment$1({ source: e, line: t, column: n, baseLine: r, baseColumn: a }, o) { function i(e, t) { return s.slice(e, t).map(((t, n) => String(e + n + 1).padStart(u) + " |" + t)).join("\n") } const s = ("\n".repeat(Math.max(r - 1, 0)) + " ".repeat(Math.max(a - 1, 0)) + e).split(/\r\n?|\n|\f/), l = Math.max(1, t - o) - 1, c = Math.min(t + o, s.length + 1), u = Math.max(4, String(c).length) + 1; let d = 0; (n += (TAB_REPLACEMENT$1.length - 1) * (s[t - 1].substr(0, n - 1).match(/\t/g) || []).length) > MAX_LINE_LENGTH$1 && (d = n - OFFSET_CORRECTION$1 + 3, n = OFFSET_CORRECTION$1 - 2); for (let e = l; e <= c; e++)e >= 0 && e < s.length && (s[e] = s[e].replace(/\t/g, TAB_REPLACEMENT$1), s[e] = (d > 0 && s[e].length > d ? "" : "") + s[e].substr(d, MAX_LINE_LENGTH$1 - 2) + (s[e].length > d + MAX_LINE_LENGTH$1 - 1 ? "" : "")); return [i(l, t), new Array(n + u + 2).join("-") + "^", i(t, c)].filter(Boolean).join("\n").replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "") } function SyntaxError$4(e, t, n, r, a, o = 1, i = 1) { return Object.assign(createCustomError$1("SyntaxError", e), { source: t, offset: n, line: r, column: a, sourceFragment: e => sourceFragment$1({ source: t, line: r, column: a, baseLine: o, baseColumn: i }, isNaN(e) ? 0 : e), get formattedMessage() { return `Parse error: ${e}\n` + sourceFragment$1({ source: t, line: r, column: a, baseLine: o, baseColumn: i }, 2) } }) } function readSequence$2(e) { const t = this.createList(); let n = !1; const r = { recognizer: e }; for (; !this.eof;) { switch (this.tokenType) { case Comment$3: this.next(); continue; case WhiteSpace$3: n = !0, this.next(); continue }let a = e.getNode.call(this, r); if (void 0 === a) break; n && (e.onWhiteSpace && e.onWhiteSpace.call(this, a, t, r), n = !1), t.push(a) } return n && e.onWhiteSpace && e.onWhiteSpace.call(this, null, t, r), t } const NOOP$1 = () => { }, EXCLAMATIONMARK$7 = 33, NUMBERSIGN$9 = 35, SEMICOLON$1 = 59, LEFTCURLYBRACKET$3 = 123, NULL$1 = 0; function createParseContext$1(e) { return function () { return this[e]() } } function fetchParseValues$1(e) { const t = Object.create(null); for (const n of Object.keys(e)) { const r = e[n], a = r.parse || r; a && (t[n] = a) } return t } function processConfig$1(e) { const t = { context: Object.create(null), features: Object.assign(Object.create(null), e.features), scope: Object.assign(Object.create(null), e.scope), atrule: fetchParseValues$1(e.atrule), pseudo: fetchParseValues$1(e.pseudo), node: fetchParseValues$1(e.node) }; for (const [n, r] of Object.entries(e.parseContext)) switch (typeof r) { case "function": t.context[n] = r; break; case "string": t.context[n] = createParseContext$1(r) }return { config: t, ...t, ...t.node } } function createParser$1(e) { let t = "", n = "<unknown>", r = !1, a = NOOP$1, o = !1; const i = new OffsetToLocation$1, s = Object.assign(new TokenStream$1, processConfig$1(e || {}), { parseAtrulePrelude: !0, parseRulePrelude: !0, parseValue: !0, parseCustomProperty: !1, readSequence: readSequence$2, consumeUntilBalanceEnd: () => 0, consumeUntilLeftCurlyBracket: e => e === LEFTCURLYBRACKET$3 ? 1 : 0, consumeUntilLeftCurlyBracketOrSemicolon: e => e === LEFTCURLYBRACKET$3 || e === SEMICOLON$1 ? 1 : 0, consumeUntilExclamationMarkOrSemicolon: e => e === EXCLAMATIONMARK$7 || e === SEMICOLON$1 ? 1 : 0, consumeUntilSemicolonIncluded: e => e === SEMICOLON$1 ? 2 : 0, createList: () => new List$1, createSingleNodeList: e => (new List$1).appendData(e), getFirstListNode: e => e && e.first, getLastListNode: e => e && e.last, parseWithFallback(e, t) { const n = this.tokenIndex; try { return e.call(this) } catch (e) { if (o) throw e; this.skip(n - this.tokenIndex); const r = t.call(this); return o = !0, a(e, r), o = !1, r } }, lookupNonWSType(e) { let t; do { if (t = this.lookupType(e++), t !== WhiteSpace$3 && t !== Comment$3) return t } while (t !== NULL$1); return NULL$1 }, charCodeAt: e => e >= 0 && e < t.length ? t.charCodeAt(e) : 0, substring: (e, n) => t.substring(e, n), substrToCursor(e) { return this.source.substring(e, this.tokenStart) }, cmpChar: (e, n) => cmpChar$1(t, e, n), cmpStr: (e, n, r) => cmpStr$1(t, e, n, r), consume(e) { const t = this.tokenStart; return this.eat(e), this.substrToCursor(t) }, consumeFunctionName() { const e = t.substring(this.tokenStart, this.tokenEnd - 1); return this.eat(Function$3), e }, consumeNumber(e) { const n = t.substring(this.tokenStart, consumeNumber$2(t, this.tokenStart)); return this.eat(e), n }, eat(e) { if (this.tokenType !== e) { const t = tokenNames$1[e].slice(0, -6).replace(/-/g, " ").replace(/^./, (e => e.toUpperCase())); let n = `${/[[\](){}]/.test(t) ? `"${t}"` : t} is expected`, r = this.tokenStart; switch (e) { case Ident$1: this.tokenType === Function$3 || this.tokenType === Url$4 ? (r = this.tokenEnd - 1, n = "Identifier is expected but function found") : n = "Identifier is expected"; break; case Hash$3: this.isDelim(NUMBERSIGN$9) && (this.next(), r++, n = "Name is expected"); break; case Percentage$3: this.tokenType === Number$5 && (r = this.tokenEnd, n = "Percent sign is expected") }this.error(n, r) } this.next() }, eatIdent(e) { this.tokenType === Ident$1 && !1 !== this.lookupValue(0, e) || this.error(`Identifier "${e}" is expected`), this.next() }, eatDelim(e) { this.isDelim(e) || this.error(`Delim "${String.fromCharCode(e)}" is expected`), this.next() }, getLocation: (e, t) => r ? i.getLocationRange(e, t, n) : null, getLocationFromList(e) { if (r) { const t = this.getFirstListNode(e), r = this.getLastListNode(e); return i.getLocationRange(null !== t ? t.loc.start.offset - i.startOffset : this.tokenStart, null !== r ? r.loc.end.offset - i.startOffset : this.tokenStart, n) } return null }, error(e, n) { const r = void 0 !== n && n < t.length ? i.getLocation(n) : this.eof ? i.getLocation(findWhiteSpaceStart$1(t, t.length - 1)) : i.getLocation(this.tokenStart); throw new SyntaxError$4(e || "Unexpected input", t, r.offset, r.line, r.column, i.startLine, i.startColumn) } }); return Object.assign((function (e, l) { t = e, l = l || {}, s.setSource(t, tokenize$4), i.setSource(t, l.offset, l.line, l.column), n = l.filename || "<unknown>", r = Boolean(l.positions), a = "function" == typeof l.onParseError ? l.onParseError : NOOP$1, o = !1, s.parseAtrulePrelude = !("parseAtrulePrelude" in l) || Boolean(l.parseAtrulePrelude), s.parseRulePrelude = !("parseRulePrelude" in l) || Boolean(l.parseRulePrelude), s.parseValue = !("parseValue" in l) || Boolean(l.parseValue), s.parseCustomProperty = "parseCustomProperty" in l && Boolean(l.parseCustomProperty); const { context: c = "default", onComment: u } = l; if (c in s.context == !1) throw new Error("Unknown context `" + c + "`"); "function" == typeof u && s.forEachToken(((e, n, r) => { if (e === Comment$3) { const e = s.getLocation(n, r), a = cmpStr$1(t, r - 2, r, "*/") ? t.slice(n + 2, r - 2) : t.slice(n + 2, r); u(a, e) } })); const d = s.context[c].call(s, l); return s.eof || s.error(), d }), { SyntaxError: SyntaxError$4, config: s.config }) } var base64Vlq = {}, base64$1 = {}, intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""); base64$1.encode = function (e) { if (0 <= e && e < intToCharMap.length) return intToCharMap[e]; throw new TypeError("Must be between 0 and 63: " + e) }, base64$1.decode = function (e) { return 65 <= e && e <= 90 ? e - 65 : 97 <= e && e <= 122 ? e - 97 + 26 : 48 <= e && e <= 57 ? e - 48 + 52 : 43 == e ? 62 : 47 == e ? 63 : -1 }; var base64 = base64$1, VLQ_BASE_SHIFT = 5, VLQ_BASE = 1 << VLQ_BASE_SHIFT, VLQ_BASE_MASK = VLQ_BASE - 1, VLQ_CONTINUATION_BIT = VLQ_BASE; function toVLQSigned(e) { return e < 0 ? 1 + (-e << 1) : 0 + (e << 1) } function fromVLQSigned(e) { var t = e >> 1; return 1 == (1 & e) ? -t : t } base64Vlq.encode = function (e) { var t, n = "", r = toVLQSigned(e); do { t = r & VLQ_BASE_MASK, (r >>>= VLQ_BASE_SHIFT) > 0 && (t |= VLQ_CONTINUATION_BIT), n += base64.encode(t) } while (r > 0); return n }, base64Vlq.decode = function (e, t, n) { var r, a, o = e.length, i = 0, s = 0; do { if (t >= o) throw new Error("Expected more digits in base 64 VLQ value."); if (-1 === (a = base64.decode(e.charCodeAt(t++)))) throw new Error("Invalid base64 digit: " + e.charAt(t - 1)); r = !!(a & VLQ_CONTINUATION_BIT), i += (a &= VLQ_BASE_MASK) << s, s += VLQ_BASE_SHIFT } while (r); n.value = fromVLQSigned(i), n.rest = t }; var util$3 = {}; !function (e) { e.getArg = function (e, t, n) { if (t in e) return e[t]; if (3 === arguments.length) return n; throw new Error('"' + t + '" is a required argument.') }; var t = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, n = /^data:.+\,.+$/; function r(e) { var n = e.match(t); return n ? { scheme: n[1], auth: n[2], host: n[3], port: n[4], path: n[5] } : null } function a(e) { var t = ""; return e.scheme && (t += e.scheme + ":"), t += "//", e.auth && (t += e.auth + "@"), e.host && (t += e.host), e.port && (t += ":" + e.port), e.path && (t += e.path), t } e.urlParse = r, e.urlGenerate = a; var o, i, s = (o = function (t) { var n = t, o = r(t); if (o) { if (!o.path) return t; n = o.path } for (var i = e.isAbsolute(n), s = [], l = 0, c = 0; ;) { if (l = c, -1 === (c = n.indexOf("/", l))) { s.push(n.slice(l)); break } for (s.push(n.slice(l, c)); c < n.length && "/" === n[c];)c++ } var u, d = 0; for (c = s.length - 1; c >= 0; c--)"." === (u = s[c]) ? s.splice(c, 1) : ".." === u ? d++ : d > 0 && ("" === u ? (s.splice(c + 1, d), d = 0) : (s.splice(c, 2), d--)); return "" === (n = s.join("/")) && (n = i ? "/" : "."), o ? (o.path = n, a(o)) : n }, i = [], function (e) { for (var t = 0; t < i.length; t++)if (i[t].input === e) { var n = i[0]; return i[0] = i[t], i[t] = n, i[0].result } var r = o(e); return i.unshift({ input: e, result: r }), i.length > 32 && i.pop(), r }); function l(e, t) { "" === e && (e = "."), "" === t && (t = "."); var o = r(t), i = r(e); if (i && (e = i.path || "/"), o && !o.scheme) return i && (o.scheme = i.scheme), a(o); if (o || t.match(n)) return t; if (i && !i.host && !i.path) return i.host = t, a(i); var l = "/" === t.charAt(0) ? t : s(e.replace(/\/+$/, "") + "/" + t); return i ? (i.path = l, a(i)) : l } e.normalize = s, e.join = l, e.isAbsolute = function (e) { return "/" === e.charAt(0) || t.test(e) }, e.relative = function (e, t) { "" === e && (e = "."), e = e.replace(/\/$/, ""); for (var n = 0; 0 !== t.indexOf(e + "/");) { var r = e.lastIndexOf("/"); if (r < 0) return t; if ((e = e.slice(0, r)).match(/^([^\/]+:\/)?\/*$/)) return t; ++n } return Array(n + 1).join("../") + t.substr(e.length + 1) }; var c = !("__proto__" in Object.create(null)); function u(e) { return e } function d(e) { if (!e) return !1; var t = e.length; if (t < 9) return !1; if (95 !== e.charCodeAt(t - 1) || 95 !== e.charCodeAt(t - 2) || 111 !== e.charCodeAt(t - 3) || 116 !== e.charCodeAt(t - 4) || 111 !== e.charCodeAt(t - 5) || 114 !== e.charCodeAt(t - 6) || 112 !== e.charCodeAt(t - 7) || 95 !== e.charCodeAt(t - 8) || 95 !== e.charCodeAt(t - 9)) return !1; for (var n = t - 10; n >= 0; n--)if (36 !== e.charCodeAt(n)) return !1; return !0 } function p(e, t) { return e === t ? 0 : null === e ? 1 : null === t ? -1 : e > t ? 1 : -1 } e.toSetString = c ? u : function (e) { return d(e) ? "$" + e : e }, e.fromSetString = c ? u : function (e) { return d(e) ? e.slice(1) : e }, e.compareByOriginalPositions = function (e, t, n) { var r = p(e.source, t.source); return 0 !== r || 0 !== (r = e.originalLine - t.originalLine) || 0 !== (r = e.originalColumn - t.originalColumn) || n || 0 !== (r = e.generatedColumn - t.generatedColumn) || 0 !== (r = e.generatedLine - t.generatedLine) ? r : p(e.name, t.name) }, e.compareByOriginalPositionsNoSource = function (e, t, n) { var r; return 0 !== (r = e.originalLine - t.originalLine) || 0 !== (r = e.originalColumn - t.originalColumn) || n || 0 !== (r = e.generatedColumn - t.generatedColumn) || 0 !== (r = e.generatedLine - t.generatedLine) ? r : p(e.name, t.name) }, e.compareByGeneratedPositionsDeflated = function (e, t, n) { var r = e.generatedLine - t.generatedLine; return 0 !== r || 0 !== (r = e.generatedColumn - t.generatedColumn) || n || 0 !== (r = p(e.source, t.source)) || 0 !== (r = e.originalLine - t.originalLine) || 0 !== (r = e.originalColumn - t.originalColumn) ? r : p(e.name, t.name) }, e.compareByGeneratedPositionsDeflatedNoLine = function (e, t, n) { var r = e.generatedColumn - t.generatedColumn; return 0 !== r || n || 0 !== (r = p(e.source, t.source)) || 0 !== (r = e.originalLine - t.originalLine) || 0 !== (r = e.originalColumn - t.originalColumn) ? r : p(e.name, t.name) }, e.compareByGeneratedPositionsInflated = function (e, t) { var n = e.generatedLine - t.generatedLine; return 0 !== n || 0 !== (n = e.generatedColumn - t.generatedColumn) || 0 !== (n = p(e.source, t.source)) || 0 !== (n = e.originalLine - t.originalLine) || 0 !== (n = e.originalColumn - t.originalColumn) ? n : p(e.name, t.name) }, e.parseSourceMapInput = function (e) { return JSON.parse(e.replace(/^\)]}'[^\n]*\n/, "")) }, e.computeSourceURL = function (e, t, n) { if (t = t || "", e && ("/" !== e[e.length - 1] && "/" !== t[0] && (e += "/"), t = e + t), n) { var o = r(n); if (!o) throw new Error("sourceMapURL could not be parsed"); if (o.path) { var i = o.path.lastIndexOf("/"); i >= 0 && (o.path = o.path.substring(0, i + 1)) } t = l(a(o), t) } return s(t) } }(util$3); var arraySet = {}, util$2 = util$3, has = Object.prototype.hasOwnProperty, hasNativeMap = "undefined" != typeof Map; function ArraySet$1() { this._array = [], this._set = hasNativeMap ? new Map : Object.create(null) } ArraySet$1.fromArray = function (e, t) { for (var n = new ArraySet$1, r = 0, a = e.length; r < a; r++)n.add(e[r], t); return n }, ArraySet$1.prototype.size = function () { return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length }, ArraySet$1.prototype.add = function (e, t) { var n = hasNativeMap ? e : util$2.toSetString(e), r = hasNativeMap ? this.has(e) : has.call(this._set, n), a = this._array.length; r && !t || this._array.push(e), r || (hasNativeMap ? this._set.set(e, a) : this._set[n] = a) }, ArraySet$1.prototype.has = function (e) { if (hasNativeMap) return this._set.has(e); var t = util$2.toSetString(e); return has.call(this._set, t) }, ArraySet$1.prototype.indexOf = function (e) { if (hasNativeMap) { var t = this._set.get(e); if (t >= 0) return t } else { var n = util$2.toSetString(e); if (has.call(this._set, n)) return this._set[n] } throw new Error('"' + e + '" is not in the set.') }, ArraySet$1.prototype.at = function (e) { if (e >= 0 && e < this._array.length) return this._array[e]; throw new Error("No element indexed by " + e) }, ArraySet$1.prototype.toArray = function () { return this._array.slice() }, arraySet.ArraySet = ArraySet$1; var mappingList = {}, util$1 = util$3; function generatedPositionAfter(e, t) { var n = e.generatedLine, r = t.generatedLine, a = e.generatedColumn, o = t.generatedColumn; return r > n || r == n && o >= a || util$1.compareByGeneratedPositionsInflated(e, t) <= 0 } function MappingList$1() { this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 } } MappingList$1.prototype.unsortedForEach = function (e, t) { this._array.forEach(e, t) }, MappingList$1.prototype.add = function (e) { generatedPositionAfter(this._last, e) ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e)) }, MappingList$1.prototype.toArray = function () { return this._sorted || (this._array.sort(util$1.compareByGeneratedPositionsInflated), this._sorted = !0), this._array }, mappingList.MappingList = MappingList$1; var base64VLQ = base64Vlq, util = util$3, ArraySet = arraySet.ArraySet, MappingList = mappingList.MappingList; function SourceMapGenerator(e) { e || (e = {}), this._file = util.getArg(e, "file", null), this._sourceRoot = util.getArg(e, "sourceRoot", null), this._skipValidation = util.getArg(e, "skipValidation", !1), this._ignoreInvalidMapping = util.getArg(e, "ignoreInvalidMapping", !1), this._sources = new ArraySet, this._names = new ArraySet, this._mappings = new MappingList, this._sourcesContents = null } SourceMapGenerator.prototype._version = 3, SourceMapGenerator.fromSourceMap = function (e, t) { var n = e.sourceRoot, r = new SourceMapGenerator(Object.assign(t || {}, { file: e.file, sourceRoot: n })); return e.eachMapping((function (e) { var t = { generated: { line: e.generatedLine, column: e.generatedColumn } }; null != e.source && (t.source = e.source, null != n && (t.source = util.relative(n, t.source)), t.original = { line: e.originalLine, column: e.originalColumn }, null != e.name && (t.name = e.name)), r.addMapping(t) })), e.sources.forEach((function (t) { var a = t; null !== n && (a = util.relative(n, t)), r._sources.has(a) || r._sources.add(a); var o = e.sourceContentFor(t); null != o && r.setSourceContent(t, o) })), r }, SourceMapGenerator.prototype.addMapping = function (e) { var t = util.getArg(e, "generated"), n = util.getArg(e, "original", null), r = util.getArg(e, "source", null), a = util.getArg(e, "name", null); (this._skipValidation || !1 !== this._validateMapping(t, n, r, a)) && (null != r && (r = String(r), this._sources.has(r) || this._sources.add(r)), null != a && (a = String(a), this._names.has(a) || this._names.add(a)), this._mappings.add({ generatedLine: t.line, generatedColumn: t.column, originalLine: null != n && n.line, originalColumn: null != n && n.column, source: r, name: a })) }, SourceMapGenerator.prototype.setSourceContent = function (e, t) { var n = e; null != this._sourceRoot && (n = util.relative(this._sourceRoot, n)), null != t ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[util.toSetString(n)] = t) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(n)], 0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null)) }, SourceMapGenerator.prototype.applySourceMap = function (e, t, n) { var r = t; if (null == t) { if (null == e.file) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.'); r = e.file } var a = this._sourceRoot; null != a && (r = util.relative(a, r)); var o = new ArraySet, i = new ArraySet; this._mappings.unsortedForEach((function (t) { if (t.source === r && null != t.originalLine) { var s = e.originalPositionFor({ line: t.originalLine, column: t.originalColumn }); null != s.source && (t.source = s.source, null != n && (t.source = util.join(n, t.source)), null != a && (t.source = util.relative(a, t.source)), t.originalLine = s.line, t.originalColumn = s.column, null != s.name && (t.name = s.name)) } var l = t.source; null == l || o.has(l) || o.add(l); var c = t.name; null == c || i.has(c) || i.add(c) }), this), this._sources = o, this._names = i, e.sources.forEach((function (t) { var r = e.sourceContentFor(t); null != r && (null != n && (t = util.join(n, t)), null != a && (t = util.relative(a, t)), this.setSourceContent(t, r)) }), this) }, SourceMapGenerator.prototype._validateMapping = function (e, t, n, r) { if (t && "number" != typeof t.line && "number" != typeof t.column) { var a = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."; if (this._ignoreInvalidMapping) return "undefined" != typeof console && console.warn && console.warn(a), !1; throw new Error(a) } if ((!(e && "line" in e && "column" in e && e.line > 0 && e.column >= 0) || t || n || r) && !(e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && n)) { a = "Invalid mapping: " + JSON.stringify({ generated: e, source: n, original: t, name: r }); if (this._ignoreInvalidMapping) return "undefined" != typeof console && console.warn && console.warn(a), !1; throw new Error(a) } }, SourceMapGenerator.prototype._serializeMappings = function () { for (var e, t, n, r, a = 0, o = 1, i = 0, s = 0, l = 0, c = 0, u = "", d = this._mappings.toArray(), p = 0, h = d.length; p < h; p++) { if (e = "", (t = d[p]).generatedLine !== o) for (a = 0; t.generatedLine !== o;)e += ";", o++; else if (p > 0) { if (!util.compareByGeneratedPositionsInflated(t, d[p - 1])) continue; e += "," } e += base64VLQ.encode(t.generatedColumn - a), a = t.generatedColumn, null != t.source && (r = this._sources.indexOf(t.source), e += base64VLQ.encode(r - c), c = r, e += base64VLQ.encode(t.originalLine - 1 - s), s = t.originalLine - 1, e += base64VLQ.encode(t.originalColumn - i), i = t.originalColumn, null != t.name && (n = this._names.indexOf(t.name), e += base64VLQ.encode(n - l), l = n)), u += e } return u }, SourceMapGenerator.prototype._generateSourcesContent = function (e, t) { return e.map((function (e) { if (!this._sourcesContents) return null; null != t && (e = util.relative(t, e)); var n = util.toSetString(e); return Object.prototype.hasOwnProperty.call(this._sourcesContents, n) ? this._sourcesContents[n] : null }), this) }, SourceMapGenerator.prototype.toJSON = function () { var e = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() }; return null != this._file && (e.file = this._file), null != this._sourceRoot && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e }, SourceMapGenerator.prototype.toString = function () { return JSON.stringify(this.toJSON()) }; var SourceMapGenerator_1 = SourceMapGenerator; const trackNodes$1 = new Set(["Atrule", "Selector", "Declaration"]); function generateSourceMap$1(e) { const t = new SourceMapGenerator_1, n = { line: 1, column: 0 }, r = { line: 0, column: 0 }, a = { line: 1, column: 0 }, o = { generated: a }; let i = 1, s = 0, l = !1; const c = e.node; e.node = function (e) { if (e.loc && e.loc.start && trackNodes$1.has(e.type)) { const c = e.loc.start.line, u = e.loc.start.column - 1; r.line === c && r.column === u || (r.line = c, r.column = u, n.line = i, n.column = s, l && (l = !1, n.line === a.line && n.column === a.column || t.addMapping(o)), l = !0, t.addMapping({ source: e.loc.source, original: r, generated: n })) } c.call(this, e), l && trackNodes$1.has(e.type) && (a.line = i, a.column = s) }; const u = e.emit; e.emit = function (e, t, n) { for (let t = 0; t < e.length; t++)10 === e.charCodeAt(t) ? (i++, s = 0) : s++; u(e, t, n) }; const d = e.result; return e.result = function () { return l && t.addMapping(o), { css: d(), map: t } }, e } const PLUSSIGN$j = 43, HYPHENMINUS$d = 45, code$1 = (e, t) => { if (e === Delim$1 && (e = t), "string" == typeof e) { const t = e.charCodeAt(0); return t > 127 ? 32768 : t << 8 } return e }, specPairs$1 = [[Ident$1, Ident$1], [Ident$1, Function$3], [Ident$1, Url$4], [Ident$1, BadUrl$1], [Ident$1, "-"], [Ident$1, Number$5], [Ident$1, Percentage$3], [Ident$1, Dimension$3], [Ident$1, CDC$3], [Ident$1, LeftParenthesis$1], [AtKeyword$1, Ident$1], [AtKeyword$1, Function$3], [AtKeyword$1, Url$4], [AtKeyword$1, BadUrl$1], [AtKeyword$1, "-"], [AtKeyword$1, Number$5], [AtKeyword$1, Percentage$3], [AtKeyword$1, Dimension$3], [AtKeyword$1, CDC$3], [Hash$3, Ident$1], [Hash$3, Function$3], [Hash$3, Url$4], [Hash$3, BadUrl$1], [Hash$3, "-"], [Hash$3, Number$5], [Hash$3, Percentage$3], [Hash$3, Dimension$3], [Hash$3, CDC$3], [Dimension$3, Ident$1], [Dimension$3, Function$3], [Dimension$3, Url$4], [Dimension$3, BadUrl$1], [Dimension$3, "-"], [Dimension$3, Number$5], [Dimension$3, Percentage$3], [Dimension$3, Dimension$3], [Dimension$3, CDC$3], ["#", Ident$1], ["#", Function$3], ["#", Url$4], ["#", BadUrl$1], ["#", "-"], ["#", Number$5], ["#", Percentage$3], ["#", Dimension$3], ["#", CDC$3], ["-", Ident$1], ["-", Function$3], ["-", Url$4], ["-", BadUrl$1], ["-", "-"], ["-", Number$5], ["-", Percentage$3], ["-", Dimension$3], ["-", CDC$3], [Number$5, Ident$1], [Number$5, Function$3], [Number$5, Url$4], [Number$5, BadUrl$1], [Number$5, Number$5], [Number$5, Percentage$3], [Number$5, Dimension$3], [Number$5, "%"], [Number$5, CDC$3], ["@", Ident$1], ["@", Function$3], ["@", Url$4], ["@", BadUrl$1], ["@", "-"], ["@", CDC$3], [".", Number$5], [".", Percentage$3], [".", Dimension$3], ["+", Number$5], ["+", Percentage$3], ["+", Dimension$3], ["/", "*"]], safePairs$1 = specPairs$1.concat([[Ident$1, Hash$3], [Dimension$3, Hash$3], [Hash$3, Hash$3], [AtKeyword$1, LeftParenthesis$1], [AtKeyword$1, String$4], [AtKeyword$1, Colon$1], [Percentage$3, Percentage$3], [Percentage$3, Dimension$3], [Percentage$3, Function$3], [Percentage$3, "-"], [RightParenthesis$1, Ident$1], [RightParenthesis$1, Function$3], [RightParenthesis$1, Percentage$3], [RightParenthesis$1, Dimension$3], [RightParenthesis$1, Hash$3], [RightParenthesis$1, "-"]]); function createMap$1(e) { const t = new Set(e.map((([e, t]) => code$1(e) << 16 | code$1(t)))); return function (e, n, r) { const a = code$1(n, r), o = r.charCodeAt(0); return (45 === o && n !== Ident$1 && n !== Function$3 && n !== CDC$3 || 43 === o ? t.has(e << 16 | o << 8) : t.has(e << 16 | a)) && this.emit(" ", WhiteSpace$3, !0), a } } const spec$1 = createMap$1(specPairs$1), safe$1 = createMap$1(safePairs$1); var tokenBefore$1 = Object.freeze({ __proto__: null, safe: safe$1, spec: spec$1 }); const REVERSESOLIDUS$1 = 92; function processChildren$1(e, t) { if ("function" != typeof t) e.children.forEach(this.node, this); else { let n = null; e.children.forEach((e => { null !== n && t.call(this, n), this.node(e), n = e })) } } function processChunk$1(e) { tokenize$4(e, ((t, n, r) => { this.token(t, e.slice(n, r)) })) } function createGenerator$1(e) { const t = new Map; for (let [n, r] of Object.entries(e.node)) { "function" == typeof (r.generate || r) && t.set(n, r.generate || r) } return function (e, n) { let r = "", a = 0, o = { node(e) { if (!t.has(e.type)) throw new Error("Unknown node type: " + e.type); t.get(e.type).call(i, e) }, tokenBefore: safe$1, token(e, t) { a = this.tokenBefore(a, e, t), this.emit(t, e, !1), e === Delim$1 && t.charCodeAt(0) === REVERSESOLIDUS$1 && this.emit("\n", WhiteSpace$3, !0) }, emit(e) { r += e }, result: () => r }; n && ("function" == typeof n.decorator && (o = n.decorator(o)), n.sourceMap && (o = generateSourceMap$1(o)), n.mode in tokenBefore$1 && (o.tokenBefore = tokenBefore$1[n.mode])); const i = { node: e => o.node(e), children: processChildren$1, token: (e, t) => o.token(e, t), tokenize: processChunk$1 }; return o.node(e), o.result() } } function createConvertor$1(e) { return { fromPlainObject: t => (e(t, { enter(e) { e.children && e.children instanceof List$1 == !1 && (e.children = (new List$1).fromArray(e.children)) } }), t), toPlainObject: t => (e(t, { leave(e) { e.children && e.children instanceof List$1 && (e.children = e.children.toArray()) } }), t) } } const { hasOwnProperty: hasOwnProperty$b } = Object.prototype, noop$5 = function () { }; function ensureFunction$3(e) { return "function" == typeof e ? e : noop$5 } function invokeForType$1(e, t) { return function (n, r, a) { n.type === t && e.call(this, n, r, a) } } function getWalkersFromStructure$1(e, t) { const n = t.structure, r = []; for (const e in n) { if (!1 === hasOwnProperty$b.call(n, e)) continue; let t = n[e]; const a = { name: e, type: !1, nullable: !1 }; Array.isArray(t) || (t = [t]); for (const e of t) null === e ? a.nullable = !0 : "string" == typeof e ? a.type = "node" : Array.isArray(e) && (a.type = "list"); a.type && r.push(a) } return r.length ? { context: t.walkContext, fields: r } : null } function getTypesFromConfig$1(e) { const t = {}; for (const n in e.node) if (hasOwnProperty$b.call(e.node, n)) { const r = e.node[n]; if (!r.structure) throw new Error("Missed `structure` field in `" + n + "` node type definition"); t[n] = getWalkersFromStructure$1(n, r) } return t } function createTypeIterator$1(e, t) { const n = e.fields.slice(), r = e.context, a = "string" == typeof r; return t && n.reverse(), function (e, o, i, s) { let l; a && (l = o[r], o[r] = e); for (const r of n) { const n = e[r.name]; if (!r.nullable || n) if ("list" === r.type) { if (t ? n.reduceRight(s, !1) : n.reduce(s, !1)) return !0 } else if (i(n)) return !0 } a && (o[r] = l) } } function createFastTraveralMap$1({ StyleSheet: e, Atrule: t, Rule: n, Block: r, DeclarationList: a }) { return { Atrule: { StyleSheet: e, Atrule: t, Rule: n, Block: r }, Rule: { StyleSheet: e, Atrule: t, Rule: n, Block: r }, Declaration: { StyleSheet: e, Atrule: t, Rule: n, Block: r, DeclarationList: a } } } function createWalker$1(e) { const t = getTypesFromConfig$1(e), n = {}, r = {}, a = Symbol("break-walk"), o = Symbol("skip-node"); for (const e in t) hasOwnProperty$b.call(t, e) && null !== t[e] && (n[e] = createTypeIterator$1(t[e], !1), r[e] = createTypeIterator$1(t[e], !0)); const i = createFastTraveralMap$1(n), s = createFastTraveralMap$1(r), l = function (e, l) { function c(e, t, n) { const r = u.call(m, e, t, n); return r === a || r !== o && (!(!p.hasOwnProperty(e.type) || !p[e.type](e, m, c, h)) || d.call(m, e, t, n) === a) } let u = noop$5, d = noop$5, p = n, h = (e, t, n, r) => e || c(t, n, r); const m = { break: a, skip: o, root: e, stylesheet: null, atrule: null, atrulePrelude: null, rule: null, selector: null, block: null, declaration: null, function: null }; if ("function" == typeof l) u = l; else if (l && (u = ensureFunction$3(l.enter), d = ensureFunction$3(l.leave), l.reverse && (p = r), l.visit)) { if (i.hasOwnProperty(l.visit)) p = l.reverse ? s[l.visit] : i[l.visit]; else if (!t.hasOwnProperty(l.visit)) throw new Error("Bad value `" + l.visit + "` for `visit` option (should be: " + Object.keys(t).sort().join(", ") + ")"); u = invokeForType$1(u, l.visit), d = invokeForType$1(d, l.visit) } if (u === noop$5 && d === noop$5) throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function"); c(e) }; return l.break = a, l.skip = o, l.find = function (e, t) { let n = null; return l(e, (function (e, r, o) { if (t.call(this, e, r, o)) return n = e, a })), n }, l.findLast = function (e, t) { let n = null; return l(e, { reverse: !0, enter(e, r, o) { if (t.call(this, e, r, o)) return n = e, a } }), n }, l.findAll = function (e, t) { const n = []; return l(e, (function (e, r, a) { t.call(this, e, r, a) && n.push(e) })), n }, l } function noop$4(e) { return e } function generateMultiplier$1(e) { const { min: t, max: n, comma: r } = e; return 0 === t && 0 === n ? r ? "#?" : "*" : 0 === t && 1 === n ? "?" : 1 === t && 0 === n ? r ? "#" : "+" : 1 === t && 1 === n ? "" : (r ? "#" : "") + (t === n ? "{" + t + "}" : "{" + t + "," + (0 !== n ? n : "") + "}") } function generateTypeOpts$1(e) { if ("Range" === e.type) return " [" + (null === e.min ? "-" : e.min) + "," + (null === e.max ? "" : e.max) + "]"; throw new Error("Unknown node type `" + e.type + "`") } function generateSequence$1(e, t, n, r) { const a = " " === e.combinator || r ? e.combinator : " " + e.combinator + " ", o = e.terms.map((e => internalGenerate$1(e, t, n, r))).join(a); return e.explicit || n ? (r || "," === o[0] ? "[" : "[ ") + o + (r ? "]" : " ]") : o } function internalGenerate$1(e, t, n, r) { let a; switch (e.type) { case "Group": a = generateSequence$1(e, t, n, r) + (e.disallowEmpty ? "!" : ""); break; case "Multiplier": return internalGenerate$1(e.term, t, n, r) + t(generateMultiplier$1(e), e); case "Type": a = "<" + e.name + (e.opts ? t(generateTypeOpts$1(e.opts), e.opts) : "") + ">"; break; case "Property": a = "<'" + e.name + "'>"; break; case "Keyword": a = e.name; break; case "AtKeyword": a = "@" + e.name; break; case "Function": a = e.name + "("; break; case "String": case "Token": a = e.value; break; case "Comma": a = ","; break; default: throw new Error("Unknown node type `" + e.type + "`") }return t(a, e) } function generate$1u(e, t) { let n = noop$4, r = !1, a = !1; return "function" == typeof t ? n = t : t && (r = Boolean(t.forceBraces), a = Boolean(t.compact), "function" == typeof t.decorate && (n = t.decorate)), internalGenerate$1(e, n, r, a) } const defaultLoc$1 = { offset: 0, line: 1, column: 1 }; function locateMismatch$1(e, t) { const n = e.tokens, r = e.longestMatch, a = r < n.length && n[r].node || null, o = a !== t ? a : null; let i, s, l = 0, c = 0, u = 0, d = ""; for (let e = 0; e < n.length; e++) { const t = n[e].value; e === r && (c = t.length, l = d.length), null !== o && n[e].node === o && (e <= r ? u++ : u = 0), d += t } return r === n.length || u > 1 ? (i = fromLoc$1(o || t, "end") || buildLoc$1(defaultLoc$1, d), s = buildLoc$1(i)) : (i = fromLoc$1(o, "start") || buildLoc$1(fromLoc$1(t, "start") || defaultLoc$1, d.slice(0, l)), s = fromLoc$1(o, "end") || buildLoc$1(i, d.substr(l, c))), { css: d, mismatchOffset: l, mismatchLength: c, start: i, end: s } } function fromLoc$1(e, t) { const n = e && e.loc && e.loc[t]; return n ? "line" in n ? buildLoc$1(n) : n : null } function buildLoc$1({ offset: e, line: t, column: n }, r) { const a = { offset: e, line: t, column: n }; if (r) { const e = r.split(/\n|\r\n?|\f/); a.offset += r.length, a.line += e.length - 1, a.column = 1 === e.length ? a.column + r.length : e.pop().length + 1 } return a } const SyntaxReferenceError$1 = function (e, t) { const n = createCustomError$1("SyntaxReferenceError", e + (t ? " `" + t + "`" : "")); return n.reference = t, n }, SyntaxMatchError$1 = function (e, t, n, r) { const a = createCustomError$1("SyntaxMatchError", e), { css: o, mismatchOffset: i, mismatchLength: s, start: l, end: c } = locateMismatch$1(r, n); return a.rawMessage = e, a.syntax = t ? generate$1u(t) : "<generic>", a.css = o, a.mismatchOffset = i, a.mismatchLength = s, a.message = e + "\n  syntax: " + a.syntax + "\n   value: " + (o || "<empty string>") + "\n  --------" + new Array(a.mismatchOffset + 1).join("-") + "^", Object.assign(a, l), a.loc = { source: n && n.loc && n.loc.source || "<unknown>", start: l, end: c }, a }, keywords$1 = new Map, properties$1 = new Map, HYPHENMINUS$c = 45, keyword$1 = getKeywordDescriptor$1, property$1 = getPropertyDescriptor$1; function isCustomProperty$1(e, t) { return t = t || 0, e.length - t >= 2 && e.charCodeAt(t) === HYPHENMINUS$c && e.charCodeAt(t + 1) === HYPHENMINUS$c } function getVendorPrefix$1(e, t) { if (t = t || 0, e.length - t >= 3 && e.charCodeAt(t) === HYPHENMINUS$c && e.charCodeAt(t + 1) !== HYPHENMINUS$c) { const n = e.indexOf("-", t + 2); if (-1 !== n) return e.substring(t, n + 1) } return "" } function getKeywordDescriptor$1(e) { if (keywords$1.has(e)) return keywords$1.get(e); const t = e.toLowerCase(); let n = keywords$1.get(t); if (void 0 === n) { const e = isCustomProperty$1(t, 0), r = e ? "" : getVendorPrefix$1(t, 0); n = Object.freeze({ basename: t.substr(r.length), name: t, prefix: r, vendor: r, custom: e }) } return keywords$1.set(e, n), n } function getPropertyDescriptor$1(e) { if (properties$1.has(e)) return properties$1.get(e); let t = e, n = e[0]; "/" === n ? n = "/" === e[1] ? "//" : "/" : "_" !== n && "*" !== n && "$" !== n && "#" !== n && "+" !== n && "&" !== n && (n = ""); const r = isCustomProperty$1(t, n.length); if (!r && (t = t.toLowerCase(), properties$1.has(t))) { const n = properties$1.get(t); return properties$1.set(e, n), n } const a = r ? "" : getVendorPrefix$1(t, n.length), o = t.substr(0, n.length + a.length), i = Object.freeze({ basename: t.substr(o.length), name: t.substr(n.length), hack: n, vendor: a, prefix: o, custom: r }); return properties$1.set(e, i), i } const cssWideKeywords$1 = ["initial", "inherit", "unset", "revert", "revert-layer"], PLUSSIGN$i = 43, HYPHENMINUS$b = 45, N$8 = 110, DISALLOW_SIGN$3 = !0, ALLOW_SIGN$3 = !1; function isDelim$3(e, t) { return null !== e && e.type === Delim$1 && e.value.charCodeAt(0) === t } function skipSC$1(e, t, n) { for (; null !== e && (e.type === WhiteSpace$3 || e.type === Comment$3);)e = n(++t); return t } function checkInteger$3(e, t, n, r) { if (!e) return 0; const a = e.value.charCodeAt(t); if (a === PLUSSIGN$i || a === HYPHENMINUS$b) { if (n) return 0; t++ } for (; t < e.value.length; t++)if (!isDigit$2(e.value.charCodeAt(t))) return 0; return r + 1 } function consumeB$3(e, t, n) { let r = !1, a = skipSC$1(e, t, n); if (null === (e = n(a))) return t; if (e.type !== Number$5) { if (!isDelim$3(e, PLUSSIGN$i) && !isDelim$3(e, HYPHENMINUS$b)) return t; if (r = !0, a = skipSC$1(n(++a), a, n), null === (e = n(a)) || e.type !== Number$5) return 0 } if (!r) { const t = e.value.charCodeAt(0); if (t !== PLUSSIGN$i && t !== HYPHENMINUS$b) return 0 } return checkInteger$3(e, r ? 0 : 1, r, a) } function anPlusB$1(e, t) { let n = 0; if (!e) return 0; if (e.type === Number$5) return checkInteger$3(e, 0, false, n); if (e.type === Ident$1 && e.value.charCodeAt(0) === HYPHENMINUS$b) { if (!cmpChar$1(e.value, 1, 110)) return 0; switch (e.value.length) { case 2: return consumeB$3(t(++n), n, t); case 3: return e.value.charCodeAt(2) !== HYPHENMINUS$b ? 0 : (n = skipSC$1(t(++n), n, t), checkInteger$3(e = t(n), 0, true, n)); default: return e.value.charCodeAt(2) !== HYPHENMINUS$b ? 0 : checkInteger$3(e, 3, true, n) } } else if (e.type === Ident$1 || isDelim$3(e, PLUSSIGN$i) && t(n + 1).type === Ident$1) { if (e.type !== Ident$1 && (e = t(++n)), null === e || !cmpChar$1(e.value, 0, 110)) return 0; switch (e.value.length) { case 1: return consumeB$3(t(++n), n, t); case 2: return e.value.charCodeAt(1) !== HYPHENMINUS$b ? 0 : (n = skipSC$1(t(++n), n, t), checkInteger$3(e = t(n), 0, true, n)); default: return e.value.charCodeAt(1) !== HYPHENMINUS$b ? 0 : checkInteger$3(e, 2, true, n) } } else if (e.type === Dimension$3) { let r = e.value.charCodeAt(0), a = r === PLUSSIGN$i || r === HYPHENMINUS$b ? 1 : 0, o = a; for (; o < e.value.length && isDigit$2(e.value.charCodeAt(o)); o++); return o === a ? 0 : cmpChar$1(e.value, o, 110) ? o + 1 === e.value.length ? consumeB$3(t(++n), n, t) : e.value.charCodeAt(o + 1) !== HYPHENMINUS$b ? 0 : o + 2 === e.value.length ? (n = skipSC$1(t(++n), n, t), checkInteger$3(e = t(n), 0, true, n)) : checkInteger$3(e, o + 2, true, n) : 0 } return 0 } const PLUSSIGN$h = 43, HYPHENMINUS$a = 45, QUESTIONMARK$5 = 63, U$3 = 117; function isDelim$2(e, t) { return null !== e && e.type === Delim$1 && e.value.charCodeAt(0) === t } function startsWith$3(e, t) { return e.value.charCodeAt(0) === t } function hexSequence$1(e, t, n) { let r = 0; for (let a = t; a < e.value.length; a++) { const o = e.value.charCodeAt(a); if (o === HYPHENMINUS$a && n && 0 !== r) return hexSequence$1(e, t + r + 1, !1), 6; if (!isHexDigit$1(o)) return 0; if (++r > 6) return 0 } return r } function withQuestionMarkSequence$1(e, t, n) { if (!e) return 0; for (; isDelim$2(n(t), QUESTIONMARK$5);) { if (++e > 6) return 0; t++ } return t } function urange$1(e, t) { let n = 0; if (null === e || e.type !== Ident$1 || !cmpChar$1(e.value, 0, 117)) return 0; if (null === (e = t(++n))) return 0; if (isDelim$2(e, 43)) return null === (e = t(++n)) ? 0 : e.type === Ident$1 ? withQuestionMarkSequence$1(hexSequence$1(e, 0, !0), ++n, t) : isDelim$2(e, QUESTIONMARK$5) ? withQuestionMarkSequence$1(1, ++n, t) : 0; if (e.type === Number$5) { const r = hexSequence$1(e, 1, !0); return 0 === r ? 0 : null === (e = t(++n)) ? n : e.type === Dimension$3 || e.type === Number$5 ? startsWith$3(e, HYPHENMINUS$a) && hexSequence$1(e, 1, !1) ? n + 1 : 0 : withQuestionMarkSequence$1(r, n, t) } return e.type === Dimension$3 ? withQuestionMarkSequence$1(hexSequence$1(e, 1, !0), ++n, t) : 0 } const calcFunctionNames$1 = ["calc(", "-moz-calc(", "-webkit-calc("], balancePair$2 = new Map([[Function$3, RightParenthesis$1], [LeftParenthesis$1, RightParenthesis$1], [LeftSquareBracket$1, RightSquareBracket$1], [LeftCurlyBracket$1, RightCurlyBracket$1]]); function charCodeAt$1(e, t) { return t < e.length ? e.charCodeAt(t) : 0 } function eqStr$1(e, t) { return cmpStr$1(e, 0, e.length, t) } function eqStrAny$1(e, t) { for (let n = 0; n < t.length; n++)if (eqStr$1(e, t[n])) return !0; return !1 } function isPostfixIeHack$1(e, t) { return t === e.length - 2 && (92 === charCodeAt$1(e, t) && isDigit$2(charCodeAt$1(e, t + 1))) } function outOfRange$1(e, t, n) { if (e && "Range" === e.type) { const r = Number(void 0 !== n && n !== t.length ? t.substr(0, n) : t); if (isNaN(r)) return !0; if (null !== e.min && r < e.min && "string" != typeof e.min) return !0; if (null !== e.max && r > e.max && "string" != typeof e.max) return !0 } return !1 } function consumeFunction$1(e, t) { let n = 0, r = [], a = 0; e: do { switch (e.type) { case RightCurlyBracket$1: case RightParenthesis$1: case RightSquareBracket$1: if (e.type !== n) break e; if (n = r.pop(), 0 === r.length) { a++; break e } break; case Function$3: case LeftParenthesis$1: case LeftSquareBracket$1: case LeftCurlyBracket$1: r.push(n), n = balancePair$2.get(e.type) }a++ } while (e = t(a)); return a } function calc$1(e) { return function (t, n, r) { return null === t ? 0 : t.type === Function$3 && eqStrAny$1(t.value, calcFunctionNames$1) ? consumeFunction$1(t, n) : e(t, n, r) } } function tokenType$1(e) { return function (t) { return null === t || t.type !== e ? 0 : 1 } } function customIdent$1(e) { if (null === e || e.type !== Ident$1) return 0; const t = e.value.toLowerCase(); return eqStrAny$1(t, cssWideKeywords$1) || eqStr$1(t, "default") ? 0 : 1 } function dashedIdent(e) { return null === e || e.type !== Ident$1 || 45 !== charCodeAt$1(e.value, 0) || 45 !== charCodeAt$1(e.value, 1) ? 0 : 1 } function customPropertyName$1(e) { return dashedIdent(e) ? "--" === e.value ? 0 : 1 : 0 } function hexColor$1(e) { if (null === e || e.type !== Hash$3) return 0; const t = e.value.length; if (4 !== t && 5 !== t && 7 !== t && 9 !== t) return 0; for (let n = 1; n < t; n++)if (!isHexDigit$1(charCodeAt$1(e.value, n))) return 0; return 1 } function idSelector$1(e) { return null === e || e.type !== Hash$3 ? 0 : isIdentifierStart$1(charCodeAt$1(e.value, 1), charCodeAt$1(e.value, 2), charCodeAt$1(e.value, 3)) ? 1 : 0 } function declarationValue$1(e, t) { if (!e) return 0; let n = 0, r = [], a = 0; e: do { switch (e.type) { case BadString$1: case BadUrl$1: break e; case RightCurlyBracket$1: case RightParenthesis$1: case RightSquareBracket$1: if (e.type !== n) break e; n = r.pop(); break; case Semicolon$1: if (0 === n) break e; break; case Delim$1: if (0 === n && "!" === e.value) break e; break; case Function$3: case LeftParenthesis$1: case LeftSquareBracket$1: case LeftCurlyBracket$1: r.push(n), n = balancePair$2.get(e.type) }a++ } while (e = t(a)); return a } function anyValue$1(e, t) { if (!e) return 0; let n = 0, r = [], a = 0; e: do { switch (e.type) { case BadString$1: case BadUrl$1: break e; case RightCurlyBracket$1: case RightParenthesis$1: case RightSquareBracket$1: if (e.type !== n) break e; n = r.pop(); break; case Function$3: case LeftParenthesis$1: case LeftSquareBracket$1: case LeftCurlyBracket$1: r.push(n), n = balancePair$2.get(e.type) }a++ } while (e = t(a)); return a } function dimension$1(e) { return e && (e = new Set(e)), function (t, n, r) { if (null === t || t.type !== Dimension$3) return 0; const a = consumeNumber$2(t.value, 0); if (null !== e) { const n = t.value.indexOf("\\", a), r = -1 !== n && isPostfixIeHack$1(t.value, n) ? t.value.substring(a, n) : t.value.substr(a); if (!1 === e.has(r.toLowerCase())) return 0 } return outOfRange$1(r, t.value, a) ? 0 : 1 } } function percentage$1(e, t, n) { return null === e || e.type !== Percentage$3 || outOfRange$1(n, e.value, e.value.length - 1) ? 0 : 1 } function zero$1(e) { return "function" != typeof e && (e = function () { return 0 }), function (t, n, r) { return null !== t && t.type === Number$5 && 0 === Number(t.value) ? 1 : e(t, n, r) } } function number$1(e, t, n) { if (null === e) return 0; const r = consumeNumber$2(e.value, 0); return r === e.value.length || isPostfixIeHack$1(e.value, r) ? outOfRange$1(n, e.value, r) ? 0 : 1 : 0 } function integer$1(e, t, n) { if (null === e || e.type !== Number$5) return 0; let r = 43 === charCodeAt$1(e.value, 0) || 45 === charCodeAt$1(e.value, 0) ? 1 : 0; for (; r < e.value.length; r++)if (!isDigit$2(charCodeAt$1(e.value, r))) return 0; return outOfRange$1(n, e.value, r) ? 0 : 1 } const tokenTypes = { "ident-token": tokenType$1(Ident$1), "function-token": tokenType$1(Function$3), "at-keyword-token": tokenType$1(AtKeyword$1), "hash-token": tokenType$1(Hash$3), "string-token": tokenType$1(String$4), "bad-string-token": tokenType$1(BadString$1), "url-token": tokenType$1(Url$4), "bad-url-token": tokenType$1(BadUrl$1), "delim-token": tokenType$1(Delim$1), "number-token": tokenType$1(Number$5), "percentage-token": tokenType$1(Percentage$3), "dimension-token": tokenType$1(Dimension$3), "whitespace-token": tokenType$1(WhiteSpace$3), "CDO-token": tokenType$1(CDO$3), "CDC-token": tokenType$1(CDC$3), "colon-token": tokenType$1(Colon$1), "semicolon-token": tokenType$1(Semicolon$1), "comma-token": tokenType$1(Comma$1), "[-token": tokenType$1(LeftSquareBracket$1), "]-token": tokenType$1(RightSquareBracket$1), "(-token": tokenType$1(LeftParenthesis$1), ")-token": tokenType$1(RightParenthesis$1), "{-token": tokenType$1(LeftCurlyBracket$1), "}-token": tokenType$1(RightCurlyBracket$1) }, productionTypes = { string: tokenType$1(String$4), ident: tokenType$1(Ident$1), percentage: calc$1(percentage$1), zero: zero$1(), number: calc$1(number$1), integer: calc$1(integer$1), "custom-ident": customIdent$1, "dashed-ident": dashedIdent, "custom-property-name": customPropertyName$1, "hex-color": hexColor$1, "id-selector": idSelector$1, "an-plus-b": anPlusB$1, urange: urange$1, "declaration-value": declarationValue$1, "any-value": anyValue$1 }; function createDemensionTypes(e) { const { angle: t, decibel: n, frequency: r, flex: a, length: o, resolution: i, semitones: s, time: l } = e || {}; return { dimension: calc$1(dimension$1(null)), angle: calc$1(dimension$1(t)), decibel: calc$1(dimension$1(n)), frequency: calc$1(dimension$1(r)), flex: calc$1(dimension$1(a)), length: calc$1(zero$1(dimension$1(o))), resolution: calc$1(dimension$1(i)), semitones: calc$1(dimension$1(s)), time: calc$1(dimension$1(l)) } } function createGenericTypes(e) { return { ...tokenTypes, ...productionTypes, ...createDemensionTypes(e) } } const length = ["cm", "mm", "q", "in", "pt", "pc", "px", "em", "rem", "ex", "rex", "cap", "rcap", "ch", "rch", "ic", "ric", "lh", "rlh", "vw", "svw", "lvw", "dvw", "vh", "svh", "lvh", "dvh", "vi", "svi", "lvi", "dvi", "vb", "svb", "lvb", "dvb", "vmin", "svmin", "lvmin", "dvmin", "vmax", "svmax", "lvmax", "dvmax", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"], angle = ["deg", "grad", "rad", "turn"], time = ["s", "ms"], frequency = ["hz", "khz"], resolution = ["dpi", "dpcm", "dppx", "x"], flex = ["fr"], decibel = ["db"], semitones = ["st"]; var units = Object.freeze({ __proto__: null, angle: angle, decibel: decibel, flex: flex, frequency: frequency, length: length, resolution: resolution, semitones: semitones, time: time }); function SyntaxError$3(e, t, n) { return Object.assign(createCustomError$1("SyntaxError", e), { input: t, offset: n, rawMessage: e, message: e + "\n  " + t + "\n--" + new Array((n || t.length) + 1).join("-") + "^" }) } const TAB$3 = 9, N$7 = 10, F$4 = 12, R$4 = 13, SPACE$7 = 32; let Tokenizer$1 = class { constructor(e) { this.str = e, this.pos = 0 } charCodeAt(e) { return e < this.str.length ? this.str.charCodeAt(e) : 0 } charCode() { return this.charCodeAt(this.pos) } nextCharCode() { return this.charCodeAt(this.pos + 1) } nextNonWsCode(e) { return this.charCodeAt(this.findWsEnd(e)) } skipWs() { this.pos = this.findWsEnd(this.pos) } findWsEnd(e) { for (; e < this.str.length; e++) { const t = this.str.charCodeAt(e); if (13 !== t && 10 !== t && 12 !== t && 32 !== t && 9 !== t) break } return e } substringToPos(e) { return this.str.substring(this.pos, this.pos = e) } eat(e) { this.charCode() !== e && this.error("Expect `" + String.fromCharCode(e) + "`"), this.pos++ } peek() { return this.pos < this.str.length ? this.str.charAt(this.pos++) : "" } error(e) { throw new SyntaxError$3(e, this.str, this.pos) } }; const TAB$2 = 9, N$6 = 10, F$3 = 12, R$3 = 13, SPACE$6 = 32, EXCLAMATIONMARK$6 = 33, NUMBERSIGN$8 = 35, AMPERSAND$7 = 38, APOSTROPHE$5 = 39, LEFTPARENTHESIS$5 = 40, RIGHTPARENTHESIS$5 = 41, ASTERISK$d = 42, PLUSSIGN$g = 43, COMMA$1 = 44, HYPERMINUS$1 = 45, LESSTHANSIGN$2 = 60, GREATERTHANSIGN$6 = 62, QUESTIONMARK$4 = 63, COMMERCIALAT$1 = 64, LEFTSQUAREBRACKET$1 = 91, RIGHTSQUAREBRACKET$1 = 93, LEFTCURLYBRACKET$2 = 123, VERTICALLINE$7 = 124, RIGHTCURLYBRACKET$1 = 125, INFINITY$1 = 8734, NAME_CHAR$1 = new Uint8Array(128).map(((e, t) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(t)) ? 1 : 0)), COMBINATOR_PRECEDENCE$1 = { " ": 1, "&&": 2, "||": 3, "|": 4 }; function scanSpaces$1(e) { return e.substringToPos(e.findWsEnd(e.pos)) } function scanWord$1(e) { let t = e.pos; for (; t < e.str.length; t++) { const n = e.str.charCodeAt(t); if (n >= 128 || 0 === NAME_CHAR$1[n]) break } return e.pos === t && e.error("Expect a keyword"), e.substringToPos(t) } function scanNumber$1(e) { let t = e.pos; for (; t < e.str.length; t++) { const n = e.str.charCodeAt(t); if (n < 48 || n > 57) break } return e.pos === t && e.error("Expect a number"), e.substringToPos(t) } function scanString$1(e) { const t = e.str.indexOf("'", e.pos + 1); return -1 === t && (e.pos = e.str.length, e.error("Expect an apostrophe")), e.substringToPos(t + 1) } function readMultiplierRange$1(e) { let t = null, n = null; return e.eat(LEFTCURLYBRACKET$2), e.skipWs(), t = scanNumber$1(e), e.skipWs(), e.charCode() === COMMA$1 ? (e.pos++, e.skipWs(), e.charCode() !== RIGHTCURLYBRACKET$1 && (n = scanNumber$1(e), e.skipWs())) : n = t, e.eat(RIGHTCURLYBRACKET$1), { min: Number(t), max: n ? Number(n) : 0 } } function readMultiplier$1(e) { let t = null, n = !1; switch (e.charCode()) { case ASTERISK$d: e.pos++, t = { min: 0, max: 0 }; break; case PLUSSIGN$g: e.pos++, t = { min: 1, max: 0 }; break; case QUESTIONMARK$4: e.pos++, t = { min: 0, max: 1 }; break; case NUMBERSIGN$8: e.pos++, n = !0, e.charCode() === LEFTCURLYBRACKET$2 ? t = readMultiplierRange$1(e) : e.charCode() === QUESTIONMARK$4 ? (e.pos++, t = { min: 0, max: 0 }) : t = { min: 1, max: 0 }; break; case LEFTCURLYBRACKET$2: t = readMultiplierRange$1(e); break; default: return null }return { type: "Multiplier", comma: n, min: t.min, max: t.max, term: null } } function maybeMultiplied$1(e, t) { const n = readMultiplier$1(e); return null !== n ? (n.term = t, e.charCode() === NUMBERSIGN$8 && e.charCodeAt(e.pos - 1) === PLUSSIGN$g ? maybeMultiplied$1(e, n) : n) : t } function maybeToken$1(e) { const t = e.peek(); return "" === t ? null : { type: "Token", value: t } } function readProperty$3(e) { let t; return e.eat(LESSTHANSIGN$2), e.eat(APOSTROPHE$5), t = scanWord$1(e), e.eat(APOSTROPHE$5), e.eat(GREATERTHANSIGN$6), maybeMultiplied$1(e, { type: "Property", name: t }) } function readTypeRange$1(e) { let t = null, n = null, r = 1; return e.eat(LEFTSQUAREBRACKET$1), e.charCode() === HYPERMINUS$1 && (e.peek(), r = -1), -1 == r && e.charCode() === INFINITY$1 ? e.peek() : (t = r * Number(scanNumber$1(e)), 0 !== NAME_CHAR$1[e.charCode()] && (t += scanWord$1(e))), scanSpaces$1(e), e.eat(COMMA$1), scanSpaces$1(e), e.charCode() === INFINITY$1 ? e.peek() : (r = 1, e.charCode() === HYPERMINUS$1 && (e.peek(), r = -1), n = r * Number(scanNumber$1(e)), 0 !== NAME_CHAR$1[e.charCode()] && (n += scanWord$1(e))), e.eat(RIGHTSQUAREBRACKET$1), { type: "Range", min: t, max: n } } function readType$1(e) { let t, n = null; return e.eat(LESSTHANSIGN$2), t = scanWord$1(e), e.charCode() === LEFTPARENTHESIS$5 && e.nextCharCode() === RIGHTPARENTHESIS$5 && (e.pos += 2, t += "()"), e.charCodeAt(e.findWsEnd(e.pos)) === LEFTSQUAREBRACKET$1 && (scanSpaces$1(e), n = readTypeRange$1(e)), e.eat(GREATERTHANSIGN$6), maybeMultiplied$1(e, { type: "Type", name: t, opts: n }) } function readKeywordOrFunction$1(e) { const t = scanWord$1(e); return e.charCode() === LEFTPARENTHESIS$5 ? (e.pos++, { type: "Function", name: t }) : maybeMultiplied$1(e, { type: "Keyword", name: t }) } function regroupTerms$1(e, t) { function n(e, t) { return { type: "Group", terms: e, combinator: t, disallowEmpty: !1, explicit: !1 } } let r; for (t = Object.keys(t).sort(((e, t) => COMBINATOR_PRECEDENCE$1[e] - COMBINATOR_PRECEDENCE$1[t])); t.length > 0;) { r = t.shift(); let a = 0, o = 0; for (; a < e.length; a++) { const t = e[a]; "Combinator" === t.type && (t.value === r ? (-1 === o && (o = a - 1), e.splice(a, 1), a--) : (-1 !== o && a - o > 1 && (e.splice(o, a - o, n(e.slice(o, a), r)), a = o + 1), o = -1)) } -1 !== o && t.length && e.splice(o, a - o, n(e.slice(o, a), r)) } return r } function readImplicitGroup$1(e) { const t = [], n = {}; let r, a = null, o = e.pos; for (; r = peek$1(e);)"Spaces" !== r.type && ("Combinator" === r.type ? (null !== a && "Combinator" !== a.type || (e.pos = o, e.error("Unexpected combinator")), n[r.value] = !0) : null !== a && "Combinator" !== a.type && (n[" "] = !0, t.push({ type: "Combinator", value: " " })), t.push(r), a = r, o = e.pos); return null !== a && "Combinator" === a.type && (e.pos -= o, e.error("Unexpected combinator")), { type: "Group", terms: t, combinator: regroupTerms$1(t, n) || " ", disallowEmpty: !1, explicit: !1 } } function readGroup$1(e) { let t; return e.eat(LEFTSQUAREBRACKET$1), t = readImplicitGroup$1(e), e.eat(RIGHTSQUAREBRACKET$1), t.explicit = !0, e.charCode() === EXCLAMATIONMARK$6 && (e.pos++, t.disallowEmpty = !0), t } function peek$1(e) { let t = e.charCode(); if (t < 128 && 1 === NAME_CHAR$1[t]) return readKeywordOrFunction$1(e); switch (t) { case RIGHTSQUAREBRACKET$1: break; case LEFTSQUAREBRACKET$1: return maybeMultiplied$1(e, readGroup$1(e)); case LESSTHANSIGN$2: return e.nextCharCode() === APOSTROPHE$5 ? readProperty$3(e) : readType$1(e); case VERTICALLINE$7: return { type: "Combinator", value: e.substringToPos(e.pos + (e.nextCharCode() === VERTICALLINE$7 ? 2 : 1)) }; case AMPERSAND$7: return e.pos++, e.eat(AMPERSAND$7), { type: "Combinator", value: "&&" }; case COMMA$1: return e.pos++, { type: "Comma" }; case APOSTROPHE$5: return maybeMultiplied$1(e, { type: "String", value: scanString$1(e) }); case SPACE$6: case TAB$2: case N$6: case R$3: case F$3: return { type: "Spaces", value: scanSpaces$1(e) }; case COMMERCIALAT$1: return t = e.nextCharCode(), t < 128 && 1 === NAME_CHAR$1[t] ? (e.pos++, { type: "AtKeyword", name: scanWord$1(e) }) : maybeToken$1(e); case ASTERISK$d: case PLUSSIGN$g: case QUESTIONMARK$4: case NUMBERSIGN$8: case EXCLAMATIONMARK$6: break; case LEFTCURLYBRACKET$2: if (t = e.nextCharCode(), t < 48 || t > 57) return maybeToken$1(e); break; default: return maybeToken$1(e) } } function parse$1u(e) { const t = new Tokenizer$1(e), n = readImplicitGroup$1(t); return t.pos !== e.length && t.error("Unexpected input"), 1 === n.terms.length && "Group" === n.terms[0].type ? n.terms[0] : n } const noop$3 = function () { }; function ensureFunction$2(e) { return "function" == typeof e ? e : noop$3 } function walk$4(e, t, n) { let r = noop$3, a = noop$3; if ("function" == typeof t ? r = t : t && (r = ensureFunction$2(t.enter), a = ensureFunction$2(t.leave)), r === noop$3 && a === noop$3) throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function"); !function e(t) { switch (r.call(n, t), t.type) { case "Group": t.terms.forEach(e); break; case "Multiplier": e(t.term); break; case "Type": case "Property": case "Keyword": case "AtKeyword": case "Function": case "String": case "Token": case "Comma": break; default: throw new Error("Unknown type: " + t.type) }a.call(n, t) }(e) } const astToTokens$1 = { decorator(e) { const t = []; let n = null; return { ...e, node(t) { const r = n; n = t, e.node.call(this, t), n = r }, emit(e, r, a) { t.push({ type: r, value: e, node: a ? null : n }) }, result: () => t } } }; function stringToTokens$1(e) { const t = []; return tokenize$4(e, ((n, r, a) => t.push({ type: n, value: e.slice(r, a), node: null }))), t } function prepareTokens$1(e, t) { return "string" == typeof e ? stringToTokens$1(e) : t.generate(e, astToTokens$1) } const MATCH$1 = { type: "Match" }, MISMATCH$1 = { type: "Mismatch" }, DISALLOW_EMPTY$1 = { type: "DisallowEmpty" }, LEFTPARENTHESIS$4 = 40, RIGHTPARENTHESIS$4 = 41; function createCondition$1(e, t, n) { return t === MATCH$1 && n === MISMATCH$1 || e === MATCH$1 && t === MATCH$1 && n === MATCH$1 ? e : ("If" === e.type && e.else === MISMATCH$1 && t === MATCH$1 && (t = e.then, e = e.match), { type: "If", match: e, then: t, else: n }) } function isFunctionType$1(e) { return e.length > 2 && e.charCodeAt(e.length - 2) === LEFTPARENTHESIS$4 && e.charCodeAt(e.length - 1) === RIGHTPARENTHESIS$4 } function isEnumCapatible$1(e) { return "Keyword" === e.type || "AtKeyword" === e.type || "Function" === e.type || "Type" === e.type && isFunctionType$1(e.name) } function buildGroupMatchGraph$1(e, t, n) { switch (e) { case " ": { let e = MATCH$1; for (let n = t.length - 1; n >= 0; n--) { e = createCondition$1(t[n], e, MISMATCH$1) } return e } case "|": { let e = MISMATCH$1, n = null; for (let r = t.length - 1; r >= 0; r--) { let a = t[r]; if (isEnumCapatible$1(a) && (null === n && r > 0 && isEnumCapatible$1(t[r - 1]) && (n = Object.create(null), e = createCondition$1({ type: "Enum", map: n }, MATCH$1, e)), null !== n)) { const e = (isFunctionType$1(a.name) ? a.name.slice(0, -1) : a.name).toLowerCase(); if (e in n == !1) { n[e] = a; continue } } n = null, e = createCondition$1(a, MATCH$1, e) } return e } case "&&": { if (t.length > 5) return { type: "MatchOnce", terms: t, all: !0 }; let n = MISMATCH$1; for (let r = t.length - 1; r >= 0; r--) { const a = t[r]; let o; o = t.length > 1 ? buildGroupMatchGraph$1(e, t.filter((function (e) { return e !== a })), !1) : MATCH$1, n = createCondition$1(a, o, n) } return n } case "||": { if (t.length > 5) return { type: "MatchOnce", terms: t, all: !1 }; let r = n ? MATCH$1 : MISMATCH$1; for (let n = t.length - 1; n >= 0; n--) { const a = t[n]; let o; o = t.length > 1 ? buildGroupMatchGraph$1(e, t.filter((function (e) { return e !== a })), !0) : MATCH$1, r = createCondition$1(a, o, r) } return r } } } function buildMultiplierMatchGraph$1(e) { let t = MATCH$1, n = buildMatchGraphInternal$1(e.term); if (0 === e.max) n = createCondition$1(n, DISALLOW_EMPTY$1, MISMATCH$1), t = createCondition$1(n, null, MISMATCH$1), t.then = createCondition$1(MATCH$1, MATCH$1, t), e.comma && (t.then.else = createCondition$1({ type: "Comma", syntax: e }, t, MISMATCH$1)); else for (let r = e.min || 1; r <= e.max; r++)e.comma && t !== MATCH$1 && (t = createCondition$1({ type: "Comma", syntax: e }, t, MISMATCH$1)), t = createCondition$1(n, createCondition$1(MATCH$1, MATCH$1, t), MISMATCH$1); if (0 === e.min) t = createCondition$1(MATCH$1, MATCH$1, t); else for (let r = 0; r < e.min - 1; r++)e.comma && t !== MATCH$1 && (t = createCondition$1({ type: "Comma", syntax: e }, t, MISMATCH$1)), t = createCondition$1(n, t, MISMATCH$1); return t } function buildMatchGraphInternal$1(e) { if ("function" == typeof e) return { type: "Generic", fn: e }; switch (e.type) { case "Group": { let t = buildGroupMatchGraph$1(e.combinator, e.terms.map(buildMatchGraphInternal$1), !1); return e.disallowEmpty && (t = createCondition$1(t, DISALLOW_EMPTY$1, MISMATCH$1)), t } case "Multiplier": return buildMultiplierMatchGraph$1(e); case "Type": case "Property": return { type: e.type, name: e.name, syntax: e }; case "Keyword": return { type: e.type, name: e.name.toLowerCase(), syntax: e }; case "AtKeyword": return { type: e.type, name: "@" + e.name.toLowerCase(), syntax: e }; case "Function": return { type: e.type, name: e.name.toLowerCase() + "(", syntax: e }; case "String": return 3 === e.value.length ? { type: "Token", value: e.value.charAt(1), syntax: e } : { type: e.type, value: e.value.substr(1, e.value.length - 2).replace(/\\'/g, "'"), syntax: e }; case "Token": return { type: e.type, value: e.value, syntax: e }; case "Comma": return { type: e.type, syntax: e }; default: throw new Error("Unknown node type:", e.type) } } function buildMatchGraph$1(e, t) { return "string" == typeof e && (e = parse$1u(e)), { type: "MatchGraph", match: buildMatchGraphInternal$1(e), syntax: t || null, source: e } } const { hasOwnProperty: hasOwnProperty$a } = Object.prototype, STUB$1 = 0, TOKEN$1 = 1, OPEN_SYNTAX$1 = 2, CLOSE_SYNTAX$1 = 3, EXIT_REASON_MATCH$1 = "Match", EXIT_REASON_MISMATCH$1 = "Mismatch", EXIT_REASON_ITERATION_LIMIT$1 = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)", ITERATION_LIMIT$1 = 15e3; function reverseList$1(e) { let t = null, n = null, r = e; for (; null !== r;)n = r.prev, r.prev = t, t = r, r = n; return t } function areStringsEqualCaseInsensitive$1(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; n++) { const r = t.charCodeAt(n); let a = e.charCodeAt(n); if (a >= 65 && a <= 90 && (a |= 32), a !== r) return !1 } return !0 } function isContextEdgeDelim$1(e) { return e.type === Delim$1 && "?" !== e.value } function isCommaContextStart$1(e) { return null === e || (e.type === Comma$1 || e.type === Function$3 || e.type === LeftParenthesis$1 || e.type === LeftSquareBracket$1 || e.type === LeftCurlyBracket$1 || isContextEdgeDelim$1(e)) } function isCommaContextEnd$1(e) { return null === e || (e.type === RightParenthesis$1 || e.type === RightSquareBracket$1 || e.type === RightCurlyBracket$1 || e.type === Delim$1 && "/" === e.value) } function internalMatch$1(e, t, n) { function r() { do { b++, g = b < e.length ? e[b] : null } while (null !== g && (g.type === WhiteSpace$3 || g.type === Comment$3)) } function a(t) { const n = b + t; return n < e.length ? e[n] : null } function o(e, t) { return { nextState: e, matchStack: $, syntaxStack: u, thenStack: d, tokenIndex: b, prev: t } } function i(e) { d = { nextState: e, matchStack: $, syntaxStack: u, prev: d } } function s(e) { p = o(e, p) } function l() { $ = { type: TOKEN$1, syntax: t.syntax, token: g, prev: $ }, r(), h = null, b > y && (y = b) } function c() { $ = $.type === OPEN_SYNTAX$1 ? $.prev : { type: CLOSE_SYNTAX$1, syntax: u.syntax, token: $.token, prev: $ }, u = u.prev } let u = null, d = null, p = null, h = null, m = 0, f = null, g = null, b = -1, y = 0, $ = { type: STUB$1, syntax: null, token: null, prev: null }; for (r(); null === f && ++m < ITERATION_LIMIT$1;)switch (t.type) { case "Match": if (null === d) { if (null !== g && (b !== e.length - 1 || "\\0" !== g.value && "\\9" !== g.value)) { t = MISMATCH$1; break } f = EXIT_REASON_MATCH$1; break } if ((t = d.nextState) === DISALLOW_EMPTY$1) { if (d.matchStack === $) { t = MISMATCH$1; break } t = MATCH$1 } for (; d.syntaxStack !== u;)c(); d = d.prev; break; case "Mismatch": if (null !== h && !1 !== h) (null === p || b > p.tokenIndex) && (p = h, h = !1); else if (null === p) { f = EXIT_REASON_MISMATCH$1; break } t = p.nextState, d = p.thenStack, u = p.syntaxStack, $ = p.matchStack, b = p.tokenIndex, g = b < e.length ? e[b] : null, p = p.prev; break; case "MatchGraph": t = t.match; break; case "If": t.else !== MISMATCH$1 && s(t.else), t.then !== MATCH$1 && i(t.then), t = t.match; break; case "MatchOnce": t = { type: "MatchOnceBuffer", syntax: t, index: 0, mask: 0 }; break; case "MatchOnceBuffer": { const e = t.syntax.terms; if (t.index === e.length) { if (0 === t.mask || t.syntax.all) { t = MISMATCH$1; break } t = MATCH$1; break } if (t.mask === (1 << e.length) - 1) { t = MATCH$1; break } for (; t.index < e.length; t.index++) { const n = 1 << t.index; if (0 == (t.mask & n)) { s(t), i({ type: "AddMatchOnce", syntax: t.syntax, mask: t.mask | n }), t = e[t.index++]; break } } break } case "AddMatchOnce": t = { type: "MatchOnceBuffer", syntax: t.syntax, index: 0, mask: t.mask }; break; case "Enum": if (null !== g) { let e = g.value.toLowerCase(); if (-1 !== e.indexOf("\\") && (e = e.replace(/\\[09].*$/, "")), hasOwnProperty$a.call(t.map, e)) { t = t.map[e]; break } } t = MISMATCH$1; break; case "Generic": { const e = null !== u ? u.opts : null, n = b + Math.floor(t.fn(g, a, e)); if (!isNaN(n) && n > b) { for (; b < n;)l(); t = MATCH$1 } else t = MISMATCH$1; break } case "Type": case "Property": { const e = "Type" === t.type ? "types" : "properties", r = hasOwnProperty$a.call(n, e) ? n[e][t.name] : null; if (!r || !r.match) throw new Error("Bad syntax reference: " + ("Type" === t.type ? "<" + t.name + ">" : "<'" + t.name + "'>")); if (!1 !== h && null !== g && "Type" === t.type) { if ("custom-ident" === t.name && g.type === Ident$1 || "length" === t.name && "0" === g.value) { null === h && (h = o(t, p)), t = MISMATCH$1; break } } u = { syntax: t.syntax, opts: t.syntax.opts || null !== u && u.opts || null, prev: u }, $ = { type: OPEN_SYNTAX$1, syntax: t.syntax, token: $.token, prev: $ }, t = r.matchRef || r.match; break } case "Keyword": { const e = t.name; if (null !== g) { let n = g.value; if (-1 !== n.indexOf("\\") && (n = n.replace(/\\[09].*$/, "")), areStringsEqualCaseInsensitive$1(n, e)) { l(), t = MATCH$1; break } } t = MISMATCH$1; break } case "AtKeyword": case "Function": if (null !== g && areStringsEqualCaseInsensitive$1(g.value, t.name)) { l(), t = MATCH$1; break } t = MISMATCH$1; break; case "Token": if (null !== g && g.value === t.value) { l(), t = MATCH$1; break } t = MISMATCH$1; break; case "Comma": null !== g && g.type === Comma$1 ? isCommaContextStart$1($.token) ? t = MISMATCH$1 : (l(), t = isCommaContextEnd$1(g) ? MISMATCH$1 : MATCH$1) : t = isCommaContextStart$1($.token) || isCommaContextEnd$1(g) ? MATCH$1 : MISMATCH$1; break; case "String": let r = "", m = b; for (; m < e.length && r.length < t.value.length; m++)r += e[m].value; if (areStringsEqualCaseInsensitive$1(r, t.value)) { for (; b < m;)l(); t = MATCH$1 } else t = MISMATCH$1; break; default: throw new Error("Unknown node type: " + t.type) }switch (f) { case null: console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT$1 + " iterations"), f = EXIT_REASON_ITERATION_LIMIT$1, $ = null; break; case EXIT_REASON_MATCH$1: for (; null !== u;)c(); break; default: $ = null }return { tokens: e, reason: f, iterations: m, match: $, longestMatch: y } } function matchAsTree$1(e, t, n) { const r = internalMatch$1(e, t, n || {}); if (null === r.match) return r; let a = r.match, o = r.match = { syntax: t.syntax || null, match: [] }; const i = [o]; for (a = reverseList$1(a).prev; null !== a;) { switch (a.type) { case OPEN_SYNTAX$1: o.match.push(o = { syntax: a.syntax, match: [] }), i.push(o); break; case CLOSE_SYNTAX$1: i.pop(), o = i[i.length - 1]; break; default: o.match.push({ syntax: a.syntax || null, token: a.token.value, node: a.token.node }) }a = a.prev } return r } function getTrace$1(e) { function t(e) { return null !== e && ("Type" === e.type || "Property" === e.type || "Keyword" === e.type) } let n = null; return null !== this.matched && function r(a) { if (Array.isArray(a.match)) { for (let e = 0; e < a.match.length; e++)if (r(a.match[e])) return t(a.syntax) && n.unshift(a.syntax), !0 } else if (a.node === e) return n = t(a.syntax) ? [a.syntax] : [], !0; return !1 }(this.matched), n } function isType$1(e, t) { return testNode$1(this, e, (e => "Type" === e.type && e.name === t)) } function isProperty$1(e, t) { return testNode$1(this, e, (e => "Property" === e.type && e.name === t)) } function isKeyword$1(e) { return testNode$1(this, e, (e => "Keyword" === e.type)) } function testNode$1(e, t, n) { const r = getTrace$1.call(e, t); return null !== r && r.some(n) } var trace$1 = Object.freeze({ __proto__: null, getTrace: getTrace$1, isKeyword: isKeyword$1, isProperty: isProperty$1, isType: isType$1 }); function getFirstMatchNode$1(e) { return "node" in e ? e.node : getFirstMatchNode$1(e.match[0]) } function getLastMatchNode$1(e) { return "node" in e ? e.node : getLastMatchNode$1(e.match[e.match.length - 1]) } function matchFragments$1(e, t, n, r, a) { const o = []; return null !== n.matched && function n(i) { if (null !== i.syntax && i.syntax.type === r && i.syntax.name === a) { const n = getFirstMatchNode$1(i), r = getLastMatchNode$1(i); e.syntax.walk(t, (function (e, t, a) { if (e === n) { const e = new List$1; do { if (e.appendData(t.data), t.data === r) break; t = t.next } while (null !== t); o.push({ parent: a, nodes: e }) } })) } Array.isArray(i.match) && i.match.forEach(n) }(n.matched), o } const { hasOwnProperty: hasOwnProperty$9 } = Object.prototype; function isValidNumber$1(e) { return "number" == typeof e && isFinite(e) && Math.floor(e) === e && e >= 0 } function isValidLocation$1(e) { return Boolean(e) && isValidNumber$1(e.offset) && isValidNumber$1(e.line) && isValidNumber$1(e.column) } function createNodeStructureChecker$1(e, t) { return function (n, r) { if (!n || n.constructor !== Object) return r(n, "Type of node should be an Object"); for (let a in n) { let o = !0; if (!1 !== hasOwnProperty$9.call(n, a)) { if ("type" === a) n.type !== e && r(n, "Wrong node type `" + n.type + "`, expected `" + e + "`"); else if ("loc" === a) { if (null === n.loc) continue; if (n.loc && n.loc.constructor === Object) if ("string" != typeof n.loc.source) a += ".source"; else if (isValidLocation$1(n.loc.start)) { if (isValidLocation$1(n.loc.end)) continue; a += ".end" } else a += ".start"; o = !1 } else if (t.hasOwnProperty(a)) { o = !1; for (let e = 0; !o && e < t[a].length; e++) { const r = t[a][e]; switch (r) { case String: o = "string" == typeof n[a]; break; case Boolean: o = "boolean" == typeof n[a]; break; case null: o = null === n[a]; break; default: "string" == typeof r ? o = n[a] && n[a].type === r : Array.isArray(r) && (o = n[a] instanceof List$1) } } } else r(n, "Unknown field `" + a + "` for " + e + " node type"); o || r(n, "Bad value for `" + e + "." + a + "`") } } for (const a in t) hasOwnProperty$9.call(t, a) && !1 === hasOwnProperty$9.call(n, a) && r(n, "Field `" + e + "." + a + "` is missed") } } function genTypesList(e, t) { const n = []; for (let r = 0; r < e.length; r++) { const a = e[r]; if (a === String || a === Boolean) n.push(a.name.toLowerCase()); else if (null === a) n.push("null"); else if ("string" == typeof a) n.push(a); else { if (!Array.isArray(a)) throw new Error("Wrong value `" + a + "` in `" + t + "` structure definition"); n.push("List<" + (genTypesList(a, t) || "any") + ">") } } return n.join(" | ") } function processStructure$1(e, t) { const n = t.structure, r = { type: String, loc: !0 }, a = { type: '"' + e + '"' }; for (const t in n) { if (!1 === hasOwnProperty$9.call(n, t)) continue; const o = r[t] = Array.isArray(n[t]) ? n[t].slice() : [n[t]]; a[t] = genTypesList(o, e + "." + t) } return { docs: a, check: createNodeStructureChecker$1(e, r) } } function getStructureFromConfig$1(e) { const t = {}; if (e.node) for (const n in e.node) if (hasOwnProperty$9.call(e.node, n)) { const r = e.node[n]; if (!r.structure) throw new Error("Missed `structure` field in `" + n + "` node type definition"); t[n] = processStructure$1(n, r) } return t } function dumpMapSyntax$1(e, t, n) { const r = {}; for (const a in e) e[a].syntax && (r[a] = n ? e[a].syntax : generate$1u(e[a].syntax, { compact: t })); return r } function dumpAtruleMapSyntax$1(e, t, n) { const r = {}; for (const [a, o] of Object.entries(e)) r[a] = { prelude: o.prelude && (n ? o.prelude.syntax : generate$1u(o.prelude.syntax, { compact: t })), descriptors: o.descriptors && dumpMapSyntax$1(o.descriptors, t, n) }; return r } function valueHasVar$1(e) { for (let t = 0; t < e.length; t++)if ("var(" === e[t].value.toLowerCase()) return !0; return !1 } function syntaxHasTopLevelCommaMultiplier(e) { const t = e.terms[0]; return !1 === e.explicit && 1 === e.terms.length && "Multiplier" === t.type && !0 === t.comma } function buildMatchResult$1(e, t, n) { return { matched: e, iterations: n, error: t, ...trace$1 } } function matchSyntax$1(e, t, n, r) { const a = prepareTokens$1(n, e.syntax); let o; return valueHasVar$1(a) ? buildMatchResult$1(null, new Error("Matching for a tree with var() is not supported")) : (r && (o = matchAsTree$1(a, e.cssWideKeywordsSyntax, e)), r && o.match || (o = matchAsTree$1(a, t.match, e), o.match) ? buildMatchResult$1(o.match, null, o.iterations) : buildMatchResult$1(null, new SyntaxMatchError$1(o.reason, t.syntax, n, o), o.iterations)) } let Lexer$1 = class { constructor(e, t, n) { if (this.cssWideKeywords = cssWideKeywords$1, this.syntax = t, this.generic = !1, this.units = { ...units }, this.atrules = Object.create(null), this.properties = Object.create(null), this.types = Object.create(null), this.structure = n || getStructureFromConfig$1(e), e) { if (e.cssWideKeywords && (this.cssWideKeywords = e.cssWideKeywords), e.units) for (const t of Object.keys(units)) Array.isArray(e.units[t]) && (this.units[t] = e.units[t]); if (e.types) for (const [t, n] of Object.entries(e.types)) this.addType_(t, n); if (e.generic) { this.generic = !0; for (const [e, t] of Object.entries(createGenericTypes(this.units))) this.addType_(e, t) } if (e.atrules) for (const [t, n] of Object.entries(e.atrules)) this.addAtrule_(t, n); if (e.properties) for (const [t, n] of Object.entries(e.properties)) this.addProperty_(t, n) } this.cssWideKeywordsSyntax = buildMatchGraph$1(this.cssWideKeywords.join(" |  ")) } checkStructure(e) { function t(e, t) { r.push({ node: e, message: t }) } const n = this.structure, r = []; return this.syntax.walk(e, (function (e) { n.hasOwnProperty(e.type) ? n[e.type].check(e, t) : t(e, "Unknown node type `" + e.type + "`") })), !!r.length && r } createDescriptor(e, t, n, r = null) { const a = { type: t, name: n }, o = { type: t, name: n, parent: r, serializable: "string" == typeof e || e && "string" == typeof e.type, syntax: null, match: null, matchRef: null }; return "function" == typeof e ? o.match = buildMatchGraph$1(e, a) : ("string" == typeof e ? Object.defineProperty(o, "syntax", { get: () => (Object.defineProperty(o, "syntax", { value: parse$1u(e) }), o.syntax) }) : o.syntax = e, Object.defineProperty(o, "match", { get: () => (Object.defineProperty(o, "match", { value: buildMatchGraph$1(o.syntax, a) }), o.match) }), "Property" === t && Object.defineProperty(o, "matchRef", { get() { const e = o.syntax, t = syntaxHasTopLevelCommaMultiplier(e) ? buildMatchGraph$1({ ...e, terms: [e.terms[0].term] }, a) : null; return Object.defineProperty(o, "matchRef", { value: t }), t } })), o } addAtrule_(e, t) { t && (this.atrules[e] = { type: "Atrule", name: e, prelude: t.prelude ? this.createDescriptor(t.prelude, "AtrulePrelude", e) : null, descriptors: t.descriptors ? Object.keys(t.descriptors).reduce(((n, r) => (n[r] = this.createDescriptor(t.descriptors[r], "AtruleDescriptor", r, e), n)), Object.create(null)) : null }) } addProperty_(e, t) { t && (this.properties[e] = this.createDescriptor(t, "Property", e)) } addType_(e, t) { t && (this.types[e] = this.createDescriptor(t, "Type", e)) } checkAtruleName(e) { if (!this.getAtrule(e)) return new SyntaxReferenceError$1("Unknown at-rule", "@" + e) } checkAtrulePrelude(e, t) { const n = this.checkAtruleName(e); if (n) return n; const r = this.getAtrule(e); return !r.prelude && t ? new SyntaxError("At-rule `@" + e + "` should not contain a prelude") : !r.prelude || t || matchSyntax$1(this, r.prelude, "", !1).matched ? void 0 : new SyntaxError("At-rule `@" + e + "` should contain a prelude") } checkAtruleDescriptorName(e, t) { const n = this.checkAtruleName(e); if (n) return n; const r = this.getAtrule(e), a = keyword$1(t); return r.descriptors ? r.descriptors[a.name] || r.descriptors[a.basename] ? void 0 : new SyntaxReferenceError$1("Unknown at-rule descriptor", t) : new SyntaxError("At-rule `@" + e + "` has no known descriptors") } checkPropertyName(e) { if (!this.getProperty(e)) return new SyntaxReferenceError$1("Unknown property", e) } matchAtrulePrelude(e, t) { const n = this.checkAtrulePrelude(e, t); if (n) return buildMatchResult$1(null, n); const r = this.getAtrule(e); return r.prelude ? matchSyntax$1(this, r.prelude, t || "", !1) : buildMatchResult$1(null, null) } matchAtruleDescriptor(e, t, n) { const r = this.checkAtruleDescriptorName(e, t); if (r) return buildMatchResult$1(null, r); const a = this.getAtrule(e), o = keyword$1(t); return matchSyntax$1(this, a.descriptors[o.name] || a.descriptors[o.basename], n, !1) } matchDeclaration(e) { return "Declaration" !== e.type ? buildMatchResult$1(null, new Error("Not a Declaration node")) : this.matchProperty(e.property, e.value) } matchProperty(e, t) { if (property$1(e).custom) return buildMatchResult$1(null, new Error("Lexer matching doesn't applicable for custom properties")); const n = this.checkPropertyName(e); return n ? buildMatchResult$1(null, n) : matchSyntax$1(this, this.getProperty(e), t, !0) } matchType(e, t) { const n = this.getType(e); return n ? matchSyntax$1(this, n, t, !1) : buildMatchResult$1(null, new SyntaxReferenceError$1("Unknown type", e)) } match(e, t) { return "string" == typeof e || e && e.type ? ("string" != typeof e && e.match || (e = this.createDescriptor(e, "Type", "anonymous")), matchSyntax$1(this, e, t, !1)) : buildMatchResult$1(null, new SyntaxReferenceError$1("Bad syntax")) } findValueFragments(e, t, n, r) { return matchFragments$1(this, t, this.matchProperty(e, t), n, r) } findDeclarationValueFragments(e, t, n) { return matchFragments$1(this, e.value, this.matchDeclaration(e), t, n) } findAllFragments(e, t, n) { const r = []; return this.syntax.walk(e, { visit: "Declaration", enter: e => { r.push.apply(r, this.findDeclarationValueFragments(e, t, n)) } }), r } getAtrule(e, t = !0) { const n = keyword$1(e); return (n.vendor && t ? this.atrules[n.name] || this.atrules[n.basename] : this.atrules[n.name]) || null } getAtrulePrelude(e, t = !0) { const n = this.getAtrule(e, t); return n && n.prelude || null } getAtruleDescriptor(e, t) { return this.atrules.hasOwnProperty(e) && this.atrules.declarators && this.atrules[e].declarators[t] || null } getProperty(e, t = !0) { const n = property$1(e); return (n.vendor && t ? this.properties[n.name] || this.properties[n.basename] : this.properties[n.name]) || null } getType(e) { return hasOwnProperty.call(this.types, e) ? this.types[e] : null } validate() { function e(e, t) { return t ? `<${e}>` : `<'${e}'>` } function t(o, i, s, l) { if (s.has(i)) return s.get(i); s.set(i, !1), null !== l.syntax && walk$4(l.syntax, (function (l) { if ("Type" !== l.type && "Property" !== l.type) return; const c = "Type" === l.type ? o.types : o.properties, u = "Type" === l.type ? r : a; hasOwnProperty.call(c, l.name) ? t(o, l.name, u, c[l.name]) && (n.push(`${e(i, s === r)} used broken syntax definition ${e(l.name, "Type" === l.type)}`), s.set(i, !0)) : (n.push(`${e(i, s === r)} used missed syntax definition ${e(l.name, "Type" === l.type)}`), s.set(i, !0)) }), this) } const n = []; let r = new Map, a = new Map; for (const e in this.types) t(this, e, r, this.types[e]); for (const e in this.properties) t(this, e, a, this.properties[e]); const o = [...r.keys()].filter((e => r.get(e))), i = [...a.keys()].filter((e => a.get(e))); return o.length || i.length ? { errors: n, types: o, properties: i } : null } dump(e, t) { return { generic: this.generic, cssWideKeywords: this.cssWideKeywords, units: this.units, types: dumpMapSyntax$1(this.types, !t, e), properties: dumpMapSyntax$1(this.properties, !t, e), atrules: dumpAtruleMapSyntax$1(this.atrules, !t, e) } } toString() { return JSON.stringify(this.dump()) } }; function appendOrSet(e, t) { return "string" == typeof t && /^\s*\|/.test(t) ? "string" == typeof e ? e + t : t.replace(/^\s*\|\s*/, "") : t || null } function sliceProps(e, t) { const n = Object.create(null); for (const [r, a] of Object.entries(e)) if (a) { n[r] = {}; for (const e of Object.keys(a)) t.includes(e) && (n[r][e] = a[e]) } return n } function mix$2(e, t) { const n = { ...e }; for (const [r, a] of Object.entries(t)) switch (r) { case "generic": n[r] = Boolean(a); break; case "cssWideKeywords": n[r] = e[r] ? [...e[r], ...a] : a || []; break; case "units": n[r] = { ...e[r] }; for (const [e, t] of Object.entries(a)) n[r][e] = Array.isArray(t) ? t : []; break; case "atrules": n[r] = { ...e[r] }; for (const [e, t] of Object.entries(a)) { const a = n[r][e] || {}, o = n[r][e] = { prelude: a.prelude || null, descriptors: { ...a.descriptors } }; if (t) { o.prelude = t.prelude ? appendOrSet(o.prelude, t.prelude) : o.prelude || null; for (const [e, n] of Object.entries(t.descriptors || {})) o.descriptors[e] = n ? appendOrSet(o.descriptors[e], n) : null; Object.keys(o.descriptors).length || (o.descriptors = null) } } break; case "types": case "properties": n[r] = { ...e[r] }; for (const [e, t] of Object.entries(a)) n[r][e] = appendOrSet(n[r][e], t); break; case "scope": case "features": n[r] = { ...e[r] }; for (const [e, t] of Object.entries(a)) n[r][e] = { ...n[r][e], ...t }; break; case "parseContext": n[r] = { ...e[r], ...a }; break; case "atrule": case "pseudo": n[r] = { ...e[r], ...sliceProps(a, ["parse"]) }; break; case "node": n[r] = { ...e[r], ...sliceProps(a, ["name", "structure", "parse", "generate", "walkContext"]) } }return n } function createSyntax$2(e) { const t = createParser$1(e), n = createWalker$1(e), r = createGenerator$1(e), { fromPlainObject: a, toPlainObject: o } = createConvertor$1(n), i = { lexer: null, createLexer: e => new Lexer$1(e, i, i.lexer.structure), tokenize: tokenize$4, parse: t, generate: r, walk: n, find: n.find, findLast: n.findLast, findAll: n.findAll, fromPlainObject: a, toPlainObject: o, fork(t) { const n = mix$2({}, e); return createSyntax$2("function" == typeof t ? t(n) : mix$2(n, t)) } }; return i.lexer = new Lexer$1({ generic: e.generic, cssWideKeywords: e.cssWideKeywords, units: e.units, types: e.types, atrules: e.atrules, properties: e.properties, node: e.node }, i), i } var createSyntax$3 = e => createSyntax$2(mix$2({}, e)), definitions$1 = { generic: !0, cssWideKeywords: ["initial", "inherit", "unset", "revert", "revert-layer"], units: { angle: ["deg", "grad", "rad", "turn"], decibel: ["db"], flex: ["fr"], frequency: ["hz", "khz"], length: ["cm", "mm", "q", "in", "pt", "pc", "px", "em", "rem", "ex", "rex", "cap", "rcap", "ch", "rch", "ic", "ric", "lh", "rlh", "vw", "svw", "lvw", "dvw", "vh", "svh", "lvh", "dvh", "vi", "svi", "lvi", "dvi", "vb", "svb", "lvb", "dvb", "vmin", "svmin", "lvmin", "dvmin", "vmax", "svmax", "lvmax", "dvmax", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"], resolution: ["dpi", "dpcm", "dppx", "x"], semitones: ["st"], time: ["s", "ms"] }, types: { "abs()": "abs( <calc-sum> )", "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large", "acos()": "acos( <calc-sum> )", "alpha-value": "<number>|<percentage>", "angle-percentage": "<angle>|<percentage>", "angular-color-hint": "<angle-percentage>", "angular-color-stop": "<color>&&<color-stop-angle>?", "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>", "animateable-feature": "scroll-position|contents|<custom-ident>", "asin()": "asin( <calc-sum> )", "atan()": "atan( <calc-sum> )", "atan2()": "atan2( <calc-sum> , <calc-sum> )", attachment: "scroll|fixed|local", "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )", "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='", "attr-modifier": "i|s", "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'", "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )", "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?", axis: "block|inline|vertical|horizontal", "baseline-position": "[first|last]? baseline", "basic-shape": "<inset()>|<xywh()>|<rect()>|<circle()>|<ellipse()>|<polygon()>|<path()>", "bg-image": "none|<image>", "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>", "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]", "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain", "blur()": "blur( <length> )", "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity", box: "border-box|padding-box|content-box", "brightness()": "brightness( <number-percentage> )", "calc()": "calc( <calc-sum> )", "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*", "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*", "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )", "calc-constant": "e|pi|infinity|-infinity|NaN", "cf-final-image": "<image>|<color>", "cf-mixing-image": "<percentage>?&&<image>", "circle()": "circle( [<shape-radius>]? [at <position>]? )", "clamp()": "clamp( <calc-sum>#{3} )", "class-selector": "'.' <ident-token>", "clip-source": "<url>", color: "<color-base>|currentColor|<system-color>|<device-cmyk()>|<light-dark()>|<-non-standard-color>", "color-stop": "<color-stop-length>|<color-stop-angle>", "color-stop-angle": "<angle-percentage>{1,2}", "color-stop-length": "<length-percentage>{1,2}", "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>", "color-interpolation-method": "in [<rectangular-color-space>|<polar-color-space> <hue-interpolation-method>?|<custom-color-space>]", combinator: "'>'|'+'|'~'|['|' '|']", "common-lig-values": "[common-ligatures|no-common-ligatures]", "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button", "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor", "compositing-operator": "add|subtract|intersect|exclude", "compound-selector": "[<type-selector>? <subclass-selector>*]!", "compound-selector-list": "<compound-selector>#", "complex-selector": "<complex-selector-unit> [<combinator>? <complex-selector-unit>]*", "complex-selector-list": "<complex-selector>#", "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )", "contextual-alt-values": "[contextual|no-contextual]", "content-distribution": "space-between|space-around|space-evenly|stretch", "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+", "content-position": "center|start|end|flex-start|flex-end", "content-replacement": "<image>", "contrast()": "contrast( [<number-percentage>] )", "cos()": "cos( <calc-sum> )", counter: "<counter()>|<counters()>", "counter()": "counter( <counter-name> , <counter-style>? )", "counter-name": "<custom-ident>", "counter-style": "<counter-style-name>|symbols( )", "counter-style-name": "<custom-ident>", "counters()": "counters( <counter-name> , <string> , <counter-style>? )", "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )", "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )", "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText", "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]", "display-box": "contents|none", "display-inside": "flow|flow-root|table|flex|grid|ruby", "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container", "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid", "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item", "display-outside": "block|inline|run-in", "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )", "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]", "east-asian-width-values": "[full-width|proportional-width]", "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )", "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )", "ending-shape": "circle|ellipse", "env()": "env( <custom-ident> , <declaration-value>? )", "exp()": "exp( <calc-sum> )", "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?", "family-name": "<string>|<custom-ident>+", "feature-tag-value": "<string> [<integer>|on|off]?", "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation", "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'", "feature-value-block-list": "<feature-value-block>+", "feature-value-declaration": "<custom-ident> : <integer>+ ;", "feature-value-declaration-list": "<feature-value-declaration>", "feature-value-name": "<custom-ident>", "fill-rule": "nonzero|evenodd", "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>", "filter-function-list": "[<filter-function>|<url>]+", "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>", "fixed-breadth": "<length-percentage>", "fixed-repeat": "repeat( [<integer [1,]>] , [<line-names>? <fixed-size>]+ <line-names>? )", "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )", "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>", "font-variant-css21": "[normal|small-caps]", "font-weight-absolute": "normal|bold|<number [1,1000]>", "frequency-percentage": "<frequency>|<percentage>", "general-enclosed": "[<function-token> <any-value>? )]|[( <any-value>? )]", "generic-family": "<generic-script-specific>|<generic-complete>|<generic-incomplete>|<-non-standard-generic-family>", "generic-name": "serif|sans-serif|cursive|fantasy|monospace", "geometry-box": "<shape-box>|fill-box|stroke-box|view-box", gradient: "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>", "grayscale()": "grayscale( <number-percentage> )", "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]", "historical-lig-values": "[historical-ligatures|no-historical-ligatures]", "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )", "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )", hue: "<number>|<angle>", "hue-rotate()": "hue-rotate( <angle> )", "hue-interpolation-method": "[shorter|longer|increasing|decreasing] hue", "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )", "hypot()": "hypot( <calc-sum># )", image: "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>", "image()": "image( <image-tags>? [<image-src>? , <color>?]! )", "image-set()": "image-set( <image-set-option># )", "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]", "image-src": "<url>|<string>", "image-tags": "ltr|rtl", "inflexible-breadth": "<length-percentage>|min-content|max-content|auto", "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )", "invert()": "invert( <number-percentage> )", "keyframes-name": "<custom-ident>|<string>", "keyframe-block": "<keyframe-selector># { <declaration-list> }", "keyframe-block-list": "<keyframe-block>+", "keyframe-selector": "from|to|<percentage>|<timeline-range-name> <percentage>", "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )", "layer()": "layer( <layer-name> )", "layer-name": "<ident> ['.' <ident>]*", "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )", "leader()": "leader( <leader-type> )", "leader-type": "dotted|solid|space|<string>", "length-percentage": "<length>|<percentage>", "light-dark()": "light-dark( <color> , <color> )", "line-names": "'[' <custom-ident>* ']'", "line-name-list": "[<line-names>|<name-repeat>]+", "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset", "line-width": "<length>|thin|medium|thick", "linear-color-hint": "<length-percentage>", "linear-color-stop": "<color> <color-stop-length>?", "linear-gradient()": "linear-gradient( [[<angle>|to <side-or-corner>]||<color-interpolation-method>]? , <color-stop-list> )", "log()": "log( <calc-sum> , <calc-sum>? )", "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>", "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?", "mask-reference": "none|<image>|<mask-source>", "mask-source": "<url>", "masking-mode": "alpha|luminance|match-source", "matrix()": "matrix( <number>#{6} )", "matrix3d()": "matrix3d( <number>#{16} )", "max()": "max( <calc-sum># )", "media-and": "<media-in-parens> [and <media-in-parens>]+", "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>", "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>", "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )", "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>", "media-not": "not <media-in-parens>", "media-or": "<media-in-parens> [or <media-in-parens>]+", "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?", "media-query-list": "<media-query>#", "media-type": "<ident>", "mf-boolean": "<mf-name>", "mf-name": "<ident>", "mf-plain": "<mf-name> : <mf-value>", "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>", "mf-value": "<number>|<dimension>|<ident>|<ratio>", "min()": "min( <calc-sum># )", "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )", "mod()": "mod( <calc-sum> , <calc-sum> )", "name-repeat": "repeat( [<integer [1,]>|auto-fill] , <line-names>+ )", "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen", "namespace-prefix": "<ident>", "ns-prefix": "[<ident-token>|'*']? '|'", "number-percentage": "<number>|<percentage>", "numeric-figure-values": "[lining-nums|oldstyle-nums]", "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]", "numeric-spacing-values": "[proportional-nums|tabular-nums]", nth: "<an-plus-b>|even|odd", "opacity()": "opacity( [<number-percentage>] )", "overflow-position": "unsafe|safe", "outline-radius": "<length>|<percentage>", "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>", "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'", "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom", "page-selector-list": "[<page-selector>#]?", "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*", "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger", "path()": "path( [<fill-rule> ,]? <string> )", "paint()": "paint( <ident> , <declaration-value>? )", "perspective()": "perspective( [<length [0,]>|none] )", "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )", "polar-color-space": "hsl|hwb|lch|oklch", position: "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]", "pow()": "pow( <calc-sum> , <calc-sum> )", "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'", "pseudo-element-selector": "':' <pseudo-class-selector>|<legacy-pseudo-element-selector>", "pseudo-page": ": [left|right|first|blank]", quote: "open-quote|close-quote|no-open-quote|no-close-quote", "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )", ratio: "<number [0,]> [/ <number [0,]>]?", "ray()": "ray( <angle>&&<ray-size>?&&contain?&&[at <position>]? )", "ray-size": "closest-side|closest-corner|farthest-side|farthest-corner|sides", "rectangular-color-space": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020|lab|oklab|xyz|xyz-d50|xyz-d65", "relative-selector": "<combinator>? <complex-selector>", "relative-selector-list": "<relative-selector>#", "relative-size": "larger|smaller", "rem()": "rem( <calc-sum> , <calc-sum> )", "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}", "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )", "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )", "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )", "reversed-counter-name": "reversed( <counter-name> )", "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )", "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )", "rotate()": "rotate( [<angle>|<zero>] )", "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )", "rotateX()": "rotateX( [<angle>|<zero>] )", "rotateY()": "rotateY( [<angle>|<zero>] )", "rotateZ()": "rotateZ( [<angle>|<zero>] )", "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )", "rounding-strategy": "nearest|up|down|to-zero", "saturate()": "saturate( <number-percentage> )", "scale()": "scale( [<number>|<percentage>]#{1,2} )", "scale3d()": "scale3d( [<number>|<percentage>]#{3} )", "scaleX()": "scaleX( [<number>|<percentage>] )", "scaleY()": "scaleY( [<number>|<percentage>] )", "scaleZ()": "scaleZ( [<number>|<percentage>] )", "scroll()": "scroll( [<axis>||<scroller>]? )", scroller: "root|nearest", "self-position": "center|start|end|self-start|self-end|flex-start|flex-end", "shape-radius": "<length-percentage>|closest-side|farthest-side", "sign()": "sign( <calc-sum> )", "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )", "skewX()": "skewX( [<angle>|<zero>] )", "skewY()": "skewY( [<angle>|<zero>] )", "sepia()": "sepia( <number-percentage> )", shadow: "inset?&&<length>{2,4}&&<color>?", "shadow-t": "[<length>{2,3}&&<color>?]", shape: "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )", "shape-box": "<box>|margin-box", "side-or-corner": "[left|right]||[top|bottom]", "sin()": "sin( <calc-sum> )", "single-animation": "<'animation-duration'>||<easing-function>||<'animation-delay'>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]||<single-animation-timeline>", "single-animation-direction": "normal|reverse|alternate|alternate-reverse", "single-animation-fill-mode": "none|forwards|backwards|both", "single-animation-iteration-count": "infinite|<number>", "single-animation-play-state": "running|paused", "single-animation-timeline": "auto|none|<dashed-ident>|<scroll()>|<view()>", "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>||<transition-behavior-value>", "single-transition-property": "all|<custom-ident>", size: "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}", "sqrt()": "sqrt( <calc-sum> )", "step-position": "jump-start|jump-end|jump-none|jump-both|start|end", "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )", "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>", "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*", "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>", "supports-feature": "<supports-decl>|<supports-selector-fn>", "supports-decl": "( <declaration> )", "supports-selector-fn": "selector( <complex-selector> )", symbol: "<string>|<image>|<custom-ident>", "tan()": "tan( <calc-sum> )", target: "<target-counter()>|<target-counters()>|<target-text()>", "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )", "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )", "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )", "time-percentage": "<time>|<percentage>", "timeline-range-name": "cover|contain|entry|exit|entry-crossing|exit-crossing", "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>", "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto", "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?", "track-repeat": "repeat( [<integer [1,]>] , [<line-names>? <track-size>]+ <line-names>? )", "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )", "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>", "transform-list": "<transform-function>+", "transition-behavior-value": "normal|allow-discrete", "translate()": "translate( <length-percentage> , <length-percentage>? )", "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )", "translateX()": "translateX( <length-percentage> )", "translateY()": "translateY( <length-percentage> )", "translateZ()": "translateZ( <length> )", "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%", "type-selector": "<wq-name>|<ns-prefix>? '*'", "var()": "var( <custom-property-name> , <declaration-value>? )", "view()": "view( [<axis>||<'view-timeline-inset'>]? )", "viewport-length": "auto|<length-percentage>", "visual-box": "content-box|padding-box|border-box", "wq-name": "<ns-prefix>? <ident-token>", "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>", "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )", "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )", "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>", "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )", "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )", "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>", "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover", "-legacy-radial-gradient-shape": "circle|ellipse", "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body", "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text", "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast", "-non-standard-overflow": "overlay|-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable", "-non-standard-size": "intrinsic|min-intrinsic|-webkit-fill-available|-webkit-fit-content|-webkit-min-content|-webkit-max-content|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content", "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )", "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )", "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]", "-webkit-gradient-radius": "<length>|<percentage>", "-webkit-gradient-type": "linear|radial", "-webkit-mask-box-repeat": "repeat|stretch|round", "-ms-filter-function-list": "<-ms-filter-function>+", "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>", "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]", "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )", "absolute-color-base": "<hex-color>|<absolute-color-function>|<named-color>|transparent", "absolute-color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>", age: "child|young|old", "anchor-name": "<dashed-ident>", "attr-name": "<wq-name>", "attr-fallback": "<any-value>", "bg-clip": "<box>|border|text", bottom: "<length>|auto", "container-name": "<custom-ident>", "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]", "coord-box": "content-box|padding-box|border-box|fill-box|stroke-box|view-box", "generic-voice": "[<age>? <gender> <integer>?]", gender: "male|female|neutral", "generic-script-specific": "generic( kai )|generic( fangsong )|generic( nastaliq )", "generic-complete": "serif|sans-serif|system-ui|cursive|fantasy|math|monospace", "generic-incomplete": "ui-serif|ui-sans-serif|ui-monospace|ui-rounded", "-non-standard-generic-family": "-apple-system|BlinkMacSystemFont", left: "<length>|auto", "color-base": "<hex-color>|<color-function>|<named-color>|<color-mix()>|transparent", "color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>", "system-color": "AccentColor|AccentColorText|ActiveText|ButtonBorder|ButtonFace|ButtonText|Canvas|CanvasText|Field|FieldText|GrayText|Highlight|HighlightText|LinkText|Mark|MarkText|SelectedItem|SelectedItemText|VisitedText", "device-cmyk()": "<legacy-device-cmyk-syntax>|<modern-device-cmyk-syntax>", "legacy-device-cmyk-syntax": "device-cmyk( <number>#{4} )", "modern-device-cmyk-syntax": "device-cmyk( <cmyk-component>{4} [/ [<alpha-value>|none]]? )", "cmyk-component": "<number>|<percentage>|none", "color-mix()": "color-mix( <color-interpolation-method> , [<color>&&<percentage [0,100]>?]#{2} )", "color-space": "<rectangular-color-space>|<polar-color-space>|<custom-color-space>", "custom-color-space": "<dashed-ident>", paint: "none|<color>|<url> [none|<color>]?|context-fill|context-stroke", "palette-identifier": "<dashed-ident>", right: "<length>|auto", "scope-start": "<forgiving-selector-list>", "scope-end": "<forgiving-selector-list>", "forgiving-selector-list": "<complex-real-selector-list>", "forgiving-relative-selector-list": "<relative-real-selector-list>", "selector-list": "<complex-selector-list>", "complex-real-selector-list": "<complex-real-selector>#", "simple-selector-list": "<simple-selector>#", "relative-real-selector-list": "<relative-real-selector>#", "complex-selector-unit": "[<compound-selector>? <pseudo-compound-selector>*]!", "complex-real-selector": "<compound-selector> [<combinator>? <compound-selector>]*", "relative-real-selector": "<combinator>? <complex-real-selector>", "pseudo-compound-selector": "<pseudo-element-selector> <pseudo-class-selector>*", "simple-selector": "<type-selector>|<subclass-selector>", "legacy-pseudo-element-selector": "':' [before|after|first-line|first-letter]", "single-animation-composition": "replace|add|accumulate", "svg-length": "<percentage>|<length>|<number>", "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb", top: "<length>|auto", x: "<number>", y: "<number>", declaration: "<ident-token> : <declaration-value>? ['!' important]?", "declaration-list": "[<declaration>? ';']* <declaration>?", url: "url( <string> <url-modifier>* )|<url-token>", "url-modifier": "<ident>|<function-token> <any-value> )", "number-zero-one": "<number [0,1]>", "number-one-or-greater": "<number [1,]>", "color()": "color( <colorspace-params> [/ [<alpha-value>|none]]? )", "colorspace-params": "[<predefined-rgb-params>|<xyz-params>]", "predefined-rgb-params": "<predefined-rgb> [<number>|<percentage>|none]{3}", "predefined-rgb": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020", "xyz-params": "<xyz-space> [<number>|<percentage>|none]{3}", "xyz-space": "xyz|xyz-d50|xyz-d65", "oklab()": "oklab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )", "oklch()": "oklch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )", "offset-path": "<ray()>|<url>|<basic-shape>", "rect()": "rect( [<length-percentage>|auto]{4} [round <'border-radius'>]? )", "xywh()": "xywh( <length-percentage>{2} <length-percentage [0,]>{2} [round <'border-radius'>]? )", "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>", "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>", "style-feature": "<declaration>", "style-query": "<style-condition>|<style-feature>", "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]", "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>", "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box", "inset-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]", "position-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|center|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|center|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]", "anchor()": "anchor( <anchor-element>?&&<anchor-side> , <length-percentage>? )", "anchor-side": "inside|outside|top|left|right|bottom|start|end|self-start|self-end|<percentage>|center", "anchor-size()": "anchor-size( [<anchor-element>||<anchor-size>]? , <length-percentage>? )", "anchor-size": "width|height|block|inline|self-block|self-inline", "anchor-element": "<dashed-ident>", "try-size": "most-width|most-height|most-block-size|most-inline-size", "try-tactic": "flip-block||flip-inline||flip-start", "font-variant-css2": "normal|small-caps", "font-width-css3": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", "system-family-name": "caption|icon|menu|message-box|small-caption|status-bar" }, properties: { "--*": "<declaration-value>", "-ms-accelerator": "false|true", "-ms-block-progression": "tb|rl|bt|lr", "-ms-content-zoom-chaining": "none|chained", "-ms-content-zooming": "none|zoom", "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>", "-ms-content-zoom-limit-max": "<percentage>", "-ms-content-zoom-limit-min": "<percentage>", "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>", "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )", "-ms-content-zoom-snap-type": "none|proximity|mandatory", "-ms-filter": "<string>", "-ms-flow-from": "[none|<custom-ident>]#", "-ms-flow-into": "[none|<custom-ident>]#", "-ms-grid-columns": "none|<track-list>|<auto-track-list>", "-ms-grid-rows": "none|<track-list>|<auto-track-list>", "-ms-high-contrast-adjust": "auto|none", "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}", "-ms-hyphenate-limit-lines": "no-limit|<integer>", "-ms-hyphenate-limit-zone": "<percentage>|<length>", "-ms-ime-align": "auto|after", "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar", "-ms-scrollbar-3dlight-color": "<color>", "-ms-scrollbar-arrow-color": "<color>", "-ms-scrollbar-base-color": "<color>", "-ms-scrollbar-darkshadow-color": "<color>", "-ms-scrollbar-face-color": "<color>", "-ms-scrollbar-highlight-color": "<color>", "-ms-scrollbar-shadow-color": "<color>", "-ms-scrollbar-track-color": "<color>", "-ms-scroll-chaining": "chained|none", "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>", "-ms-scroll-limit-x-max": "auto|<length>", "-ms-scroll-limit-x-min": "<length>", "-ms-scroll-limit-y-max": "auto|<length>", "-ms-scroll-limit-y-min": "<length>", "-ms-scroll-rails": "none|railed", "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )", "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )", "-ms-scroll-snap-type": "none|proximity|mandatory", "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>", "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>", "-ms-scroll-translation": "none|vertical-to-horizontal", "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space", "-ms-touch-select": "grippers|none", "-ms-user-select": "none|element|text", "-ms-wrap-flow": "auto|both|start|end|maximum|clear", "-ms-wrap-margin": "<length>", "-ms-wrap-through": "wrap|none", "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized", "-moz-binding": "<url>|none", "-moz-border-bottom-colors": "<color>+|none", "-moz-border-left-colors": "<color>+|none", "-moz-border-right-colors": "<color>+|none", "-moz-border-top-colors": "<color>+|none", "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#", "-moz-float-edge": "border-box|content-box|margin-box|padding-box", "-moz-force-broken-image-icon": "0|1", "-moz-image-region": "<shape>|auto", "-moz-orient": "inline|block|horizontal|vertical", "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?", "-moz-outline-radius-bottomleft": "<outline-radius>", "-moz-outline-radius-bottomright": "<outline-radius>", "-moz-outline-radius-topleft": "<outline-radius>", "-moz-outline-radius-topright": "<outline-radius>", "-moz-stack-sizing": "ignore|stretch-to-fit", "-moz-text-blink": "none|blink", "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none", "-moz-user-input": "auto|none|enabled|disabled", "-moz-user-modify": "read-only|read-write|write-only", "-moz-window-dragging": "drag|no-drag", "-moz-window-shadow": "default|menu|tooltip|sheet|none", "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button", "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>", "-webkit-border-before-color": "<color>", "-webkit-border-before-style": "<'border-style'>", "-webkit-border-before-width": "<'border-width'>", "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?", "-webkit-line-clamp": "none|<integer>", "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#", "-webkit-mask-attachment": "<attachment>#", "-webkit-mask-clip": "[<box>|border|padding|content|text]#", "-webkit-mask-composite": "<composite-style>#", "-webkit-mask-image": "<mask-reference>#", "-webkit-mask-origin": "[<box>|border|padding|content]#", "-webkit-mask-position": "<position>#", "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#", "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#", "-webkit-mask-repeat": "<repeat-style>#", "-webkit-mask-repeat-x": "repeat|no-repeat|space|round", "-webkit-mask-repeat-y": "repeat|no-repeat|space|round", "-webkit-mask-size": "<bg-size>#", "-webkit-overflow-scrolling": "auto|touch", "-webkit-tap-highlight-color": "<color>", "-webkit-text-fill-color": "<color>", "-webkit-text-stroke": "<length>||<color>", "-webkit-text-stroke-color": "<color>", "-webkit-text-stroke-width": "<length>", "-webkit-touch-callout": "default|none", "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only", "accent-color": "auto|<color>", "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>", "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]", "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>", "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#", all: "initial|inherit|unset|revert|revert-layer", "anchor-name": "none|<dashed-ident>#", "anchor-scope": "none|all|<dashed-ident>#", animation: "<single-animation>#", "animation-composition": "<single-animation-composition>#", "animation-delay": "<time>#", "animation-direction": "<single-animation-direction>#", "animation-duration": "<time>#", "animation-fill-mode": "<single-animation-fill-mode>#", "animation-iteration-count": "<single-animation-iteration-count>#", "animation-name": "[none|<keyframes-name>]#", "animation-play-state": "<single-animation-play-state>#", "animation-range": "[<'animation-range-start'> <'animation-range-end'>?]#", "animation-range-end": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#", "animation-range-start": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#", "animation-timing-function": "<easing-function>#", "animation-timeline": "<single-animation-timeline>#", appearance: "none|auto|textfield|menulist-button|<compat-auto>", "aspect-ratio": "auto||<ratio>", azimuth: "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards", "backdrop-filter": "none|<filter-function-list>", "backface-visibility": "visible|hidden", background: "[<bg-layer> ,]* <final-bg-layer>", "background-attachment": "<attachment>#", "background-blend-mode": "<blend-mode>#", "background-clip": "<bg-clip>#", "background-color": "<color>", "background-image": "<bg-image>#", "background-origin": "<box>#", "background-position": "<bg-position>#", "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#", "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#", "background-repeat": "<repeat-style>#", "background-size": "<bg-size>#", "block-size": "<'width'>", border: "<line-width>||<line-style>||<color>", "border-block": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-color": "<'border-top-color'>{1,2}", "border-block-style": "<'border-top-style'>", "border-block-width": "<'border-top-width'>", "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-end-color": "<'border-top-color'>", "border-block-end-style": "<'border-top-style'>", "border-block-end-width": "<'border-top-width'>", "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-start-color": "<'border-top-color'>", "border-block-start-style": "<'border-top-style'>", "border-block-start-width": "<'border-top-width'>", "border-bottom": "<line-width>||<line-style>||<color>", "border-bottom-color": "<'border-top-color'>", "border-bottom-left-radius": "<length-percentage>{1,2}", "border-bottom-right-radius": "<length-percentage>{1,2}", "border-bottom-style": "<line-style>", "border-bottom-width": "<line-width>", "border-collapse": "collapse|separate", "border-color": "<color>{1,4}", "border-end-end-radius": "<length-percentage>{1,2}", "border-end-start-radius": "<length-percentage>{1,2}", "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>", "border-image-outset": "[<length>|<number>]{1,4}", "border-image-repeat": "[stretch|repeat|round|space]{1,2}", "border-image-slice": "<number-percentage>{1,4}&&fill?", "border-image-source": "none|<image>", "border-image-width": "[<length-percentage>|<number>|auto]{1,4}", "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-color": "<'border-top-color'>{1,2}", "border-inline-style": "<'border-top-style'>", "border-inline-width": "<'border-top-width'>", "border-inline-end-color": "<'border-top-color'>", "border-inline-end-style": "<'border-top-style'>", "border-inline-end-width": "<'border-top-width'>", "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-start-color": "<'border-top-color'>", "border-inline-start-style": "<'border-top-style'>", "border-inline-start-width": "<'border-top-width'>", "border-left": "<line-width>||<line-style>||<color>", "border-left-color": "<color>", "border-left-style": "<line-style>", "border-left-width": "<line-width>", "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?", "border-right": "<line-width>||<line-style>||<color>", "border-right-color": "<color>", "border-right-style": "<line-style>", "border-right-width": "<line-width>", "border-spacing": "<length> <length>?", "border-start-end-radius": "<length-percentage>{1,2}", "border-start-start-radius": "<length-percentage>{1,2}", "border-style": "<line-style>{1,4}", "border-top": "<line-width>||<line-style>||<color>", "border-top-color": "<color>", "border-top-left-radius": "<length-percentage>{1,2}", "border-top-right-radius": "<length-percentage>{1,2}", "border-top-style": "<line-style>", "border-top-width": "<line-width>", "border-width": "<line-width>{1,4}", bottom: "<length>|<percentage>|auto", "box-align": "start|center|end|baseline|stretch", "box-decoration-break": "slice|clone", "box-direction": "normal|reverse|inherit", "box-flex": "<number>", "box-flex-group": "<integer>", "box-lines": "single|multiple", "box-ordinal-group": "<integer>", "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit", "box-pack": "start|center|end|justify", "box-shadow": "none|<shadow>#", "box-sizing": "content-box|border-box", "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region", "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region", "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region", "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end", caret: "<'caret-color'>||<'caret-shape'>", "caret-color": "auto|<color>", "caret-shape": "auto|bar|block|underscore", clear: "none|left|right|both|inline-start|inline-end", clip: "<shape>|auto", "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none", "clip-rule": "nonzero|evenodd", color: "<color>", "color-interpolation-filters": "auto|sRGB|linearRGB", "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?", "column-count": "<integer>|auto", "column-fill": "auto|balance", "column-gap": "normal|<length-percentage>", "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>", "column-rule-color": "<color>", "column-rule-style": "<'border-style'>", "column-rule-width": "<'border-width'>", "column-span": "none|all", "column-width": "<length>|auto", columns: "<'column-width'>||<'column-count'>", contain: "none|strict|content|[[size||inline-size]||layout||style||paint]", "contain-intrinsic-size": "[auto? [none|<length>]]{1,2}", "contain-intrinsic-block-size": "auto? [none|<length>]", "contain-intrinsic-height": "auto? [none|<length>]", "contain-intrinsic-inline-size": "auto? [none|<length>]", "contain-intrinsic-width": "auto? [none|<length>]", container: "<'container-name'> [/ <'container-type'>]?", "container-name": "none|<custom-ident>+", "container-type": "normal||[size|inline-size]", content: "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?", "content-visibility": "visible|auto|hidden", "counter-increment": "[<counter-name> <integer>?]+|none", "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none", "counter-set": "[<counter-name> <integer>?]+|none", cursor: "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]", d: "none|path( <string> )", cx: "<length>|<percentage>", cy: "<length>|<percentage>", direction: "ltr|rtl", display: "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>", "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge", "empty-cells": "show|hide", "field-sizing": "content|fixed", fill: "<paint>", "fill-opacity": "<number-zero-one>", "fill-rule": "nonzero|evenodd", filter: "none|<filter-function-list>|<-ms-filter-function-list>", flex: "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]", "flex-basis": "content|<'width'>", "flex-direction": "row|row-reverse|column|column-reverse", "flex-flow": "<'flex-direction'>||<'flex-wrap'>", "flex-grow": "<number>", "flex-shrink": "<number>", "flex-wrap": "nowrap|wrap|wrap-reverse", float: "left|right|none|inline-start|inline-end", font: "[[<'font-style'>||<font-variant-css2>||<'font-weight'>||<font-width-css3>]? <'font-size'> [/ <'line-height'>]? <'font-family'>#]|<system-family-name>|<-non-standard-font>", "font-family": "[<family-name>|<generic-family>]#", "font-feature-settings": "normal|<feature-tag-value>#", "font-kerning": "auto|normal|none", "font-language-override": "normal|<string>", "font-optical-sizing": "auto|none", "font-palette": "normal|light|dark|<palette-identifier>", "font-variation-settings": "normal|[<string> <number>]#", "font-size": "<absolute-size>|<relative-size>|<length-percentage>", "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]", "font-smooth": "auto|never|always|<absolute-size>|<length>", "font-stretch": "<font-stretch-absolute>", "font-style": "normal|italic|oblique <angle>?", "font-synthesis": "none|[weight||style||small-caps||position]", "font-synthesis-position": "auto|none", "font-synthesis-small-caps": "auto|none", "font-synthesis-style": "auto|none", "font-synthesis-weight": "auto|none", "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]", "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]", "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps", "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]", "font-variant-emoji": "normal|text|emoji|unicode", "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]", "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]", "font-variant-position": "normal|sub|super", "font-weight": "<font-weight-absolute>|bolder|lighter", "forced-color-adjust": "auto|none", gap: "<'row-gap'> <'column-gap'>?", grid: "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>", "grid-area": "<grid-line> [/ <grid-line>]{0,3}", "grid-auto-columns": "<track-size>+", "grid-auto-flow": "[row|column]||dense", "grid-auto-rows": "<track-size>+", "grid-column": "<grid-line> [/ <grid-line>]?", "grid-column-end": "<grid-line>", "grid-column-gap": "<length-percentage>", "grid-column-start": "<grid-line>", "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?", "grid-row": "<grid-line> [/ <grid-line>]?", "grid-row-end": "<grid-line>", "grid-row-gap": "<length-percentage>", "grid-row-start": "<grid-line>", "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?", "grid-template-areas": "none|<string>+", "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?", "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?", "hanging-punctuation": "none|[first||[force-end|allow-end]||last]", height: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>", "hyphenate-character": "auto|<string>", "hyphenate-limit-chars": "[auto|<integer>]{1,3}", hyphens: "none|manual|auto", "image-orientation": "from-image|<angle>|[<angle>? flip]", "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>", "image-resolution": "[from-image||<resolution>]&&snap?", "ime-mode": "auto|normal|active|inactive|disabled", "initial-letter": "normal|[<number> <integer>?]", "initial-letter-align": "[auto|alphabetic|hanging|ideographic]", "inline-size": "<'width'>", "input-security": "auto|none", inset: "<'top'>{1,4}", "inset-block": "<'top'>{1,2}", "inset-block-end": "<'top'>", "inset-block-start": "<'top'>", "inset-inline": "<'top'>{1,2}", "inset-inline-end": "<'top'>", "inset-inline-start": "<'top'>", "interpolate-size": "numeric-only|allow-keywords", isolation: "auto|isolate", "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]", "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]", "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]", "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#", left: "<length>|<percentage>|auto", "letter-spacing": "normal|<length-percentage>", "line-break": "auto|loose|normal|strict|anywhere", "line-clamp": "none|<integer>", "line-height": "normal|<number>|<length>|<percentage>", "line-height-step": "<length>", "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>", "list-style-image": "<image>|none", "list-style-position": "inside|outside", "list-style-type": "<counter-style>|<string>|none", margin: "[<length>|<percentage>|auto]{1,4}", "margin-block": "<'margin-left'>{1,2}", "margin-block-end": "<'margin-left'>", "margin-block-start": "<'margin-left'>", "margin-bottom": "<length>|<percentage>|auto", "margin-inline": "<'margin-left'>{1,2}", "margin-inline-end": "<'margin-left'>", "margin-inline-start": "<'margin-left'>", "margin-left": "<length>|<percentage>|auto", "margin-right": "<length>|<percentage>|auto", "margin-top": "<length>|<percentage>|auto", "margin-trim": "none|in-flow|all", marker: "none|<url>", "marker-end": "none|<url>", "marker-mid": "none|<url>", "marker-start": "none|<url>", mask: "<mask-layer>#", "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>", "mask-border-mode": "luminance|alpha", "mask-border-outset": "[<length>|<number>]{1,4}", "mask-border-repeat": "[stretch|repeat|round|space]{1,2}", "mask-border-slice": "<number-percentage>{1,4} fill?", "mask-border-source": "none|<image>", "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}", "mask-clip": "[<geometry-box>|no-clip]#", "mask-composite": "<compositing-operator>#", "mask-image": "<mask-reference>#", "mask-mode": "<masking-mode>#", "mask-origin": "<geometry-box>#", "mask-position": "<position>#", "mask-repeat": "<repeat-style>#", "mask-size": "<bg-size>#", "mask-type": "luminance|alpha", "masonry-auto-flow": "[pack|next]||[definite-first|ordered]", "math-depth": "auto-add|add( <integer> )|<integer>", "math-shift": "normal|compact", "math-style": "normal|compact", "max-block-size": "<'max-width'>", "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>", "max-inline-size": "<'max-width'>", "max-lines": "none|<integer>", "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>", "min-block-size": "<'min-width'>", "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>", "min-inline-size": "<'min-width'>", "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>", "mix-blend-mode": "<blend-mode>|plus-lighter", "object-fit": "fill|contain|cover|none|scale-down", "object-position": "<position>", offset: "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?", "offset-anchor": "auto|<position>", "offset-distance": "<length-percentage>", "offset-path": "none|<offset-path>||<coord-box>", "offset-position": "normal|auto|<position>", "offset-rotate": "[auto|reverse]||<angle>", opacity: "<alpha-value>", order: "<integer>", orphans: "<integer>", outline: "[<'outline-width'>||<'outline-style'>||<'outline-color'>]", "outline-color": "auto|<color>", "outline-offset": "<length>", "outline-style": "auto|<'border-style'>", "outline-width": "<line-width>", overflow: "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>", "overflow-anchor": "auto|none", "overflow-block": "visible|hidden|clip|scroll|auto", "overflow-clip-box": "padding-box|content-box", "overflow-clip-margin": "<visual-box>||<length [0,]>", "overflow-inline": "visible|hidden|clip|scroll|auto", "overflow-wrap": "normal|break-word|anywhere", "overflow-x": "visible|hidden|clip|scroll|auto", "overflow-y": "visible|hidden|clip|scroll|auto", overlay: "none|auto", "overscroll-behavior": "[contain|none|auto]{1,2}", "overscroll-behavior-block": "contain|none|auto", "overscroll-behavior-inline": "contain|none|auto", "overscroll-behavior-x": "contain|none|auto", "overscroll-behavior-y": "contain|none|auto", padding: "[<length>|<percentage>]{1,4}", "padding-block": "<'padding-left'>{1,2}", "padding-block-end": "<'padding-left'>", "padding-block-start": "<'padding-left'>", "padding-bottom": "<length>|<percentage>", "padding-inline": "<'padding-left'>{1,2}", "padding-inline-end": "<'padding-left'>", "padding-inline-start": "<'padding-left'>", "padding-left": "<length>|<percentage>", "padding-right": "<length>|<percentage>", "padding-top": "<length>|<percentage>", page: "auto|<custom-ident>", "page-break-after": "auto|always|avoid|left|right|recto|verso", "page-break-before": "auto|always|avoid|left|right|recto|verso", "page-break-inside": "auto|avoid", "paint-order": "normal|[fill||stroke||markers]", perspective: "none|<length>", "perspective-origin": "<position>", "place-content": "<'align-content'> <'justify-content'>?", "place-items": "<'align-items'> <'justify-items'>?", "place-self": "<'align-self'> <'justify-self'>?", "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit", position: "static|relative|absolute|sticky|fixed|-webkit-sticky", "position-anchor": "auto|<anchor-name>", "position-area": "none|<position-area>", "position-try": "<'position-try-order'>? <'position-try-fallbacks'>", "position-try-fallbacks": "none|[[<dashed-ident>||<try-tactic>]|<'position-area'>]#", "position-try-order": "normal|<try-size>", "position-visibility": "always|[anchors-valid||anchors-visible||no-overflow]", "print-color-adjust": "economy|exact", quotes: "none|auto|[<string> <string>]+", r: "<length>|<percentage>", resize: "none|both|horizontal|vertical|block|inline", right: "<length>|<percentage>|auto", rotate: "none|<angle>|[x|y|z|<number>{3}]&&<angle>", "row-gap": "normal|<length-percentage>", "ruby-align": "start|center|space-between|space-around", "ruby-merge": "separate|collapse|auto", "ruby-position": "[alternate||[over|under]]|inter-character", rx: "<length>|<percentage>", ry: "<length>|<percentage>", scale: "none|<number>{1,3}", "scrollbar-color": "auto|<color>{2}", "scrollbar-gutter": "auto|stable&&both-edges?", "scrollbar-width": "auto|thin|none", "scroll-behavior": "auto|smooth", "scroll-margin": "<length>{1,4}", "scroll-margin-block": "<length>{1,2}", "scroll-margin-block-start": "<length>", "scroll-margin-block-end": "<length>", "scroll-margin-bottom": "<length>", "scroll-margin-inline": "<length>{1,2}", "scroll-margin-inline-start": "<length>", "scroll-margin-inline-end": "<length>", "scroll-margin-left": "<length>", "scroll-margin-right": "<length>", "scroll-margin-top": "<length>", "scroll-padding": "[auto|<length-percentage>]{1,4}", "scroll-padding-block": "[auto|<length-percentage>]{1,2}", "scroll-padding-block-start": "auto|<length-percentage>", "scroll-padding-block-end": "auto|<length-percentage>", "scroll-padding-bottom": "auto|<length-percentage>", "scroll-padding-inline": "[auto|<length-percentage>]{1,2}", "scroll-padding-inline-start": "auto|<length-percentage>", "scroll-padding-inline-end": "auto|<length-percentage>", "scroll-padding-left": "auto|<length-percentage>", "scroll-padding-right": "auto|<length-percentage>", "scroll-padding-top": "auto|<length-percentage>", "scroll-snap-align": "[none|start|end|center]{1,2}", "scroll-snap-coordinate": "none|<position>#", "scroll-snap-destination": "<position>", "scroll-snap-points-x": "none|repeat( <length-percentage> )", "scroll-snap-points-y": "none|repeat( <length-percentage> )", "scroll-snap-stop": "normal|always", "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?", "scroll-snap-type-x": "none|mandatory|proximity", "scroll-snap-type-y": "none|mandatory|proximity", "scroll-timeline": "[<'scroll-timeline-name'>||<'scroll-timeline-axis'>]#", "scroll-timeline-axis": "[block|inline|x|y]#", "scroll-timeline-name": "[none|<dashed-ident>]#", "shape-image-threshold": "<alpha-value>", "shape-margin": "<length-percentage>", "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>", "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision", stroke: "<paint>", "stroke-dasharray": "none|[<svg-length>+]#", "stroke-dashoffset": "<svg-length>", "stroke-linecap": "butt|round|square", "stroke-linejoin": "miter|round|bevel", "stroke-miterlimit": "<number-one-or-greater>", "stroke-opacity": "<'opacity'>", "stroke-width": "<svg-length>", "tab-size": "<integer>|<length>", "table-layout": "auto|fixed", "text-align": "start|end|left|right|center|justify|match-parent", "text-align-last": "auto|start|end|left|right|center|justify", "text-anchor": "start|middle|end", "text-combine-upright": "none|all|[digits <integer>?]", "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>", "text-decoration-color": "<color>", "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error", "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]", "text-decoration-skip-ink": "auto|all|none", "text-decoration-style": "solid|double|dotted|dashed|wavy", "text-decoration-thickness": "auto|from-font|<length>|<percentage>", "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>", "text-emphasis-color": "<color>", "text-emphasis-position": "auto|[over|under]&&[right|left]?", "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>", "text-indent": "<length-percentage>&&hanging?&&each-line?", "text-justify": "auto|inter-character|inter-word|none", "text-orientation": "mixed|upright|sideways", "text-overflow": "[clip|ellipsis|<string>]{1,2}", "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision", "text-shadow": "none|<shadow-t>#", "text-size-adjust": "none|auto|<percentage>", "text-spacing-trim": "space-all|normal|space-first|trim-start|trim-both|trim-all|auto", "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana", "text-underline-offset": "auto|<length>|<percentage>", "text-underline-position": "auto|from-font|[under||[left|right]]", "text-wrap": "<'text-wrap-mode'>||<'text-wrap-style'>", "text-wrap-mode": "auto|wrap|nowrap", "text-wrap-style": "auto|balance|stable|pretty", "timeline-scope": "none|<dashed-ident>#", top: "<length>|<percentage>|auto", "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation", transform: "none|<transform-list>", "transform-box": "content-box|border-box|fill-box|stroke-box|view-box", "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?", "transform-style": "flat|preserve-3d", transition: "<single-transition>#", "transition-behavior": "<transition-behavior-value>#", "transition-delay": "<time>#", "transition-duration": "<time>#", "transition-property": "none|<single-transition-property>#", "transition-timing-function": "<easing-function>#", translate: "none|<length-percentage> [<length-percentage> <length>?]?", "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext", "user-select": "auto|text|none|contain|all", "vector-effect": "none|non-scaling-stroke|non-scaling-size|non-rotation|fixed-position", "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>", "view-timeline": "[<'view-timeline-name'> <'view-timeline-axis'>?]#", "view-timeline-axis": "[block|inline|x|y]#", "view-timeline-inset": "[[auto|<length-percentage>]{1,2}]#", "view-timeline-name": "none|<dashed-ident>#", "view-transition-name": "none|<custom-ident>", visibility: "visible|hidden|collapse", "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces|[<'white-space-collapse'>||<'text-wrap'>||<'white-space-trim'>]", "white-space-collapse": "collapse|discard|preserve|preserve-breaks|preserve-spaces|break-spaces", widows: "<integer>", width: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>", "will-change": "auto|<animateable-feature>#", "word-break": "normal|break-all|keep-all|break-word|auto-phrase", "word-spacing": "normal|<length>", "word-wrap": "normal|break-word", "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>", x: "<length>|<percentage>", y: "<length>|<percentage>", "z-index": "auto|<integer>", zoom: "normal|reset|<number>|<percentage>", "-moz-background-clip": "padding|border", "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>", "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>", "-moz-border-radius-topleft": "<'border-top-left-radius'>", "-moz-border-radius-topright": "<'border-bottom-right-radius'>", "-moz-control-character-visibility": "visible|hidden", "-moz-osx-font-smoothing": "auto|grayscale", "-moz-user-select": "none|text|all|-moz-none", "-ms-flex-align": "start|end|center|baseline|stretch", "-ms-flex-item-align": "auto|start|end|center|baseline|stretch", "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch", "-ms-flex-negative": "<'flex-shrink'>", "-ms-flex-pack": "start|end|center|justify|distribute", "-ms-flex-order": "<integer>", "-ms-flex-positive": "<'flex-grow'>", "-ms-flex-preferred-size": "<'flex-basis'>", "-ms-interpolation-mode": "nearest-neighbor|bicubic", "-ms-grid-column-align": "start|end|center|stretch", "-ms-grid-row-align": "start|end|center|stretch", "-ms-hyphenate-limit-last": "none|always|column|page|spread", "-webkit-background-clip": "[<box>|border|padding|content|text]#", "-webkit-column-break-after": "always|auto|avoid", "-webkit-column-break-before": "always|auto|avoid", "-webkit-column-break-inside": "always|auto|avoid", "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased", "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?", "-webkit-print-color-adjust": "economy|exact", "-webkit-text-security": "none|circle|disc|square", "-webkit-user-drag": "none|element|auto", "-webkit-user-select": "auto|none|text|all", "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical", "baseline-shift": "baseline|sub|super|<svg-length>", behavior: "<url>+", cue: "<'cue-before'> <'cue-after'>?", "cue-after": "<url> <decibel>?|none", "cue-before": "<url> <decibel>?|none", "glyph-orientation-horizontal": "<angle>", "glyph-orientation-vertical": "<angle>", kerning: "auto|<svg-length>", pause: "<'pause-before'> <'pause-after'>?", "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong", "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong", rest: "<'rest-before'> <'rest-after'>?", "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong", "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong", src: "[<url> [format( <string># )]?|local( <family-name> )]#", speak: "auto|never|always", "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]", "unicode-range": "<urange>#", "voice-balance": "<number>|left|center|right|leftwards|rightwards", "voice-duration": "auto|<time>", "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve", "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]", "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]", "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>", "voice-stress": "normal|strong|moderate|none|reduced", "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]", "white-space-trim": "none|discard-before||discard-after||discard-inner" }, atrules: { charset: { prelude: "<string>", descriptors: null }, "counter-style": { prelude: "<counter-style-name>", descriptors: { "additive-symbols": "[<integer>&&<symbol>]#", fallback: "<counter-style-name>", negative: "<symbol> <symbol>?", pad: "<integer>&&<symbol>", prefix: "<symbol>", range: "[[<integer>|infinite]{2}]#|auto", "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>", suffix: "<symbol>", symbols: "<symbol>+", system: "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]" } }, document: { prelude: "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#", descriptors: null }, "font-palette-values": { prelude: "<dashed-ident>", descriptors: { "base-palette": "light|dark|<integer [0,]>", "font-family": "<family-name>#", "override-colors": "[<integer [0,]> <absolute-color-base>]#" } }, "font-face": { prelude: null, descriptors: { "ascent-override": "normal|<percentage>", "descent-override": "normal|<percentage>", "font-display": "[auto|block|swap|fallback|optional]", "font-family": "<family-name>", "font-feature-settings": "normal|<feature-tag-value>#", "font-variation-settings": "normal|[<string> <number>]#", "font-stretch": "<font-stretch-absolute>{1,2}", "font-style": "normal|italic|oblique <angle>{0,2}", "font-weight": "<font-weight-absolute>{1,2}", "line-gap-override": "normal|<percentage>", "size-adjust": "<percentage>", src: "[<url> [format( <string># )]?|local( <family-name> )]#", "unicode-range": "<urange>#" } }, "font-feature-values": { prelude: "<family-name>#", descriptors: null }, import: { prelude: "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?", descriptors: null }, keyframes: { prelude: "<keyframes-name>", descriptors: null }, layer: { prelude: "[<layer-name>#|<layer-name>?]", descriptors: null }, media: { prelude: "<media-query-list>", descriptors: null }, namespace: { prelude: "<namespace-prefix>? [<string>|<url>]", descriptors: null }, page: { prelude: "<page-selector-list>", descriptors: { bleed: "auto|<length>", marks: "none|[crop||cross]", "page-orientation": "upright|rotate-left|rotate-right", size: "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]" } }, "position-try": { prelude: "<dashed-ident>", descriptors: { top: "<'top'>", left: "<'left'>", bottom: "<'bottom'>", right: "<'right'>", "inset-block-start": "<'inset-block-start'>", "inset-block-end": "<'inset-block-end'>", "inset-inline-start": "<'inset-inline-start'>", "inset-inline-end": "<'inset-inline-end'>", "inset-block": "<'inset-block'>", "inset-inline": "<'inset-inline'>", inset: "<'inset'>", "margin-top": "<'margin-top'>", "margin-left": "<'margin-left'>", "margin-bottom": "<'margin-bottom'>", "margin-right": "<'margin-right'>", "margin-block-start": "<'margin-block-start'>", "margin-block-end": "<'margin-block-end'>", "margin-inline-start": "<'margin-inline-start'>", "margin-inline-end": "<'margin-inline-end'>", margin: "<'margin'>", "margin-block": "<'margin-block'>", "margin-inline": "<'margin-inline'>", width: "<'width'>", height: "<'height'>", "min-width": "<'min-width'>", "min-height": "<'min-height'>", "max-width": "<'max-width'>", "max-height": "<'max-height'>", "block-size": "<'block-size'>", "inline-size": "<'inline-size'>", "min-block-size": "<'min-block-size'>", "min-inline-size": "<'min-inline-size'>", "max-block-size": "<'max-block-size'>", "max-inline-size": "<'max-inline-size'>", "align-self": "<'align-self'>|anchor-center", "justify-self": "<'justify-self'>|anchor-center" } }, property: { prelude: "<custom-property-name>", descriptors: { syntax: "<string>", inherits: "true|false", "initial-value": "<declaration-value>?" } }, scope: { prelude: "[( <scope-start> )]? [to ( <scope-end> )]?", descriptors: null }, "starting-style": { prelude: null, descriptors: null }, supports: { prelude: "<supports-condition>", descriptors: null }, container: { prelude: "[<container-name>]? <container-condition>", descriptors: null }, nest: { prelude: "<complex-selector-list>", descriptors: null } } }; const PLUSSIGN$f = 43, HYPHENMINUS$9 = 45, N$5 = 110, DISALLOW_SIGN$2 = !0, ALLOW_SIGN$2 = !1; function checkInteger$2(e, t) { let n = this.tokenStart + e; const r = this.charCodeAt(n); for (r !== PLUSSIGN$f && r !== HYPHENMINUS$9 || (t && this.error("Number sign is not allowed"), n++); n < this.tokenEnd; n++)isDigit$2(this.charCodeAt(n)) || this.error("Integer is expected", n) } function checkTokenIsInteger$1(e) { return checkInteger$2.call(this, 0, e) } function expectCharCode$1(e, t) { if (!this.cmpChar(this.tokenStart + e, t)) { let n = ""; switch (t) { case N$5: n = "N is expected"; break; case HYPHENMINUS$9: n = "HyphenMinus is expected" }this.error(n, this.tokenStart + e) } } function consumeB$2() { let e = 0, t = 0, n = this.tokenType; for (; n === WhiteSpace$3 || n === Comment$3;)n = this.lookupType(++e); if (n !== Number$5) { if (!this.isDelim(PLUSSIGN$f, e) && !this.isDelim(HYPHENMINUS$9, e)) return null; t = this.isDelim(PLUSSIGN$f, e) ? PLUSSIGN$f : HYPHENMINUS$9; do { n = this.lookupType(++e) } while (n === WhiteSpace$3 || n === Comment$3); n !== Number$5 && (this.skip(e), checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2)) } return e > 0 && this.skip(e), 0 === t && (n = this.charCodeAt(this.tokenStart), n !== PLUSSIGN$f && n !== HYPHENMINUS$9 && this.error("Number sign is expected")), checkTokenIsInteger$1.call(this, 0 !== t), t === HYPHENMINUS$9 ? "-" + this.consume(Number$5) : this.consume(Number$5) } const name$2a = "AnPlusB", structure$1o = { a: [String, null], b: [String, null] }; function parse$1t() { const e = this.tokenStart; let t = null, n = null; if (this.tokenType === Number$5) checkTokenIsInteger$1.call(this, false), n = this.consume(Number$5); else if (this.tokenType === Ident$1 && this.cmpChar(this.tokenStart, HYPHENMINUS$9)) switch (t = "-1", expectCharCode$1.call(this, 1, N$5), this.tokenEnd - this.tokenStart) { case 2: this.next(), n = consumeB$2.call(this); break; case 3: expectCharCode$1.call(this, 2, HYPHENMINUS$9), this.next(), this.skipSC(), checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2), n = "-" + this.consume(Number$5); break; default: expectCharCode$1.call(this, 2, HYPHENMINUS$9), checkInteger$2.call(this, 3, DISALLOW_SIGN$2), this.next(), n = this.substrToCursor(e + 2) } else if (this.tokenType === Ident$1 || this.isDelim(PLUSSIGN$f) && this.lookupType(1) === Ident$1) { let r = 0; switch (t = "1", this.isDelim(PLUSSIGN$f) && (r = 1, this.next()), expectCharCode$1.call(this, 0, N$5), this.tokenEnd - this.tokenStart) { case 1: this.next(), n = consumeB$2.call(this); break; case 2: expectCharCode$1.call(this, 1, HYPHENMINUS$9), this.next(), this.skipSC(), checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2), n = "-" + this.consume(Number$5); break; default: expectCharCode$1.call(this, 1, HYPHENMINUS$9), checkInteger$2.call(this, 2, DISALLOW_SIGN$2), this.next(), n = this.substrToCursor(e + r + 1) } } else if (this.tokenType === Dimension$3) { const r = this.charCodeAt(this.tokenStart), a = r === PLUSSIGN$f || r === HYPHENMINUS$9; let o = this.tokenStart + a; for (; o < this.tokenEnd && isDigit$2(this.charCodeAt(o)); o++); o === this.tokenStart + a && this.error("Integer is expected", this.tokenStart + a), expectCharCode$1.call(this, o - this.tokenStart, N$5), t = this.substring(e, o), o + 1 === this.tokenEnd ? (this.next(), n = consumeB$2.call(this)) : (expectCharCode$1.call(this, o - this.tokenStart + 1, HYPHENMINUS$9), o + 2 === this.tokenEnd ? (this.next(), this.skipSC(), checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2), n = "-" + this.consume(Number$5)) : (checkInteger$2.call(this, o - this.tokenStart + 2, DISALLOW_SIGN$2), this.next(), n = this.substrToCursor(o + 1))) } else this.error(); return null !== t && t.charCodeAt(0) === PLUSSIGN$f && (t = t.substr(1)), null !== n && n.charCodeAt(0) === PLUSSIGN$f && (n = n.substr(1)), { type: "AnPlusB", loc: this.getLocation(e, this.tokenStart), a: t, b: n } } function generate$1t(e) { if (e.a) { const t = ("+1" === e.a || "1" === e.a ? "n" : "-1" === e.a && "-n") || e.a + "n"; if (e.b) { const n = "-" === e.b[0] || "+" === e.b[0] ? e.b : "+" + e.b; this.tokenize(t + n) } else this.tokenize(t) } else this.tokenize(e.b) } var AnPlusB$1 = Object.freeze({ __proto__: null, generate: generate$1t, name: name$2a, parse: parse$1t, structure: structure$1o }); function consumeRaw$a() { return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, !0) } function isDeclarationBlockAtrule$1() { for (let e, t = 1; e = this.lookupType(t); t++) { if (e === RightCurlyBracket$1) return !0; if (e === LeftCurlyBracket$1 || e === AtKeyword$1) return !1 } return !1 } const name$29 = "Atrule", walkContext$j = "atrule", structure$1n = { name: String, prelude: ["AtrulePrelude", "Raw", null], block: ["Block", null] }; function parse$1s(e = !1) { const t = this.tokenStart; let n, r, a = null, o = null; switch (this.eat(AtKeyword$1), n = this.substrToCursor(t + 1), r = n.toLowerCase(), this.skipSC(), !1 === this.eof && this.tokenType !== LeftCurlyBracket$1 && this.tokenType !== Semicolon$1 && (a = this.parseAtrulePrelude ? this.parseWithFallback(this.AtrulePrelude.bind(this, n, e), consumeRaw$a) : consumeRaw$a.call(this, this.tokenIndex), this.skipSC()), this.tokenType) { case Semicolon$1: this.next(); break; case LeftCurlyBracket$1: o = hasOwnProperty.call(this.atrule, r) && "function" == typeof this.atrule[r].block ? this.atrule[r].block.call(this, e) : this.Block(isDeclarationBlockAtrule$1.call(this)) }return { type: "Atrule", loc: this.getLocation(t, this.tokenStart), name: n, prelude: a, block: o } } function generate$1s(e) { this.token(AtKeyword$1, "@" + e.name), null !== e.prelude && this.node(e.prelude), e.block ? this.node(e.block) : this.token(Semicolon$1, ";") } var Atrule$2 = Object.freeze({ __proto__: null, generate: generate$1s, name: name$29, parse: parse$1s, structure: structure$1n, walkContext: "atrule" }); const name$28 = "AtrulePrelude", walkContext$i = "atrulePrelude", structure$1m = { children: [[]] }; function parse$1r(e) { let t = null; return null !== e && (e = e.toLowerCase()), this.skipSC(), t = hasOwnProperty.call(this.atrule, e) && "function" == typeof this.atrule[e].prelude ? this.atrule[e].prelude.call(this) : this.readSequence(this.scope.AtrulePrelude), this.skipSC(), !0 !== this.eof && this.tokenType !== LeftCurlyBracket$1 && this.tokenType !== Semicolon$1 && this.error("Semicolon or block is expected"), { type: "AtrulePrelude", loc: this.getLocationFromList(t), children: t } } function generate$1r(e) { this.children(e) } var AtrulePrelude$1 = Object.freeze({ __proto__: null, generate: generate$1r, name: name$28, parse: parse$1r, structure: structure$1m, walkContext: walkContext$i }); const DOLLARSIGN$3 = 36, ASTERISK$c = 42, EQUALSSIGN$2 = 61, CIRCUMFLEXACCENT$1 = 94, VERTICALLINE$6 = 124, TILDE$5 = 126; function getAttributeName$1() { this.eof && this.error("Unexpected end of input"); const e = this.tokenStart; let t = !1; return this.isDelim(ASTERISK$c) ? (t = !0, this.next()) : this.isDelim(VERTICALLINE$6) || this.eat(Ident$1), this.isDelim(VERTICALLINE$6) ? this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN$2 ? (this.next(), this.eat(Ident$1)) : t && this.error("Identifier is expected", this.tokenEnd) : t && this.error("Vertical line is expected"), { type: "Identifier", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e) } } function getOperator$1() { const e = this.tokenStart, t = this.charCodeAt(e); return t !== EQUALSSIGN$2 && t !== TILDE$5 && t !== CIRCUMFLEXACCENT$1 && t !== DOLLARSIGN$3 && t !== ASTERISK$c && t !== VERTICALLINE$6 && this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected"), this.next(), t !== EQUALSSIGN$2 && (this.isDelim(EQUALSSIGN$2) || this.error("Equal sign is expected"), this.next()), this.substrToCursor(e) } const name$27 = "AttributeSelector", structure$1l = { name: "Identifier", matcher: [String, null], value: ["String", "Identifier", null], flags: [String, null] }; function parse$1q() { const e = this.tokenStart; let t, n = null, r = null, a = null; return this.eat(LeftSquareBracket$1), this.skipSC(), t = getAttributeName$1.call(this), this.skipSC(), this.tokenType !== RightSquareBracket$1 && (this.tokenType !== Ident$1 && (n = getOperator$1.call(this), this.skipSC(), r = this.tokenType === String$4 ? this.String() : this.Identifier(), this.skipSC()), this.tokenType === Ident$1 && (a = this.consume(Ident$1), this.skipSC())), this.eat(RightSquareBracket$1), { type: "AttributeSelector", loc: this.getLocation(e, this.tokenStart), name: t, matcher: n, value: r, flags: a } } function generate$1q(e) { this.token(Delim$1, "["), this.node(e.name), null !== e.matcher && (this.tokenize(e.matcher), this.node(e.value)), null !== e.flags && this.token(Ident$1, e.flags), this.token(Delim$1, "]") } var AttributeSelector$2 = Object.freeze({ __proto__: null, generate: generate$1q, name: name$27, parse: parse$1q, structure: structure$1l }); const AMPERSAND$6 = 38; function consumeRaw$9() { return this.Raw(null, !0) } function consumeRule$1() { return this.parseWithFallback(this.Rule, consumeRaw$9) } function consumeRawDeclaration$1() { return this.Raw(this.consumeUntilSemicolonIncluded, !0) } function consumeDeclaration$1() { if (this.tokenType === Semicolon$1) return consumeRawDeclaration$1.call(this, this.tokenIndex); const e = this.parseWithFallback(this.Declaration, consumeRawDeclaration$1); return this.tokenType === Semicolon$1 && this.next(), e } const name$26 = "Block", walkContext$h = "block", structure$1k = { children: [["Atrule", "Rule", "Declaration"]] }; function parse$1p(e) { const t = e ? consumeDeclaration$1 : consumeRule$1, n = this.tokenStart; let r = this.createList(); this.eat(LeftCurlyBracket$1); e: for (; !this.eof;)switch (this.tokenType) { case RightCurlyBracket$1: break e; case WhiteSpace$3: case Comment$3: this.next(); break; case AtKeyword$1: r.push(this.parseWithFallback(this.Atrule.bind(this, e), consumeRaw$9)); break; default: e && this.isDelim(38) ? r.push(consumeRule$1.call(this)) : r.push(t.call(this)) }return this.eof || this.eat(RightCurlyBracket$1), { type: "Block", loc: this.getLocation(n, this.tokenStart), children: r } } function generate$1p(e) { this.token(LeftCurlyBracket$1, "{"), this.children(e, (e => { "Declaration" === e.type && this.token(Semicolon$1, ";") })), this.token(RightCurlyBracket$1, "}") } var Block$1 = Object.freeze({ __proto__: null, generate: generate$1p, name: "Block", parse: parse$1p, structure: structure$1k, walkContext: "block" }); const name$25 = "Brackets", structure$1j = { children: [[]] }; function parse$1o(e, t) { const n = this.tokenStart; let r = null; return this.eat(LeftSquareBracket$1), r = e.call(this, t), this.eof || this.eat(RightSquareBracket$1), { type: "Brackets", loc: this.getLocation(n, this.tokenStart), children: r } } function generate$1o(e) { this.token(Delim$1, "["), this.children(e), this.token(Delim$1, "]") } var Brackets$1 = Object.freeze({ __proto__: null, generate: generate$1o, name: name$25, parse: parse$1o, structure: structure$1j }); const name$24 = "CDC", structure$1i = []; function parse$1n() { const e = this.tokenStart; return this.eat(CDC$3), { type: "CDC", loc: this.getLocation(e, this.tokenStart) } } function generate$1n() { this.token(CDC$3, "--\x3e") } var CDC$2 = Object.freeze({ __proto__: null, generate: generate$1n, name: "CDC", parse: parse$1n, structure: structure$1i }); const name$23 = "CDO", structure$1h = []; function parse$1m() { const e = this.tokenStart; return this.eat(CDO$3), { type: "CDO", loc: this.getLocation(e, this.tokenStart) } } function generate$1m() { this.token(CDO$3, "\x3c!--") } var CDO$2 = Object.freeze({ __proto__: null, generate: generate$1m, name: "CDO", parse: parse$1m, structure: structure$1h }); const FULLSTOP$5 = 46, name$22 = "ClassSelector", structure$1g = { name: String }; function parse$1l() { return this.eatDelim(46), { type: "ClassSelector", loc: this.getLocation(this.tokenStart - 1, this.tokenEnd), name: this.consume(Ident$1) } } function generate$1l(e) { this.token(Delim$1, "."), this.token(Ident$1, e.name) } var ClassSelector$1 = Object.freeze({ __proto__: null, generate: generate$1l, name: name$22, parse: parse$1l, structure: structure$1g }); const PLUSSIGN$e = 43, SOLIDUS$d = 47, GREATERTHANSIGN$5 = 62, TILDE$4 = 126, name$21 = "Combinator", structure$1f = { name: String }; function parse$1k() { const e = this.tokenStart; let t; switch (this.tokenType) { case WhiteSpace$3: t = " "; break; case Delim$1: switch (this.charCodeAt(this.tokenStart)) { case 62: case 43: case 126: this.next(); break; case 47: this.next(), this.eatIdent("deep"), this.eatDelim(47); break; default: this.error("Combinator is expected") }t = this.substrToCursor(e) }return { type: "Combinator", loc: this.getLocation(e, this.tokenStart), name: t } } function generate$1k(e) { this.tokenize(e.name) } var Combinator$1 = Object.freeze({ __proto__: null, generate: generate$1k, name: name$21, parse: parse$1k, structure: structure$1f }); const ASTERISK$b = 42, SOLIDUS$c = 47, name$20 = "Comment", structure$1e = { value: String }; function parse$1j() { const e = this.tokenStart; let t = this.tokenEnd; return this.eat(Comment$3), t - e + 2 >= 2 && 42 === this.charCodeAt(t - 2) && 47 === this.charCodeAt(t - 1) && (t -= 2), { type: "Comment", loc: this.getLocation(e, this.tokenStart), value: this.substring(e + 2, t) } } function generate$1j(e) { this.token(Comment$3, "/*" + e.value + "*/") } var Comment$2 = Object.freeze({ __proto__: null, generate: generate$1j, name: name$20, parse: parse$1j, structure: structure$1e }); const likelyFeatureToken = new Set([Colon$1, RightParenthesis$1, 0]), name$1$ = "Condition", structure$1d = { kind: String, children: [["Identifier", "Feature", "FeatureFunction", "FeatureRange", "SupportsDeclaration"]] }; function featureOrRange(e) { return this.lookupTypeNonSC(1) === Ident$1 && likelyFeatureToken.has(this.lookupTypeNonSC(2)) ? this.Feature(e) : this.FeatureRange(e) } const parentheses$1 = { media: featureOrRange, container: featureOrRange, supports() { return this.SupportsDeclaration() } }; function parse$1i(e = "media") { const t = this.createList(); e: for (; !this.eof;)switch (this.tokenType) { case Comment$3: case WhiteSpace$3: this.next(); continue; case Ident$1: t.push(this.Identifier()); break; case LeftParenthesis$1: { let n = this.parseWithFallback((() => parentheses$1[e].call(this, e)), (() => null)); n || (n = this.parseWithFallback((() => { this.eat(LeftParenthesis$1); const t = this.Condition(e); return this.eat(RightParenthesis$1), t }), (() => this.GeneralEnclosed(e)))), t.push(n); break } case Function$3: { let n = this.parseWithFallback((() => this.FeatureFunction(e)), (() => null)); n || (n = this.GeneralEnclosed(e)), t.push(n); break } default: break e }return t.isEmpty && this.error("Condition is expected"), { type: "Condition", loc: this.getLocationFromList(t), kind: e, children: t } } function generate$1i(e) { e.children.forEach((e => { "Condition" === e.type ? (this.token(LeftParenthesis$1, "("), this.node(e), this.token(RightParenthesis$1, ")")) : this.node(e) })) } var Condition = Object.freeze({ __proto__: null, generate: generate$1i, name: name$1$, parse: parse$1i, structure: structure$1d }); const EXCLAMATIONMARK$5 = 33, NUMBERSIGN$7 = 35, DOLLARSIGN$2 = 36, AMPERSAND$5 = 38, ASTERISK$a = 42, PLUSSIGN$d = 43, SOLIDUS$b = 47; function consumeValueRaw$1() { return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, !0) } function consumeCustomPropertyRaw$1() { return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, !1) } function consumeValue$1() { const e = this.tokenIndex, t = this.Value(); return "Raw" !== t.type && !1 === this.eof && this.tokenType !== Semicolon$1 && !1 === this.isDelim(EXCLAMATIONMARK$5) && !1 === this.isBalanceEdge(e) && this.error(), t } const name$1_ = "Declaration", walkContext$g = "declaration", structure$1c = { important: [Boolean, String], property: String, value: ["Value", "Raw"] }; function parse$1h() { const e = this.tokenStart, t = this.tokenIndex, n = readProperty$2.call(this), r = isCustomProperty$1(n), a = r ? this.parseCustomProperty : this.parseValue, o = r ? consumeCustomPropertyRaw$1 : consumeValueRaw$1; let i, s = !1; this.skipSC(), this.eat(Colon$1); const l = this.tokenIndex; if (r || this.skipSC(), i = a ? this.parseWithFallback(consumeValue$1, o) : o.call(this, this.tokenIndex), r && "Value" === i.type && i.children.isEmpty) for (let e = l - this.tokenIndex; e <= 0; e++)if (this.lookupType(e) === WhiteSpace$3) { i.children.appendData({ type: "WhiteSpace", loc: null, value: " " }); break } return this.isDelim(EXCLAMATIONMARK$5) && (s = getImportant$1.call(this), this.skipSC()), !1 === this.eof && this.tokenType !== Semicolon$1 && !1 === this.isBalanceEdge(t) && this.error(), { type: "Declaration", loc: this.getLocation(e, this.tokenStart), important: s, property: n, value: i } } function generate$1h(e) { this.token(Ident$1, e.property), this.token(Colon$1, ":"), this.node(e.value), e.important && (this.token(Delim$1, "!"), this.token(Ident$1, !0 === e.important ? "important" : e.important)) } function readProperty$2() { const e = this.tokenStart; if (this.tokenType === Delim$1) switch (this.charCodeAt(this.tokenStart)) { case ASTERISK$a: case DOLLARSIGN$2: case PLUSSIGN$d: case NUMBERSIGN$7: case AMPERSAND$5: this.next(); break; case SOLIDUS$b: this.next(), this.isDelim(SOLIDUS$b) && this.next() }return this.tokenType === Hash$3 ? this.eat(Hash$3) : this.eat(Ident$1), this.substrToCursor(e) } function getImportant$1() { this.eat(Delim$1), this.skipSC(); const e = this.consume(Ident$1); return "important" === e || e } var Declaration$1 = Object.freeze({ __proto__: null, generate: generate$1h, name: name$1_, parse: parse$1h, structure: structure$1c, walkContext: "declaration" }); const AMPERSAND$4 = 38; function consumeRaw$8() { return this.Raw(this.consumeUntilSemicolonIncluded, !0) } const name$1Z = "DeclarationList", structure$1b = { children: [["Declaration", "Atrule", "Rule"]] }; function parse$1g() { const e = this.createList(); for (; !this.eof;)switch (this.tokenType) { case WhiteSpace$3: case Comment$3: case Semicolon$1: this.next(); break; case AtKeyword$1: e.push(this.parseWithFallback(this.Atrule.bind(this, !0), consumeRaw$8)); break; default: this.isDelim(38) ? e.push(this.parseWithFallback(this.Rule, consumeRaw$8)) : e.push(this.parseWithFallback(this.Declaration, consumeRaw$8)) }return { type: "DeclarationList", loc: this.getLocationFromList(e), children: e } } function generate$1g(e) { this.children(e, (e => { "Declaration" === e.type && this.token(Semicolon$1, ";") })) } var DeclarationList$1 = Object.freeze({ __proto__: null, generate: generate$1g, name: name$1Z, parse: parse$1g, structure: structure$1b }); const name$1Y = "Dimension", structure$1a = { value: String, unit: String }; function parse$1f() { const e = this.tokenStart, t = this.consumeNumber(Dimension$3); return { type: "Dimension", loc: this.getLocation(e, this.tokenStart), value: t, unit: this.substring(e + t.length, this.tokenStart) } } function generate$1f(e) { this.token(Dimension$3, e.value + e.unit) } var Dimension$2 = Object.freeze({ __proto__: null, generate: generate$1f, name: name$1Y, parse: parse$1f, structure: structure$1a }); const SOLIDUS$a = 47, name$1X = "Feature", structure$19 = { kind: String, name: String, value: ["Identifier", "Number", "Dimension", "Ratio", "Function", null] }; function parse$1e(e) { const t = this.tokenStart; let n, r = null; if (this.eat(LeftParenthesis$1), this.skipSC(), n = this.consume(Ident$1), this.skipSC(), this.tokenType !== RightParenthesis$1) { switch (this.eat(Colon$1), this.skipSC(), this.tokenType) { case Number$5: r = this.lookupNonWSType(1) === Delim$1 ? this.Ratio() : this.Number(); break; case Dimension$3: r = this.Dimension(); break; case Ident$1: r = this.Identifier(); break; case Function$3: r = this.parseWithFallback((() => { const e = this.Function(this.readSequence, this.scope.Value); return this.skipSC(), this.isDelim(47) && this.error(), e }), (() => this.Ratio())); break; default: this.error("Number, dimension, ratio or identifier is expected") }this.skipSC() } return this.eof || this.eat(RightParenthesis$1), { type: "Feature", loc: this.getLocation(t, this.tokenStart), kind: e, name: n, value: r } } function generate$1e(e) { this.token(LeftParenthesis$1, "("), this.token(Ident$1, e.name), null !== e.value && (this.token(Colon$1, ":"), this.node(e.value)), this.token(RightParenthesis$1, ")") } var Feature = Object.freeze({ __proto__: null, generate: generate$1e, name: name$1X, parse: parse$1e, structure: structure$19 }); const name$1W = "FeatureFunction", structure$18 = { kind: String, feature: String, value: ["Declaration", "Selector"] }; function getFeatureParser(e, t) { const n = (this.features[e] || {})[t]; return "function" != typeof n && this.error(`Unknown feature ${t}()`), n } function parse$1d(e = "unknown") { const t = this.tokenStart, n = this.consumeFunctionName(), r = getFeatureParser.call(this, e, n.toLowerCase()); this.skipSC(); const a = this.parseWithFallback((() => { const e = this.tokenIndex, t = r.call(this); return !1 === this.eof && !1 === this.isBalanceEdge(e) && this.error(), t }), (() => this.Raw(null, !1))); return this.eof || this.eat(RightParenthesis$1), { type: "FeatureFunction", loc: this.getLocation(t, this.tokenStart), kind: e, feature: n, value: a } } function generate$1d(e) { this.token(Function$3, e.feature + "("), this.node(e.value), this.token(RightParenthesis$1, ")") } var FeatureFunction = Object.freeze({ __proto__: null, generate: generate$1d, name: name$1W, parse: parse$1d, structure: structure$18 }); const SOLIDUS$9 = 47, LESSTHANSIGN$1 = 60, EQUALSSIGN$1 = 61, GREATERTHANSIGN$4 = 62, name$1V = "FeatureRange", structure$17 = { kind: String, left: ["Identifier", "Number", "Dimension", "Ratio", "Function"], leftComparison: String, middle: ["Identifier", "Number", "Dimension", "Ratio", "Function"], rightComparison: [String, null], right: ["Identifier", "Number", "Dimension", "Ratio", "Function", null] }; function readTerm() { switch (this.skipSC(), this.tokenType) { case Number$5: return this.isDelim(SOLIDUS$9, this.lookupOffsetNonSC(1)) ? this.Ratio() : this.Number(); case Dimension$3: return this.Dimension(); case Ident$1: return this.Identifier(); case Function$3: return this.parseWithFallback((() => { const e = this.Function(this.readSequence, this.scope.Value); return this.skipSC(), this.isDelim(SOLIDUS$9) && this.error(), e }), (() => this.Ratio())); default: this.error("Number, dimension, ratio or identifier is expected") } } function readComparison(e) { if (this.skipSC(), this.isDelim(LESSTHANSIGN$1) || this.isDelim(GREATERTHANSIGN$4)) { const e = this.source[this.tokenStart]; return this.next(), this.isDelim(EQUALSSIGN$1) ? (this.next(), e + "=") : e } if (this.isDelim(EQUALSSIGN$1)) return "="; this.error(`Expected ${e ? '":", ' : ""}"<", ">", "=" or ")"`) } function parse$1c(e = "unknown") { const t = this.tokenStart; this.skipSC(), this.eat(LeftParenthesis$1); const n = readTerm.call(this), r = readComparison.call(this, "Identifier" === n.type), a = readTerm.call(this); let o = null, i = null; return this.lookupNonWSType(0) !== RightParenthesis$1 && (o = readComparison.call(this), i = readTerm.call(this)), this.skipSC(), this.eat(RightParenthesis$1), { type: "FeatureRange", loc: this.getLocation(t, this.tokenStart), kind: e, left: n, leftComparison: r, middle: a, rightComparison: o, right: i } } function generate$1c(e) { this.token(LeftParenthesis$1, "("), this.node(e.left), this.tokenize(e.leftComparison), this.node(e.middle), e.right && (this.tokenize(e.rightComparison), this.node(e.right)), this.token(RightParenthesis$1, ")") } var FeatureRange = Object.freeze({ __proto__: null, generate: generate$1c, name: name$1V, parse: parse$1c, structure: structure$17 }); const name$1U = "Function", walkContext$f = "function", structure$16 = { name: String, children: [[]] }; function parse$1b(e, t) { const n = this.tokenStart, r = this.consumeFunctionName(), a = r.toLowerCase(); let o; return o = t.hasOwnProperty(a) ? t[a].call(this, t) : e.call(this, t), this.eof || this.eat(RightParenthesis$1), { type: "Function", loc: this.getLocation(n, this.tokenStart), name: r, children: o } } function generate$1b(e) { this.token(Function$3, e.name + "("), this.children(e), this.token(RightParenthesis$1, ")") } var Function$2 = Object.freeze({ __proto__: null, generate: generate$1b, name: name$1U, parse: parse$1b, structure: structure$16, walkContext: "function" }); const name$1T = "GeneralEnclosed", structure$15 = { kind: String, function: [String, null], children: [[]] }; function parse$1a(e) { const t = this.tokenStart; let n = null; this.tokenType === Function$3 ? n = this.consumeFunctionName() : this.eat(LeftParenthesis$1); const r = this.parseWithFallback((() => { const e = this.tokenIndex, t = this.readSequence(this.scope.Value); return !1 === this.eof && !1 === this.isBalanceEdge(e) && this.error(), t }), (() => this.createSingleNodeList(this.Raw(null, !1)))); return this.eof || this.eat(RightParenthesis$1), { type: "GeneralEnclosed", loc: this.getLocation(t, this.tokenStart), kind: e, function: n, children: r } } function generate$1a(e) { e.function ? this.token(Function$3, e.function + "(") : this.token(LeftParenthesis$1, "("), this.children(e), this.token(RightParenthesis$1, ")") } var GeneralEnclosed = Object.freeze({ __proto__: null, generate: generate$1a, name: name$1T, parse: parse$1a, structure: structure$15 }); const xxx$1 = "XXX", name$1S = "Hash", structure$14 = { value: String }; function parse$19() { const e = this.tokenStart; return this.eat(Hash$3), { type: "Hash", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e + 1) } } function generate$19(e) { this.token(Hash$3, "#" + e.value) } var Hash$2 = Object.freeze({ __proto__: null, generate: generate$19, name: "Hash", parse: parse$19, structure: structure$14, xxx: "XXX" }); const name$1R = "Identifier", structure$13 = { name: String }; function parse$18() { return { type: "Identifier", loc: this.getLocation(this.tokenStart, this.tokenEnd), name: this.consume(Ident$1) } } function generate$18(e) { this.token(Ident$1, e.name) } var Identifier$1 = Object.freeze({ __proto__: null, generate: generate$18, name: name$1R, parse: parse$18, structure: structure$13 }); const name$1Q = "IdSelector", structure$12 = { name: String }; function parse$17() { const e = this.tokenStart; return this.eat(Hash$3), { type: "IdSelector", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e + 1) } } function generate$17(e) { this.token(Delim$1, "#" + e.name) } var IdSelector$1 = Object.freeze({ __proto__: null, generate: generate$17, name: name$1Q, parse: parse$17, structure: structure$12 }); const FULLSTOP$4 = 46, name$1P = "Layer", structure$11 = { name: String }; function parse$16() { let e = this.consume(Ident$1); for (; this.isDelim(46);)this.eat(Delim$1), e += "." + this.consume(Ident$1); return { type: "Layer", loc: this.getLocation(this.tokenStart, this.tokenEnd), name: e } } function generate$16(e) { this.tokenize(e.name) } var Layer = Object.freeze({ __proto__: null, generate: generate$16, name: "Layer", parse: parse$16, structure: structure$11 }); const name$1O = "LayerList", structure$10 = { children: [["Layer"]] }; function parse$15() { const e = this.createList(); for (this.skipSC(); !this.eof && (e.push(this.Layer()), this.lookupTypeNonSC(0) === Comma$1);)this.skipSC(), this.next(), this.skipSC(); return { type: "LayerList", loc: this.getLocationFromList(e), children: e } } function generate$15(e) { this.children(e, (() => this.token(Comma$1, ","))) } var LayerList = Object.freeze({ __proto__: null, generate: generate$15, name: name$1O, parse: parse$15, structure: structure$10 }); const name$1N = "MediaQuery", structure$$ = { modifier: [String, null], mediaType: [String, null], condition: ["Condition", null] }; function parse$14() { const e = this.tokenStart; let t = null, n = null, r = null; if (this.skipSC(), this.tokenType === Ident$1 && this.lookupTypeNonSC(1) !== LeftParenthesis$1) { const e = this.consume(Ident$1), a = e.toLowerCase(); switch ("not" === a || "only" === a ? (this.skipSC(), t = a, n = this.consume(Ident$1)) : n = e, this.lookupTypeNonSC(0)) { case Ident$1: this.skipSC(), this.eatIdent("and"), r = this.Condition("media"); break; case LeftCurlyBracket$1: case Semicolon$1: case Comma$1: case 0: break; default: this.error("Identifier or parenthesis is expected") } } else switch (this.tokenType) { case Ident$1: case LeftParenthesis$1: case Function$3: r = this.Condition("media"); break; case LeftCurlyBracket$1: case Semicolon$1: case 0: break; default: this.error("Identifier or parenthesis is expected") }return { type: "MediaQuery", loc: this.getLocation(e, this.tokenStart), modifier: t, mediaType: n, condition: r } } function generate$14(e) { e.mediaType ? (e.modifier && this.token(Ident$1, e.modifier), this.token(Ident$1, e.mediaType), e.condition && (this.token(Ident$1, "and"), this.node(e.condition))) : e.condition && this.node(e.condition) } var MediaQuery$1 = Object.freeze({ __proto__: null, generate: generate$14, name: name$1N, parse: parse$14, structure: structure$$ }); const name$1M = "MediaQueryList", structure$_ = { children: [["MediaQuery"]] }; function parse$13() { const e = this.createList(); for (this.skipSC(); !this.eof && (e.push(this.MediaQuery()), this.tokenType === Comma$1);)this.next(); return { type: "MediaQueryList", loc: this.getLocationFromList(e), children: e } } function generate$13(e) { this.children(e, (() => this.token(Comma$1, ","))) } var MediaQueryList$1 = Object.freeze({ __proto__: null, generate: generate$13, name: name$1M, parse: parse$13, structure: structure$_ }); const AMPERSAND$3 = 38, name$1L = "NestingSelector", structure$Z = {}; function parse$12() { const e = this.tokenStart; return this.eatDelim(38), { type: "NestingSelector", loc: this.getLocation(e, this.tokenStart) } } function generate$12() { this.token(Delim$1, "&") } var NestingSelector = Object.freeze({ __proto__: null, generate: generate$12, name: name$1L, parse: parse$12, structure: structure$Z }); const name$1K = "Nth", structure$Y = { nth: ["AnPlusB", "Identifier"], selector: ["SelectorList", null] }; function parse$11() { this.skipSC(); const e = this.tokenStart; let t, n = e, r = null; return t = this.lookupValue(0, "odd") || this.lookupValue(0, "even") ? this.Identifier() : this.AnPlusB(), n = this.tokenStart, this.skipSC(), this.lookupValue(0, "of") && (this.next(), r = this.SelectorList(), n = this.tokenStart), { type: "Nth", loc: this.getLocation(e, n), nth: t, selector: r } } function generate$11(e) { this.node(e.nth), null !== e.selector && (this.token(Ident$1, "of"), this.node(e.selector)) } var Nth$1 = Object.freeze({ __proto__: null, generate: generate$11, name: "Nth", parse: parse$11, structure: structure$Y }); const name$1J = "Number", structure$X = { value: String }; function parse$10() { return { type: "Number", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consume(Number$5) } } function generate$10(e) { this.token(Number$5, e.value) } var Number$4 = Object.freeze({ __proto__: null, generate: generate$10, name: name$1J, parse: parse$10, structure: structure$X }); const name$1I = "Operator", structure$W = { value: String }; function parse$$() { const e = this.tokenStart; return this.next(), { type: "Operator", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e) } } function generate$$(e) { this.tokenize(e.value) } var Operator$1 = Object.freeze({ __proto__: null, generate: generate$$, name: name$1I, parse: parse$$, structure: structure$W }); const name$1H = "Parentheses", structure$V = { children: [[]] }; function parse$_(e, t) { const n = this.tokenStart; let r = null; return this.eat(LeftParenthesis$1), r = e.call(this, t), this.eof || this.eat(RightParenthesis$1), { type: "Parentheses", loc: this.getLocation(n, this.tokenStart), children: r } } function generate$_(e) { this.token(LeftParenthesis$1, "("), this.children(e), this.token(RightParenthesis$1, ")") } var Parentheses$1 = Object.freeze({ __proto__: null, generate: generate$_, name: name$1H, parse: parse$_, structure: structure$V }); const name$1G = "Percentage", structure$U = { value: String }; function parse$Z() { return { type: "Percentage", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consumeNumber(Percentage$3) } } function generate$Z(e) { this.token(Percentage$3, e.value + "%") } var Percentage$2 = Object.freeze({ __proto__: null, generate: generate$Z, name: name$1G, parse: parse$Z, structure: structure$U }); const name$1F = "PseudoClassSelector", walkContext$e = "function", structure$T = { name: String, children: [["Raw"], null] }; function parse$Y() { const e = this.tokenStart; let t, n, r = null; return this.eat(Colon$1), this.tokenType === Function$3 ? (t = this.consumeFunctionName(), n = t.toLowerCase(), this.lookupNonWSType(0) == RightParenthesis$1 ? r = this.createList() : hasOwnProperty.call(this.pseudo, n) ? (this.skipSC(), r = this.pseudo[n].call(this), this.skipSC()) : (r = this.createList(), r.push(this.Raw(null, !1))), this.eat(RightParenthesis$1)) : t = this.consume(Ident$1), { type: "PseudoClassSelector", loc: this.getLocation(e, this.tokenStart), name: t, children: r } } function generate$Y(e) { this.token(Colon$1, ":"), null === e.children ? this.token(Ident$1, e.name) : (this.token(Function$3, e.name + "("), this.children(e), this.token(RightParenthesis$1, ")")) } var PseudoClassSelector$1 = Object.freeze({ __proto__: null, generate: generate$Y, name: name$1F, parse: parse$Y, structure: structure$T, walkContext: "function" }); const name$1E = "PseudoElementSelector", walkContext$d = "function", structure$S = { name: String, children: [["Raw"], null] }; function parse$X() { const e = this.tokenStart; let t, n, r = null; return this.eat(Colon$1), this.eat(Colon$1), this.tokenType === Function$3 ? (t = this.consumeFunctionName(), n = t.toLowerCase(), this.lookupNonWSType(0) == RightParenthesis$1 ? r = this.createList() : hasOwnProperty.call(this.pseudo, n) ? (this.skipSC(), r = this.pseudo[n].call(this), this.skipSC()) : (r = this.createList(), r.push(this.Raw(null, !1))), this.eat(RightParenthesis$1)) : t = this.consume(Ident$1), { type: "PseudoElementSelector", loc: this.getLocation(e, this.tokenStart), name: t, children: r } } function generate$X(e) { this.token(Colon$1, ":"), this.token(Colon$1, ":"), null === e.children ? this.token(Ident$1, e.name) : (this.token(Function$3, e.name + "("), this.children(e), this.token(RightParenthesis$1, ")")) } var PseudoElementSelector$1 = Object.freeze({ __proto__: null, generate: generate$X, name: name$1E, parse: parse$X, structure: structure$S, walkContext: "function" }); const SOLIDUS$8 = 47; function consumeTerm() { switch (this.skipSC(), this.tokenType) { case Number$5: return this.Number(); case Function$3: return this.Function(this.readSequence, this.scope.Value); default: this.error("Number of function is expected") } } const name$1D = "Ratio", structure$R = { left: ["Number", "Function"], right: ["Number", "Function", null] }; function parse$W() { const e = this.tokenStart, t = consumeTerm.call(this); let n = null; return this.skipSC(), this.isDelim(47) && (this.eatDelim(47), n = consumeTerm.call(this)), { type: "Ratio", loc: this.getLocation(e, this.tokenStart), left: t, right: n } } function generate$W(e) { this.node(e.left), this.token(Delim$1, "/"), e.right ? this.node(e.right) : this.node(Number$5, 1) } var Ratio$1 = Object.freeze({ __proto__: null, generate: generate$W, name: "Ratio", parse: parse$W, structure: structure$R }); function getOffsetExcludeWS$1() { return this.tokenIndex > 0 && this.lookupType(-1) === WhiteSpace$3 ? this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset : this.tokenStart } const name$1C = "Raw", structure$Q = { value: String }; function parse$V(e, t) { const n = this.getTokenStart(this.tokenIndex); let r; return this.skipUntilBalanced(this.tokenIndex, e || this.consumeUntilBalanceEnd), r = t && this.tokenStart > n ? getOffsetExcludeWS$1.call(this) : this.tokenStart, { type: "Raw", loc: this.getLocation(n, r), value: this.substring(n, r) } } function generate$V(e) { this.tokenize(e.value) } var Raw$1 = Object.freeze({ __proto__: null, generate: generate$V, name: "Raw", parse: parse$V, structure: structure$Q }); function consumeRaw$7() { return this.Raw(this.consumeUntilLeftCurlyBracket, !0) } function consumePrelude$1() { const e = this.SelectorList(); return "Raw" !== e.type && !1 === this.eof && this.tokenType !== LeftCurlyBracket$1 && this.error(), e } const name$1B = "Rule", walkContext$c = "rule", structure$P = { prelude: ["SelectorList", "Raw"], block: ["Block"] }; function parse$U() { const e = this.tokenIndex, t = this.tokenStart; let n, r; return n = this.parseRulePrelude ? this.parseWithFallback(consumePrelude$1, consumeRaw$7) : consumeRaw$7.call(this, e), r = this.Block(!0), { type: "Rule", loc: this.getLocation(t, this.tokenStart), prelude: n, block: r } } function generate$U(e) { this.node(e.prelude), this.node(e.block) } var Rule$1 = Object.freeze({ __proto__: null, generate: generate$U, name: "Rule", parse: parse$U, structure: structure$P, walkContext: "rule" }); const name$1A = "Scope", structure$O = { root: ["SelectorList", "Raw", null], limit: ["SelectorList", "Raw", null] }; function parse$T() { let e = null, t = null; this.skipSC(); const n = this.tokenStart; return this.tokenType === LeftParenthesis$1 && (this.next(), this.skipSC(), e = this.parseWithFallback(this.SelectorList, (() => this.Raw(!1, !0))), this.skipSC(), this.eat(RightParenthesis$1)), this.lookupNonWSType(0) === Ident$1 && (this.skipSC(), this.eatIdent("to"), this.skipSC(), this.eat(LeftParenthesis$1), this.skipSC(), t = this.parseWithFallback(this.SelectorList, (() => this.Raw(!1, !0))), this.skipSC(), this.eat(RightParenthesis$1)), { type: "Scope", loc: this.getLocation(n, this.tokenStart), root: e, limit: t } } function generate$T(e) { e.root && (this.token(LeftParenthesis$1, "("), this.node(e.root), this.token(RightParenthesis$1, ")")), e.limit && (this.token(Ident$1, "to"), this.token(LeftParenthesis$1, "("), this.node(e.limit), this.token(RightParenthesis$1, ")")) } var Scope = Object.freeze({ __proto__: null, generate: generate$T, name: "Scope", parse: parse$T, structure: structure$O }); const name$1z = "Selector", structure$N = { children: [["TypeSelector", "IdSelector", "ClassSelector", "AttributeSelector", "PseudoClassSelector", "PseudoElementSelector", "Combinator"]] }; function parse$S() { const e = this.readSequence(this.scope.Selector); return null === this.getFirstListNode(e) && this.error("Selector is expected"), { type: "Selector", loc: this.getLocationFromList(e), children: e } } function generate$S(e) { this.children(e) } var Selector$1 = Object.freeze({ __proto__: null, generate: generate$S, name: name$1z, parse: parse$S, structure: structure$N }); const name$1y = "SelectorList", walkContext$b = "selector", structure$M = { children: [["Selector", "Raw"]] }; function parse$R() { const e = this.createList(); for (; !this.eof && (e.push(this.Selector()), this.tokenType === Comma$1);)this.next(); return { type: "SelectorList", loc: this.getLocationFromList(e), children: e } } function generate$R(e) { this.children(e, (() => this.token(Comma$1, ","))) } var SelectorList$1 = Object.freeze({ __proto__: null, generate: generate$R, name: name$1y, parse: parse$R, structure: structure$M, walkContext: "selector" }); const REVERSE_SOLIDUS$3 = 92, QUOTATION_MARK$3 = 34, APOSTROPHE$4 = 39; function decode$3(e) { const t = e.length, n = e.charCodeAt(0), r = n === QUOTATION_MARK$3 || n === APOSTROPHE$4 ? 1 : 0, a = 1 === r && t > 1 && e.charCodeAt(t - 1) === n ? t - 2 : t - 1; let o = ""; for (let n = r; n <= a; n++) { let r = e.charCodeAt(n); if (r === REVERSE_SOLIDUS$3) { if (n === a) { n !== t - 1 && (o = e.substr(n + 1)); break } if (r = e.charCodeAt(++n), isValidEscape$1(REVERSE_SOLIDUS$3, r)) { const t = n - 1, r = consumeEscaped$1(e, t); n = r - 1, o += decodeEscaped$1(e.substring(t + 1, r)) } else 13 === r && 10 === e.charCodeAt(n + 1) && n++ } else o += e[n] } return o } function encode$3(e, t) { const n = QUOTATION_MARK$3; let r = "", a = !1; for (let t = 0; t < e.length; t++) { const o = e.charCodeAt(t); 0 !== o ? o <= 31 || 127 === o ? (r += "\\" + o.toString(16), a = !0) : o === n || o === REVERSE_SOLIDUS$3 ? (r += "\\" + e.charAt(t), a = !1) : (a && (isHexDigit$1(o) || isWhiteSpace$2(o)) && (r += " "), r += e.charAt(t), a = !1) : r += "" } return '"' + r + '"' } const name$1x = "String", structure$L = { value: String }; function parse$Q() { return { type: "String", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: decode$3(this.consume(String$4)) } } function generate$Q(e) { this.token(String$4, encode$3(e.value)) } var String$3 = Object.freeze({ __proto__: null, generate: generate$Q, name: name$1x, parse: parse$Q, structure: structure$L }); const EXCLAMATIONMARK$4 = 33; function consumeRaw$6() { return this.Raw(null, !1) } const name$1w = "StyleSheet", walkContext$a = "stylesheet", structure$K = { children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]] }; function parse$P() { const e = this.tokenStart, t = this.createList(); let n; for (; !this.eof;) { switch (this.tokenType) { case WhiteSpace$3: this.next(); continue; case Comment$3: if (33 !== this.charCodeAt(this.tokenStart + 2)) { this.next(); continue } n = this.Comment(); break; case CDO$3: n = this.CDO(); break; case CDC$3: n = this.CDC(); break; case AtKeyword$1: n = this.parseWithFallback(this.Atrule, consumeRaw$6); break; default: n = this.parseWithFallback(this.Rule, consumeRaw$6) }t.push(n) } return { type: "StyleSheet", loc: this.getLocation(e, this.tokenStart), children: t } } function generate$P(e) { this.children(e) } var StyleSheet$1 = Object.freeze({ __proto__: null, generate: generate$P, name: name$1w, parse: parse$P, structure: structure$K, walkContext: "stylesheet" }); const name$1v = "SupportsDeclaration", structure$J = { declaration: "Declaration" }; function parse$O() { const e = this.tokenStart; this.eat(LeftParenthesis$1), this.skipSC(); const t = this.Declaration(); return this.eof || this.eat(RightParenthesis$1), { type: "SupportsDeclaration", loc: this.getLocation(e, this.tokenStart), declaration: t } } function generate$O(e) { this.token(LeftParenthesis$1, "("), this.node(e.declaration), this.token(RightParenthesis$1, ")") } var SupportsDeclaration = Object.freeze({ __proto__: null, generate: generate$O, name: name$1v, parse: parse$O, structure: structure$J }); const ASTERISK$9 = 42, VERTICALLINE$5 = 124; function eatIdentifierOrAsterisk$1() { this.tokenType !== Ident$1 && !1 === this.isDelim(ASTERISK$9) && this.error("Identifier or asterisk is expected"), this.next() } const name$1u = "TypeSelector", structure$I = { name: String }; function parse$N() { const e = this.tokenStart; return this.isDelim(124) ? (this.next(), eatIdentifierOrAsterisk$1.call(this)) : (eatIdentifierOrAsterisk$1.call(this), this.isDelim(124) && (this.next(), eatIdentifierOrAsterisk$1.call(this))), { type: "TypeSelector", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e) } } function generate$N(e) { this.tokenize(e.name) } var TypeSelector$1 = Object.freeze({ __proto__: null, generate: generate$N, name: name$1u, parse: parse$N, structure: structure$I }); const PLUSSIGN$c = 43, HYPHENMINUS$8 = 45, QUESTIONMARK$3 = 63; function eatHexSequence$1(e, t) { let n = 0; for (let r = this.tokenStart + e; r < this.tokenEnd; r++) { const a = this.charCodeAt(r); if (a === HYPHENMINUS$8 && t && 0 !== n) return eatHexSequence$1.call(this, e + n + 1, !1), -1; isHexDigit$1(a) || this.error(t && 0 !== n ? "Hyphen minus" + (n < 6 ? " or hex digit" : "") + " is expected" : n < 6 ? "Hex digit is expected" : "Unexpected input", r), ++n > 6 && this.error("Too many hex digits", r) } return this.next(), n } function eatQuestionMarkSequence$1(e) { let t = 0; for (; this.isDelim(QUESTIONMARK$3);)++t > e && this.error("Too many question marks"), this.next() } function startsWith$2(e) { this.charCodeAt(this.tokenStart) !== e && this.error((e === PLUSSIGN$c ? "Plus sign" : "Hyphen minus") + " is expected") } function scanUnicodeRange$1() { let e = 0; switch (this.tokenType) { case Number$5: if (e = eatHexSequence$1.call(this, 1, !0), this.isDelim(QUESTIONMARK$3)) { eatQuestionMarkSequence$1.call(this, 6 - e); break } if (this.tokenType === Dimension$3 || this.tokenType === Number$5) { startsWith$2.call(this, HYPHENMINUS$8), eatHexSequence$1.call(this, 1, !1); break } break; case Dimension$3: e = eatHexSequence$1.call(this, 1, !0), e > 0 && eatQuestionMarkSequence$1.call(this, 6 - e); break; default: if (this.eatDelim(PLUSSIGN$c), this.tokenType === Ident$1) { e = eatHexSequence$1.call(this, 0, !0), e > 0 && eatQuestionMarkSequence$1.call(this, 6 - e); break } if (this.isDelim(QUESTIONMARK$3)) { this.next(), eatQuestionMarkSequence$1.call(this, 5); break } this.error("Hex digit or question mark is expected") } } const name$1t = "UnicodeRange", structure$H = { value: String }; function parse$M() { const e = this.tokenStart; return this.eatIdent("u"), scanUnicodeRange$1.call(this), { type: "UnicodeRange", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e) } } function generate$M(e) { this.tokenize(e.value) } var UnicodeRange$1 = Object.freeze({ __proto__: null, generate: generate$M, name: name$1t, parse: parse$M, structure: structure$H }); const SPACE$5 = 32, REVERSE_SOLIDUS$2 = 92, QUOTATION_MARK$2 = 34, APOSTROPHE$3 = 39, LEFTPARENTHESIS$3 = 40, RIGHTPARENTHESIS$3 = 41; function decode$2(e) { const t = e.length; let n = 4, r = e.charCodeAt(t - 1) === RIGHTPARENTHESIS$3 ? t - 2 : t - 1, a = ""; for (; n < r && isWhiteSpace$2(e.charCodeAt(n));)n++; for (; n < r && isWhiteSpace$2(e.charCodeAt(r));)r--; for (let o = n; o <= r; o++) { let n = e.charCodeAt(o); if (n === REVERSE_SOLIDUS$2) { if (o === r) { o !== t - 1 && (a = e.substr(o + 1)); break } if (n = e.charCodeAt(++o), isValidEscape$1(REVERSE_SOLIDUS$2, n)) { const t = o - 1, n = consumeEscaped$1(e, t); o = n - 1, a += decodeEscaped$1(e.substring(t + 1, n)) } else 13 === n && 10 === e.charCodeAt(o + 1) && o++ } else a += e[o] } return a } function encode$2(e) { let t = "", n = !1; for (let r = 0; r < e.length; r++) { const a = e.charCodeAt(r); 0 !== a ? a <= 31 || 127 === a ? (t += "\\" + a.toString(16), n = !0) : a === SPACE$5 || a === REVERSE_SOLIDUS$2 || a === QUOTATION_MARK$2 || a === APOSTROPHE$3 || a === LEFTPARENTHESIS$3 || a === RIGHTPARENTHESIS$3 ? (t += "\\" + e.charAt(r), n = !1) : (n && isHexDigit$1(a) && (t += " "), t += e.charAt(r), n = !1) : t += "" } return "url(" + t + ")" } const name$1s = "Url", structure$G = { value: String }; function parse$L() { const e = this.tokenStart; let t; switch (this.tokenType) { case Url$4: t = decode$2(this.consume(Url$4)); break; case Function$3: this.cmpStr(this.tokenStart, this.tokenEnd, "url(") || this.error("Function name must be `url`"), this.eat(Function$3), this.skipSC(), t = decode$3(this.consume(String$4)), this.skipSC(), this.eof || this.eat(RightParenthesis$1); break; default: this.error("Url or Function is expected") }return { type: "Url", loc: this.getLocation(e, this.tokenStart), value: t } } function generate$L(e) { this.token(Url$4, encode$2(e.value)) } var Url$3 = Object.freeze({ __proto__: null, generate: generate$L, name: "Url", parse: parse$L, structure: structure$G }); const name$1r = "Value", structure$F = { children: [[]] }; function parse$K() { const e = this.tokenStart, t = this.readSequence(this.scope.Value); return { type: "Value", loc: this.getLocation(e, this.tokenStart), children: t } } function generate$K(e) { this.children(e) } var Value$1 = Object.freeze({ __proto__: null, generate: generate$K, name: "Value", parse: parse$K, structure: structure$F }); const SPACE$4 = Object.freeze({ type: "WhiteSpace", loc: null, value: " " }), name$1q = "WhiteSpace", structure$E = { value: String }; function parse$J() { return this.eat(WhiteSpace$3), SPACE$4 } function generate$J(e) { this.token(WhiteSpace$3, e.value) } var WhiteSpace$2 = Object.freeze({ __proto__: null, generate: generate$J, name: name$1q, parse: parse$J, structure: structure$E }), node$3 = Object.freeze({ __proto__: null, AnPlusB: AnPlusB$1, Atrule: Atrule$2, AtrulePrelude: AtrulePrelude$1, AttributeSelector: AttributeSelector$2, Block: Block$1, Brackets: Brackets$1, CDC: CDC$2, CDO: CDO$2, ClassSelector: ClassSelector$1, Combinator: Combinator$1, Comment: Comment$2, Condition: Condition, Declaration: Declaration$1, DeclarationList: DeclarationList$1, Dimension: Dimension$2, Feature: Feature, FeatureFunction: FeatureFunction, FeatureRange: FeatureRange, Function: Function$2, GeneralEnclosed: GeneralEnclosed, Hash: Hash$2, IdSelector: IdSelector$1, Identifier: Identifier$1, Layer: Layer, LayerList: LayerList, MediaQuery: MediaQuery$1, MediaQueryList: MediaQueryList$1, NestingSelector: NestingSelector, Nth: Nth$1, Number: Number$4, Operator: Operator$1, Parentheses: Parentheses$1, Percentage: Percentage$2, PseudoClassSelector: PseudoClassSelector$1, PseudoElementSelector: PseudoElementSelector$1, Ratio: Ratio$1, Raw: Raw$1, Rule: Rule$1, Scope: Scope, Selector: Selector$1, SelectorList: SelectorList$1, String: String$3, StyleSheet: StyleSheet$1, SupportsDeclaration: SupportsDeclaration, TypeSelector: TypeSelector$1, UnicodeRange: UnicodeRange$1, Url: Url$3, Value: Value$1, WhiteSpace: WhiteSpace$2 }), lexerConfig$1 = { generic: !0, cssWideKeywords: cssWideKeywords$1, ...definitions$1, node: node$3 }; const NUMBERSIGN$6 = 35, ASTERISK$8 = 42, PLUSSIGN$b = 43, HYPHENMINUS$7 = 45, SOLIDUS$7 = 47, U$2 = 117; function defaultRecognizer$1(e) { switch (this.tokenType) { case Hash$3: return this.Hash(); case Comma$1: return this.Operator(); case LeftParenthesis$1: return this.Parentheses(this.readSequence, e.recognizer); case LeftSquareBracket$1: return this.Brackets(this.readSequence, e.recognizer); case String$4: return this.String(); case Dimension$3: return this.Dimension(); case Percentage$3: return this.Percentage(); case Number$5: return this.Number(); case Function$3: return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, e.recognizer); case Url$4: return this.Url(); case Ident$1: return this.cmpChar(this.tokenStart, 117) && this.cmpChar(this.tokenStart + 1, 43) ? this.UnicodeRange() : this.Identifier(); case Delim$1: { const e = this.charCodeAt(this.tokenStart); if (47 === e || 42 === e || 43 === e || 45 === e) return this.Operator(); 35 === e && this.error("Hex or identifier is expected", this.tokenStart + 1); break } } } var atrulePrelude$1 = { getNode: defaultRecognizer$1 }; const NUMBERSIGN$5 = 35, AMPERSAND$2 = 38, ASTERISK$7 = 42, PLUSSIGN$a = 43, SOLIDUS$6 = 47, FULLSTOP$3 = 46, GREATERTHANSIGN$3 = 62, VERTICALLINE$4 = 124, TILDE$3 = 126; function onWhiteSpace$1(e, t) { null !== t.last && "Combinator" !== t.last.type && null !== e && "Combinator" !== e.type && t.push({ type: "Combinator", loc: null, name: " " }) } function getNode$1() { switch (this.tokenType) { case LeftSquareBracket$1: return this.AttributeSelector(); case Hash$3: return this.IdSelector(); case Colon$1: return this.lookupType(1) === Colon$1 ? this.PseudoElementSelector() : this.PseudoClassSelector(); case Ident$1: return this.TypeSelector(); case Number$5: case Percentage$3: return this.Percentage(); case Dimension$3: 46 === this.charCodeAt(this.tokenStart) && this.error("Identifier is expected", this.tokenStart + 1); break; case Delim$1: switch (this.charCodeAt(this.tokenStart)) { case 43: case 62: case 126: case 47: return this.Combinator(); case 46: return this.ClassSelector(); case 42: case 124: return this.TypeSelector(); case 35: return this.IdSelector(); case 38: return this.NestingSelector() }break } } var selector$3 = { onWhiteSpace: onWhiteSpace$1, getNode: getNode$1 }; function expressionFn$1() { return this.createSingleNodeList(this.Raw(null, !1)) } function varFn$1() { const e = this.createList(); if (this.skipSC(), e.push(this.Identifier()), this.skipSC(), this.tokenType === Comma$1) { e.push(this.Operator()); const t = this.tokenIndex, n = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, !1); if ("Value" === n.type && n.children.isEmpty) for (let e = t - this.tokenIndex; e <= 0; e++)if (this.lookupType(e) === WhiteSpace$3) { n.children.appendData({ type: "WhiteSpace", loc: null, value: " " }); break } e.push(n) } return e } function isPlusMinusOperator$1(e) { return null !== e && "Operator" === e.type && ("-" === e.value[e.value.length - 1] || "+" === e.value[e.value.length - 1]) } var value$1 = { getNode: defaultRecognizer$1, onWhiteSpace(e, t) { isPlusMinusOperator$1(e) && (e.value = " " + e.value), isPlusMinusOperator$1(t.last) && (t.last.value += " ") }, expression: expressionFn$1, var: varFn$1 }, scope$2 = Object.freeze({ __proto__: null, AtrulePrelude: atrulePrelude$1, Selector: selector$3, Value: value$1 }); const nonContainerNameKeywords = new Set(["none", "and", "not", "or"]); var container = { parse: { prelude() { const e = this.createList(); if (this.tokenType === Ident$1) { const t = this.substring(this.tokenStart, this.tokenEnd); nonContainerNameKeywords.has(t.toLowerCase()) || e.push(this.Identifier()) } return e.push(this.Condition("container")), e }, block(e = !1) { return this.Block(e) } } }, fontFace$1 = { parse: { prelude: null, block() { return this.Block(!0) } } }; function parseWithFallback(e, t) { return this.parseWithFallback((() => { try { return e.call(this) } finally { this.skipSC(), this.lookupNonWSType(0) !== RightParenthesis$1 && this.error() } }), t || (() => this.Raw(null, !0))) } const parseFunctions = { layer() { this.skipSC(); const e = this.createList(), t = parseWithFallback.call(this, this.Layer); return "Raw" === t.type && "" === t.value || e.push(t), e }, supports() { this.skipSC(); const e = this.createList(), t = parseWithFallback.call(this, this.Declaration, (() => parseWithFallback.call(this, (() => this.Condition("supports"))))); return "Raw" === t.type && "" === t.value || e.push(t), e } }; var importAtrule$1 = { parse: { prelude() { const e = this.createList(); switch (this.tokenType) { case String$4: e.push(this.String()); break; case Url$4: case Function$3: e.push(this.Url()); break; default: this.error("String or url() is expected") }return this.skipSC(), this.tokenType === Ident$1 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer") ? e.push(this.Identifier()) : this.tokenType === Function$3 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(") && e.push(this.Function(null, parseFunctions)), this.skipSC(), this.tokenType === Function$3 && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(") && e.push(this.Function(null, parseFunctions)), this.lookupNonWSType(0) !== Ident$1 && this.lookupNonWSType(0) !== LeftParenthesis$1 || e.push(this.MediaQueryList()), e }, block: null } }, layer = { parse: { prelude() { return this.createSingleNodeList(this.LayerList()) }, block() { return this.Block(!1) } } }, media$1 = { parse: { prelude() { return this.createSingleNodeList(this.MediaQueryList()) }, block(e = !1) { return this.Block(e) } } }, nest = { parse: { prelude() { return this.createSingleNodeList(this.SelectorList()) }, block() { return this.Block(!0) } } }, page$1 = { parse: { prelude() { return this.createSingleNodeList(this.SelectorList()) }, block() { return this.Block(!0) } } }, scope$1 = { parse: { prelude() { return this.createSingleNodeList(this.Scope()) }, block(e = !1) { return this.Block(e) } } }, startingStyle = { parse: { prelude: null, block(e = !1) { return this.Block(e) } } }, supports$1 = { parse: { prelude() { return this.createSingleNodeList(this.Condition("supports")) }, block(e = !1) { return this.Block(e) } } }, atrule$1 = { container: container, "font-face": fontFace$1, import: importAtrule$1, layer: layer, media: media$1, nest: nest, page: page$1, scope: scope$1, "starting-style": startingStyle, supports: supports$1 }; function parseLanguageRangeList() { const e = this.createList(); this.skipSC(); e: for (; !this.eof;) { switch (this.tokenType) { case Ident$1: e.push(this.Identifier()); break; case String$4: e.push(this.String()); break; case Comma$1: e.push(this.Operator()); break; case RightParenthesis$1: break e; default: this.error("Identifier, string or comma is expected") }this.skipSC() } return e } const selectorList$1 = { parse() { return this.createSingleNodeList(this.SelectorList()) } }, selector$2 = { parse() { return this.createSingleNodeList(this.Selector()) } }, identList$1 = { parse() { return this.createSingleNodeList(this.Identifier()) } }, langList = { parse: parseLanguageRangeList }, nth$1 = { parse() { return this.createSingleNodeList(this.Nth()) } }; var pseudo$1 = { dir: identList$1, has: selectorList$1, lang: langList, matches: selectorList$1, is: selectorList$1, "-moz-any": selectorList$1, "-webkit-any": selectorList$1, where: selectorList$1, not: selectorList$1, "nth-child": nth$1, "nth-last-child": nth$1, "nth-last-of-type": nth$1, "nth-of-type": nth$1, slotted: selector$2, host: selector$2, "host-context": selector$2 }, node$2 = Object.freeze({ __proto__: null, AnPlusB: parse$1t, Atrule: parse$1s, AtrulePrelude: parse$1r, AttributeSelector: parse$1q, Block: parse$1p, Brackets: parse$1o, CDC: parse$1n, CDO: parse$1m, ClassSelector: parse$1l, Combinator: parse$1k, Comment: parse$1j, Condition: parse$1i, Declaration: parse$1h, DeclarationList: parse$1g, Dimension: parse$1f, Feature: parse$1e, FeatureFunction: parse$1d, FeatureRange: parse$1c, Function: parse$1b, GeneralEnclosed: parse$1a, Hash: parse$19, IdSelector: parse$17, Identifier: parse$18, Layer: parse$16, LayerList: parse$15, MediaQuery: parse$14, MediaQueryList: parse$13, NestingSelector: parse$12, Nth: parse$11, Number: parse$10, Operator: parse$$, Parentheses: parse$_, Percentage: parse$Z, PseudoClassSelector: parse$Y, PseudoElementSelector: parse$X, Ratio: parse$W, Raw: parse$V, Rule: parse$U, Scope: parse$T, Selector: parse$S, SelectorList: parse$R, String: parse$Q, StyleSheet: parse$P, SupportsDeclaration: parse$O, TypeSelector: parse$N, UnicodeRange: parse$M, Url: parse$L, Value: parse$K, WhiteSpace: parse$J }), parserConfig$1 = { parseContext: { default: "StyleSheet", stylesheet: "StyleSheet", atrule: "Atrule", atrulePrelude(e) { return this.AtrulePrelude(e.atrule ? String(e.atrule) : null) }, mediaQueryList: "MediaQueryList", mediaQuery: "MediaQuery", condition(e) { return this.Condition(e.kind) }, rule: "Rule", selectorList: "SelectorList", selector: "Selector", block() { return this.Block(!0) }, declarationList: "DeclarationList", declaration: "Declaration", value: "Value" }, features: { supports: { selector() { return this.Selector() } }, container: { style() { return this.Declaration() } } }, scope: scope$2, atrule: atrule$1, pseudo: pseudo$1, node: node$2 }, walkerConfig$1 = { node: node$3 }, syntax$2 = createSyntax$3({ ...lexerConfig$1, ...parserConfig$1, ...walkerConfig$1 }); function clone$1(e) { const t = {}; for (const n of Object.keys(e)) { let r = e[n]; r && (Array.isArray(r) || r instanceof List$1 ? r = r.map(clone$1) : r.constructor === Object && (r = clone$1(r))), t[n] = r } return t } const { tokenize: tokenize$3, parse: parse$I, generate: generate$I, lexer: lexer$2, createLexer: createLexer$1, walk: walk$3, find: find$2, findLast: findLast$2, findAll: findAll$2, toPlainObject: toPlainObject$2, fromPlainObject: fromPlainObject$2, fork: fork$1 } = syntax$2, EOF$1 = 0, Ident = 1, Function$1 = 2, AtKeyword = 3, Hash$1 = 4, String$2 = 5, BadString = 6, Url$2 = 7, BadUrl = 8, Delim = 9, Number$3 = 10, Percentage$1 = 11, Dimension$1 = 12, WhiteSpace$1 = 13, CDO$1 = 14, CDC$1 = 15, Colon = 16, Semicolon = 17, Comma = 18, LeftSquareBracket = 19, RightSquareBracket = 20, LeftParenthesis = 21, RightParenthesis = 22, LeftCurlyBracket = 23, RightCurlyBracket = 24, Comment$1 = 25, EOF = 0; function isDigit$1(e) { return e >= 48 && e <= 57 } function isHexDigit(e) { return isDigit$1(e) || e >= 65 && e <= 70 || e >= 97 && e <= 102 } function isUppercaseLetter(e) { return e >= 65 && e <= 90 } function isLowercaseLetter(e) { return e >= 97 && e <= 122 } function isLetter(e) { return isUppercaseLetter(e) || isLowercaseLetter(e) } function isNonAscii(e) { return e >= 128 } function isNameStart(e) { return isLetter(e) || isNonAscii(e) || 95 === e } function isName(e) { return isNameStart(e) || isDigit$1(e) || 45 === e } function isNonPrintable(e) { return e >= 0 && e <= 8 || 11 === e || e >= 14 && e <= 31 || 127 === e } function isNewline(e) { return 10 === e || 13 === e || 12 === e } function isWhiteSpace$1(e) { return isNewline(e) || 32 === e || 9 === e } function isValidEscape(e, t) { return 92 === e && (!isNewline(t) && t !== EOF) } function isIdentifierStart(e, t, n) { return 45 === e ? isNameStart(t) || 45 === t || isValidEscape(t, n) : !!isNameStart(e) || 92 === e && isValidEscape(e, t) } function isNumberStart(e, t, n) { return 43 === e || 45 === e ? isDigit$1(t) ? 2 : 46 === t && isDigit$1(n) ? 3 : 0 : 46 === e ? isDigit$1(t) ? 2 : 0 : isDigit$1(e) ? 1 : 0 } function isBOM(e) { return 65279 === e || 65534 === e ? 1 : 0 } const CATEGORY = new Array(128), EofCategory = 128, WhiteSpaceCategory = 130, DigitCategory = 131, NameStartCategory = 132, NonPrintableCategory = 133; for (let e = 0; e < CATEGORY.length; e++)CATEGORY[e] = isWhiteSpace$1(e) && WhiteSpaceCategory || isDigit$1(e) && DigitCategory || isNameStart(e) && NameStartCategory || isNonPrintable(e) && NonPrintableCategory || e || 128; function charCodeCategory(e) { return e < 128 ? CATEGORY[e] : NameStartCategory } function getCharCode(e, t) { return t < e.length ? e.charCodeAt(t) : 0 } function getNewlineLength(e, t, n) { return 13 === n && 10 === getCharCode(e, t + 1) ? 2 : 1 } function cmpChar(e, t, n) { let r = e.charCodeAt(t); return isUppercaseLetter(r) && (r |= 32), r === n } function cmpStr(e, t, n, r) { if (n - t !== r.length) return !1; if (t < 0 || n > e.length) return !1; for (let a = t; a < n; a++) { const n = r.charCodeAt(a - t); let o = e.charCodeAt(a); if (isUppercaseLetter(o) && (o |= 32), o !== n) return !1 } return !0 } function findWhiteSpaceStart(e, t) { for (; t >= 0 && isWhiteSpace$1(e.charCodeAt(t)); t--); return t + 1 } function findWhiteSpaceEnd(e, t) { for (; t < e.length && isWhiteSpace$1(e.charCodeAt(t)); t++); return t } function findDecimalNumberEnd(e, t) { for (; t < e.length && isDigit$1(e.charCodeAt(t)); t++); return t } function consumeEscaped(e, t) { if (isHexDigit(getCharCode(e, (t += 2) - 1))) { for (const n = Math.min(e.length, t + 5); t < n && isHexDigit(getCharCode(e, t)); t++); const n = getCharCode(e, t); isWhiteSpace$1(n) && (t += getNewlineLength(e, t, n)) } return t } function consumeName(e, t) { for (; t < e.length; t++) { const n = e.charCodeAt(t); if (!isName(n)) { if (!isValidEscape(n, getCharCode(e, t + 1))) break; t = consumeEscaped(e, t) - 1 } } return t } function consumeNumber$1(e, t) { let n = e.charCodeAt(t); if (43 !== n && 45 !== n || (n = e.charCodeAt(t += 1)), isDigit$1(n) && (t = findDecimalNumberEnd(e, t + 1), n = e.charCodeAt(t)), 46 === n && isDigit$1(e.charCodeAt(t + 1)) && (t = findDecimalNumberEnd(e, t += 2)), cmpChar(e, t, 101)) { let r = 0; n = e.charCodeAt(t + 1), 45 !== n && 43 !== n || (r = 1, n = e.charCodeAt(t + 2)), isDigit$1(n) && (t = findDecimalNumberEnd(e, t + 1 + r + 1)) } return t } function consumeBadUrlRemnants(e, t) { for (; t < e.length; t++) { const n = e.charCodeAt(t); if (41 === n) { t++; break } isValidEscape(n, getCharCode(e, t + 1)) && (t = consumeEscaped(e, t)) } return t } function decodeEscaped(e) { if (1 === e.length && !isHexDigit(e.charCodeAt(0))) return e[0]; let t = parseInt(e, 16); return (0 === t || t >= 55296 && t <= 57343 || t > 1114111) && (t = 65533), String.fromCodePoint(t) } var tokenNames = ["EOF-token", "ident-token", "function-token", "at-keyword-token", "hash-token", "string-token", "bad-string-token", "url-token", "bad-url-token", "delim-token", "number-token", "percentage-token", "dimension-token", "whitespace-token", "CDO-token", "CDC-token", "colon-token", "semicolon-token", "comma-token", "[-token", "]-token", "(-token", ")-token", "{-token", "}-token"]; const MIN_SIZE = 16384; function adoptBuffer(e = null, t) { return null === e || e.length < t ? new Uint32Array(Math.max(t + 1024, MIN_SIZE)) : e } const N$4 = 10, F$2 = 12, R$2 = 13; function computeLinesAndColumns(e) { const t = e.source, n = t.length, r = t.length > 0 ? isBOM(t.charCodeAt(0)) : 0, a = adoptBuffer(e.lines, n), o = adoptBuffer(e.columns, n); let i = e.startLine, s = e.startColumn; for (let e = r; e < n; e++) { const r = t.charCodeAt(e); a[e] = i, o[e] = s++, 10 !== r && 13 !== r && 12 !== r || (13 === r && e + 1 < n && 10 === t.charCodeAt(e + 1) && (e++, a[e] = i, o[e] = s), i++, s = 1) } a[n] = i, o[n] = s, e.lines = a, e.columns = o, e.computed = !0 } class OffsetToLocation { constructor() { this.lines = null, this.columns = null, this.computed = !1 } setSource(e, t = 0, n = 1, r = 1) { this.source = e, this.startOffset = t, this.startLine = n, this.startColumn = r, this.computed = !1 } getLocation(e, t) { return this.computed || computeLinesAndColumns(this), { source: t, offset: this.startOffset + e, line: this.lines[e], column: this.columns[e] } } getLocationRange(e, t, n) { return this.computed || computeLinesAndColumns(this), { source: n, start: { offset: this.startOffset + e, line: this.lines[e], column: this.columns[e] }, end: { offset: this.startOffset + t, line: this.lines[t], column: this.columns[t] } } } } const OFFSET_MASK = 16777215, TYPE_SHIFT = 24, balancePair$1 = new Map([[Function$1, RightParenthesis], [LeftParenthesis, RightParenthesis], [LeftSquareBracket, RightSquareBracket], [LeftCurlyBracket, RightCurlyBracket]]); class TokenStream { constructor(e, t) { this.setSource(e, t) } reset() { this.eof = !1, this.tokenIndex = -1, this.tokenType = 0, this.tokenStart = this.firstCharOffset, this.tokenEnd = this.firstCharOffset } setSource(e = "", t = (() => { })) { const n = (e = String(e || "")).length, r = adoptBuffer(this.offsetAndType, e.length + 1), a = adoptBuffer(this.balance, e.length + 1); let o = 0, i = 0, s = 0, l = -1; for (this.offsetAndType = null, this.balance = null, t(e, ((e, t, c) => { switch (e) { default: a[o] = n; break; case i: { let e = 16777215 & s; for (s = a[e], i = s >> 24, a[o] = e, a[e++] = o; e < o; e++)a[e] === n && (a[e] = o); break } case LeftParenthesis: case Function$1: case LeftSquareBracket: case LeftCurlyBracket: a[o] = s, i = balancePair$1.get(e), s = i << 24 | o }r[o++] = e << 24 | c, -1 === l && (l = t) })), r[o] = 0 | n, a[o] = n, a[n] = n; 0 !== s;) { const e = 16777215 & s; s = a[e], a[e] = n } this.source = e, this.firstCharOffset = -1 === l ? 0 : l, this.tokenCount = o, this.offsetAndType = r, this.balance = a, this.reset(), this.next() } lookupType(e) { return (e += this.tokenIndex) < this.tokenCount ? this.offsetAndType[e] >> 24 : 0 } lookupOffset(e) { return (e += this.tokenIndex) < this.tokenCount ? 16777215 & this.offsetAndType[e - 1] : this.source.length } lookupValue(e, t) { return (e += this.tokenIndex) < this.tokenCount && cmpStr(this.source, 16777215 & this.offsetAndType[e - 1], 16777215 & this.offsetAndType[e], t) } getTokenStart(e) { return e === this.tokenIndex ? this.tokenStart : e > 0 ? e < this.tokenCount ? 16777215 & this.offsetAndType[e - 1] : 16777215 & this.offsetAndType[this.tokenCount] : this.firstCharOffset } substrToCursor(e) { return this.source.substring(e, this.tokenStart) } isBalanceEdge(e) { return this.balance[this.tokenIndex] < e } isDelim(e, t) { return t ? this.lookupType(t) === Delim && this.source.charCodeAt(this.lookupOffset(t)) === e : this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === e } skip(e) { let t = this.tokenIndex + e; t < this.tokenCount ? (this.tokenIndex = t, this.tokenStart = 16777215 & this.offsetAndType[t - 1], t = this.offsetAndType[t], this.tokenType = t >> 24, this.tokenEnd = 16777215 & t) : (this.tokenIndex = this.tokenCount, this.next()) } next() { let e = this.tokenIndex + 1; e < this.tokenCount ? (this.tokenIndex = e, this.tokenStart = this.tokenEnd, e = this.offsetAndType[e], this.tokenType = e >> 24, this.tokenEnd = 16777215 & e) : (this.eof = !0, this.tokenIndex = this.tokenCount, this.tokenType = 0, this.tokenStart = this.tokenEnd = this.source.length) } skipSC() { for (; this.tokenType === WhiteSpace$1 || this.tokenType === Comment$1;)this.next() } skipUntilBalanced(e, t) { let n, r, a = e; e: for (; a < this.tokenCount && (n = this.balance[a], !(n < e)); a++)switch (r = a > 0 ? 16777215 & this.offsetAndType[a - 1] : this.firstCharOffset, t(this.source.charCodeAt(r))) { case 1: break e; case 2: a++; break e; default: this.balance[n] === a && (a = n) }this.skip(a - this.tokenIndex) } forEachToken(e) { for (let t = 0, n = this.firstCharOffset; t < this.tokenCount; t++) { const r = n, a = this.offsetAndType[t], o = 16777215 & a; n = o, e(a >> 24, r, o, t) } } dump() { const e = new Array(this.tokenCount); return this.forEachToken(((t, n, r, a) => { e[a] = { idx: a, type: tokenNames[t], chunk: this.source.substring(n, r), balance: this.balance[a] } })), e } } function tokenize$2(e, t) { function n(t) { return t < i ? e.charCodeAt(t) : 0 } function r() { return c = consumeNumber$1(e, c), isIdentifierStart(n(c), n(c + 1), n(c + 2)) ? (s = Dimension$1, void (c = consumeName(e, c))) : 37 === n(c) ? (s = Percentage$1, void c++) : void (s = Number$3) } function a() { const t = c; return c = consumeName(e, c), cmpStr(e, t, c, "url") && 40 === n(c) ? (c = findWhiteSpaceEnd(e, c + 1), 34 === n(c) || 39 === n(c) ? (s = Function$1, void (c = t + 4)) : void function () { for (s = Url$2, c = findWhiteSpaceEnd(e, c); c < e.length; c++) { const t = e.charCodeAt(c); switch (charCodeCategory(t)) { case 41: return void c++; case WhiteSpaceCategory: return c = findWhiteSpaceEnd(e, c), 41 === n(c) || c >= e.length ? void (c < e.length && c++) : (c = consumeBadUrlRemnants(e, c), void (s = BadUrl)); case 34: case 39: case 40: case NonPrintableCategory: return c = consumeBadUrlRemnants(e, c), void (s = BadUrl); case 92: if (isValidEscape(t, n(c + 1))) { c = consumeEscaped(e, c) - 1; break } return c = consumeBadUrlRemnants(e, c), void (s = BadUrl) } } }()) : 40 === n(c) ? (s = Function$1, void c++) : void (s = Ident) } function o(t) { for (t || (t = n(c++)), s = String$2; c < e.length; c++) { const r = e.charCodeAt(c); switch (charCodeCategory(r)) { case t: return void c++; case WhiteSpaceCategory: if (isNewline(r)) return c += getNewlineLength(e, c, r), void (s = BadString); break; case 92: if (c === e.length - 1) break; const a = n(c + 1); isNewline(a) ? c += getNewlineLength(e, c + 1, a) : isValidEscape(r, a) && (c = consumeEscaped(e, c) - 1) } } } const i = (e = String(e || "")).length; let s, l = isBOM(n(0)), c = l; for (; c < i;) { const i = e.charCodeAt(c); switch (charCodeCategory(i)) { case WhiteSpaceCategory: s = WhiteSpace$1, c = findWhiteSpaceEnd(e, c + 1); break; case 34: o(); break; case 35: isName(n(c + 1)) || isValidEscape(n(c + 1), n(c + 2)) ? (s = Hash$1, c = consumeName(e, c + 1)) : (s = Delim, c++); break; case 39: o(); break; case 40: s = LeftParenthesis, c++; break; case 41: s = RightParenthesis, c++; break; case 43: isNumberStart(i, n(c + 1), n(c + 2)) ? r() : (s = Delim, c++); break; case 44: s = Comma, c++; break; case 45: isNumberStart(i, n(c + 1), n(c + 2)) ? r() : 45 === n(c + 1) && 62 === n(c + 2) ? (s = CDC$1, c += 3) : isIdentifierStart(i, n(c + 1), n(c + 2)) ? a() : (s = Delim, c++); break; case 46: isNumberStart(i, n(c + 1), n(c + 2)) ? r() : (s = Delim, c++); break; case 47: 42 === n(c + 1) ? (s = Comment$1, c = e.indexOf("*/", c + 2), c = -1 === c ? e.length : c + 2) : (s = Delim, c++); break; case 58: s = Colon, c++; break; case 59: s = Semicolon, c++; break; case 60: 33 === n(c + 1) && 45 === n(c + 2) && 45 === n(c + 3) ? (s = CDO$1, c += 4) : (s = Delim, c++); break; case 64: isIdentifierStart(n(c + 1), n(c + 2), n(c + 3)) ? (s = AtKeyword, c = consumeName(e, c + 1)) : (s = Delim, c++); break; case 91: s = LeftSquareBracket, c++; break; case 92: isValidEscape(i, n(c + 1)) ? a() : (s = Delim, c++); break; case 93: s = RightSquareBracket, c++; break; case 123: s = LeftCurlyBracket, c++; break; case 125: s = RightCurlyBracket, c++; break; case DigitCategory: r(); break; case NameStartCategory: a(); break; default: s = Delim, c++ }t(s, l, l = c) } } let releasedCursors = null; class List { static createItem(e) { return { prev: null, next: null, data: e } } constructor() { this.head = null, this.tail = null, this.cursor = null } createItem(e) { return List.createItem(e) } allocateCursor(e, t) { let n; return null !== releasedCursors ? (n = releasedCursors, releasedCursors = releasedCursors.cursor, n.prev = e, n.next = t, n.cursor = this.cursor) : n = { prev: e, next: t, cursor: this.cursor }, this.cursor = n, n } releaseCursor() { const { cursor: e } = this; this.cursor = e.cursor, e.prev = null, e.next = null, e.cursor = releasedCursors, releasedCursors = e } updateCursors(e, t, n, r) { let { cursor: a } = this; for (; null !== a;)a.prev === e && (a.prev = t), a.next === n && (a.next = r), a = a.cursor } *[Symbol.iterator]() { for (let e = this.head; null !== e; e = e.next)yield e.data } get size() { let e = 0; for (let t = this.head; null !== t; t = t.next)e++; return e } get isEmpty() { return null === this.head } get first() { return this.head && this.head.data } get last() { return this.tail && this.tail.data } fromArray(e) { let t = null; this.head = null; for (let n of e) { const e = List.createItem(n); null !== t ? t.next = e : this.head = e, e.prev = t, t = e } return this.tail = t, this } toArray() { return [...this] } toJSON() { return [...this] } forEach(e, t = this) { const n = this.allocateCursor(null, this.head); for (; null !== n.next;) { const r = n.next; n.next = r.next, e.call(t, r.data, r, this) } this.releaseCursor() } forEachRight(e, t = this) { const n = this.allocateCursor(this.tail, null); for (; null !== n.prev;) { const r = n.prev; n.prev = r.prev, e.call(t, r.data, r, this) } this.releaseCursor() } reduce(e, t, n = this) { let r, a = this.allocateCursor(null, this.head), o = t; for (; null !== a.next;)r = a.next, a.next = r.next, o = e.call(n, o, r.data, r, this); return this.releaseCursor(), o } reduceRight(e, t, n = this) { let r, a = this.allocateCursor(this.tail, null), o = t; for (; null !== a.prev;)r = a.prev, a.prev = r.prev, o = e.call(n, o, r.data, r, this); return this.releaseCursor(), o } some(e, t = this) { for (let n = this.head; null !== n; n = n.next)if (e.call(t, n.data, n, this)) return !0; return !1 } map(e, t = this) { const n = new List; for (let r = this.head; null !== r; r = r.next)n.appendData(e.call(t, r.data, r, this)); return n } filter(e, t = this) { const n = new List; for (let r = this.head; null !== r; r = r.next)e.call(t, r.data, r, this) && n.appendData(r.data); return n } nextUntil(e, t, n = this) { if (null === e) return; const r = this.allocateCursor(null, e); for (; null !== r.next;) { const e = r.next; if (r.next = e.next, t.call(n, e.data, e, this)) break } this.releaseCursor() } prevUntil(e, t, n = this) { if (null === e) return; const r = this.allocateCursor(e, null); for (; null !== r.prev;) { const e = r.prev; if (r.prev = e.prev, t.call(n, e.data, e, this)) break } this.releaseCursor() } clear() { this.head = null, this.tail = null } copy() { const e = new List; for (let t of this) e.appendData(t); return e } prepend(e) { return this.updateCursors(null, e, this.head, e), null !== this.head ? (this.head.prev = e, e.next = this.head) : this.tail = e, this.head = e, this } prependData(e) { return this.prepend(List.createItem(e)) } append(e) { return this.insert(e) } appendData(e) { return this.insert(List.createItem(e)) } insert(e, t = null) { if (null !== t) if (this.updateCursors(t.prev, e, t, e), null === t.prev) { if (this.head !== t) throw new Error("before doesn't belong to list"); this.head = e, t.prev = e, e.next = t, this.updateCursors(null, e) } else t.prev.next = e, e.prev = t.prev, t.prev = e, e.next = t; else this.updateCursors(this.tail, e, null, e), null !== this.tail ? (this.tail.next = e, e.prev = this.tail) : this.head = e, this.tail = e; return this } insertData(e, t) { return this.insert(List.createItem(e), t) } remove(e) { if (this.updateCursors(e, e.prev, e, e.next), null !== e.prev) e.prev.next = e.next; else { if (this.head !== e) throw new Error("item doesn't belong to list"); this.head = e.next } if (null !== e.next) e.next.prev = e.prev; else { if (this.tail !== e) throw new Error("item doesn't belong to list"); this.tail = e.prev } return e.prev = null, e.next = null, e } push(e) { this.insert(List.createItem(e)) } pop() { return null !== this.tail ? this.remove(this.tail) : null } unshift(e) { this.prepend(List.createItem(e)) } shift() { return null !== this.head ? this.remove(this.head) : null } prependList(e) { return this.insertList(e, this.head) } appendList(e) { return this.insertList(e) } insertList(e, t) { return null === e.head || (null != t ? (this.updateCursors(t.prev, e.tail, t, e.head), null !== t.prev ? (t.prev.next = e.head, e.head.prev = t.prev) : this.head = e.head, t.prev = e.tail, e.tail.next = t) : (this.updateCursors(this.tail, e.tail, null, e.head), null !== this.tail ? (this.tail.next = e.head, e.head.prev = this.tail) : this.head = e.head, this.tail = e.tail), e.head = null, e.tail = null), this } replace(e, t) { "head" in t ? this.insertList(t, e) : this.insert(t, e), this.remove(e) } } function createCustomError(e, t) { const n = Object.create(SyntaxError.prototype), r = new Error; return Object.assign(n, { name: e, message: t, get stack() { return (r.stack || "").replace(/^(.+\n){1,3}/, `${e}: ${t}\n`) } }) } const MAX_LINE_LENGTH = 100, OFFSET_CORRECTION = 60, TAB_REPLACEMENT = "    "; function sourceFragment({ source: e, line: t, column: n }, r) { function a(e, t) { return o.slice(e, t).map(((t, n) => String(e + n + 1).padStart(l) + " |" + t)).join("\n") } const o = e.split(/\r\n?|\n|\f/), i = Math.max(1, t - r) - 1, s = Math.min(t + r, o.length + 1), l = Math.max(4, String(s).length) + 1; let c = 0; (n += (TAB_REPLACEMENT.length - 1) * (o[t - 1].substr(0, n - 1).match(/\t/g) || []).length) > MAX_LINE_LENGTH && (c = n - OFFSET_CORRECTION + 3, n = OFFSET_CORRECTION - 2); for (let e = i; e <= s; e++)e >= 0 && e < o.length && (o[e] = o[e].replace(/\t/g, TAB_REPLACEMENT), o[e] = (c > 0 && o[e].length > c ? "" : "") + o[e].substr(c, MAX_LINE_LENGTH - 2) + (o[e].length > c + MAX_LINE_LENGTH - 1 ? "" : "")); return [a(i, t), new Array(n + l + 2).join("-") + "^", a(t, s)].filter(Boolean).join("\n") } function SyntaxError$2(e, t, n, r, a) { return Object.assign(createCustomError("SyntaxError", e), { source: t, offset: n, line: r, column: a, sourceFragment: e => sourceFragment({ source: t, line: r, column: a }, isNaN(e) ? 0 : e), get formattedMessage() { return `Parse error: ${e}\n` + sourceFragment({ source: t, line: r, column: a }, 2) } }) } function readSequence$1(e) { const t = this.createList(); let n = !1; const r = { recognizer: e }; for (; !this.eof;) { switch (this.tokenType) { case Comment$1: this.next(); continue; case WhiteSpace$1: n = !0, this.next(); continue }let a = e.getNode.call(this, r); if (void 0 === a) break; n && (e.onWhiteSpace && e.onWhiteSpace.call(this, a, t, r), n = !1), t.push(a) } return n && e.onWhiteSpace && e.onWhiteSpace.call(this, null, t, r), t } const NOOP = () => { }, EXCLAMATIONMARK$3 = 33, NUMBERSIGN$4 = 35, SEMICOLON = 59, LEFTCURLYBRACKET$1 = 123, NULL = 0; function createParseContext(e) { return function () { return this[e]() } } function fetchParseValues(e) { const t = Object.create(null); for (const n in e) { const r = e[n], a = r.parse || r; a && (t[n] = a) } return t } function processConfig(e) { const t = { context: Object.create(null), scope: Object.assign(Object.create(null), e.scope), atrule: fetchParseValues(e.atrule), pseudo: fetchParseValues(e.pseudo), node: fetchParseValues(e.node) }; for (const n in e.parseContext) switch (typeof e.parseContext[n]) { case "function": t.context[n] = e.parseContext[n]; break; case "string": t.context[n] = createParseContext(e.parseContext[n]) }return { config: t, ...t, ...t.node } } function createParser(e) { let t = "", n = "<unknown>", r = !1, a = NOOP, o = !1; const i = new OffsetToLocation, s = Object.assign(new TokenStream, processConfig(e || {}), { parseAtrulePrelude: !0, parseRulePrelude: !0, parseValue: !0, parseCustomProperty: !1, readSequence: readSequence$1, consumeUntilBalanceEnd: () => 0, consumeUntilLeftCurlyBracket: e => e === LEFTCURLYBRACKET$1 ? 1 : 0, consumeUntilLeftCurlyBracketOrSemicolon: e => e === LEFTCURLYBRACKET$1 || e === SEMICOLON ? 1 : 0, consumeUntilExclamationMarkOrSemicolon: e => e === EXCLAMATIONMARK$3 || e === SEMICOLON ? 1 : 0, consumeUntilSemicolonIncluded: e => e === SEMICOLON ? 2 : 0, createList: () => new List, createSingleNodeList: e => (new List).appendData(e), getFirstListNode: e => e && e.first, getLastListNode: e => e && e.last, parseWithFallback(e, t) { const n = this.tokenIndex; try { return e.call(this) } catch (e) { if (o) throw e; const r = t.call(this, n); return o = !0, a(e, r), o = !1, r } }, lookupNonWSType(e) { let t; do { if (t = this.lookupType(e++), t !== WhiteSpace$1) return t } while (t !== NULL); return NULL }, charCodeAt: e => e >= 0 && e < t.length ? t.charCodeAt(e) : 0, substring: (e, n) => t.substring(e, n), substrToCursor(e) { return this.source.substring(e, this.tokenStart) }, cmpChar: (e, n) => cmpChar(t, e, n), cmpStr: (e, n, r) => cmpStr(t, e, n, r), consume(e) { const t = this.tokenStart; return this.eat(e), this.substrToCursor(t) }, consumeFunctionName() { const e = t.substring(this.tokenStart, this.tokenEnd - 1); return this.eat(Function$1), e }, consumeNumber(e) { const n = t.substring(this.tokenStart, consumeNumber$1(t, this.tokenStart)); return this.eat(e), n }, eat(e) { if (this.tokenType !== e) { const t = tokenNames[e].slice(0, -6).replace(/-/g, " ").replace(/^./, (e => e.toUpperCase())); let n = `${/[[\](){}]/.test(t) ? `"${t}"` : t} is expected`, r = this.tokenStart; switch (e) { case Ident: this.tokenType === Function$1 || this.tokenType === Url$2 ? (r = this.tokenEnd - 1, n = "Identifier is expected but function found") : n = "Identifier is expected"; break; case Hash$1: this.isDelim(NUMBERSIGN$4) && (this.next(), r++, n = "Name is expected"); break; case Percentage$1: this.tokenType === Number$3 && (r = this.tokenEnd, n = "Percent sign is expected") }this.error(n, r) } this.next() }, eatIdent(e) { this.tokenType === Ident && !1 !== this.lookupValue(0, e) || this.error(`Identifier "${e}" is expected`), this.next() }, eatDelim(e) { this.isDelim(e) || this.error(`Delim "${String.fromCharCode(e)}" is expected`), this.next() }, getLocation: (e, t) => r ? i.getLocationRange(e, t, n) : null, getLocationFromList(e) { if (r) { const t = this.getFirstListNode(e), r = this.getLastListNode(e); return i.getLocationRange(null !== t ? t.loc.start.offset - i.startOffset : this.tokenStart, null !== r ? r.loc.end.offset - i.startOffset : this.tokenStart, n) } return null }, error(e, n) { const r = void 0 !== n && n < t.length ? i.getLocation(n) : this.eof ? i.getLocation(findWhiteSpaceStart(t, t.length - 1)) : i.getLocation(this.tokenStart); throw new SyntaxError$2(e || "Unexpected input", t, r.offset, r.line, r.column) } }); return Object.assign((function (e, l) { t = e, l = l || {}, s.setSource(t, tokenize$2), i.setSource(t, l.offset, l.line, l.column), n = l.filename || "<unknown>", r = Boolean(l.positions), a = "function" == typeof l.onParseError ? l.onParseError : NOOP, o = !1, s.parseAtrulePrelude = !("parseAtrulePrelude" in l) || Boolean(l.parseAtrulePrelude), s.parseRulePrelude = !("parseRulePrelude" in l) || Boolean(l.parseRulePrelude), s.parseValue = !("parseValue" in l) || Boolean(l.parseValue), s.parseCustomProperty = "parseCustomProperty" in l && Boolean(l.parseCustomProperty); const { context: c = "default", onComment: u } = l; if (c in s.context == !1) throw new Error("Unknown context `" + c + "`"); "function" == typeof u && s.forEachToken(((e, n, r) => { if (e === Comment$1) { const e = s.getLocation(n, r), a = cmpStr(t, r - 2, r, "*/") ? t.slice(n + 2, r - 2) : t.slice(n + 2, r); u(a, e) } })); const d = s.context[c].call(s, l); return s.eof || s.error(), d }), { SyntaxError: SyntaxError$2, config: s.config }) } const trackNodes = new Set(["Atrule", "Selector", "Declaration"]); function generateSourceMap(e) { const t = new SourceMapGenerator_1, n = { line: 1, column: 0 }, r = { line: 0, column: 0 }, a = { line: 1, column: 0 }, o = { generated: a }; let i = 1, s = 0, l = !1; const c = e.node; e.node = function (e) { if (e.loc && e.loc.start && trackNodes.has(e.type)) { const c = e.loc.start.line, u = e.loc.start.column - 1; r.line === c && r.column === u || (r.line = c, r.column = u, n.line = i, n.column = s, l && (l = !1, n.line === a.line && n.column === a.column || t.addMapping(o)), l = !0, t.addMapping({ source: e.loc.source, original: r, generated: n })) } c.call(this, e), l && trackNodes.has(e.type) && (a.line = i, a.column = s) }; const u = e.emit; e.emit = function (e, t, n) { for (let t = 0; t < e.length; t++)10 === e.charCodeAt(t) ? (i++, s = 0) : s++; u(e, t, n) }; const d = e.result; return e.result = function () { return l && t.addMapping(o), { css: d(), map: t } }, e } const PLUSSIGN$9 = 43, HYPHENMINUS$6 = 45, code = (e, t) => { if (e === Delim && (e = t), "string" == typeof e) { const t = e.charCodeAt(0); return t > 127 ? 32768 : t << 8 } return e }, specPairs = [[Ident, Ident], [Ident, Function$1], [Ident, Url$2], [Ident, BadUrl], [Ident, "-"], [Ident, Number$3], [Ident, Percentage$1], [Ident, Dimension$1], [Ident, CDC$1], [Ident, LeftParenthesis], [AtKeyword, Ident], [AtKeyword, Function$1], [AtKeyword, Url$2], [AtKeyword, BadUrl], [AtKeyword, "-"], [AtKeyword, Number$3], [AtKeyword, Percentage$1], [AtKeyword, Dimension$1], [AtKeyword, CDC$1], [Hash$1, Ident], [Hash$1, Function$1], [Hash$1, Url$2], [Hash$1, BadUrl], [Hash$1, "-"], [Hash$1, Number$3], [Hash$1, Percentage$1], [Hash$1, Dimension$1], [Hash$1, CDC$1], [Dimension$1, Ident], [Dimension$1, Function$1], [Dimension$1, Url$2], [Dimension$1, BadUrl], [Dimension$1, "-"], [Dimension$1, Number$3], [Dimension$1, Percentage$1], [Dimension$1, Dimension$1], [Dimension$1, CDC$1], ["#", Ident], ["#", Function$1], ["#", Url$2], ["#", BadUrl], ["#", "-"], ["#", Number$3], ["#", Percentage$1], ["#", Dimension$1], ["#", CDC$1], ["-", Ident], ["-", Function$1], ["-", Url$2], ["-", BadUrl], ["-", "-"], ["-", Number$3], ["-", Percentage$1], ["-", Dimension$1], ["-", CDC$1], [Number$3, Ident], [Number$3, Function$1], [Number$3, Url$2], [Number$3, BadUrl], [Number$3, Number$3], [Number$3, Percentage$1], [Number$3, Dimension$1], [Number$3, "%"], [Number$3, CDC$1], ["@", Ident], ["@", Function$1], ["@", Url$2], ["@", BadUrl], ["@", "-"], ["@", CDC$1], [".", Number$3], [".", Percentage$1], [".", Dimension$1], ["+", Number$3], ["+", Percentage$1], ["+", Dimension$1], ["/", "*"]], safePairs = specPairs.concat([[Ident, Hash$1], [Dimension$1, Hash$1], [Hash$1, Hash$1], [AtKeyword, LeftParenthesis], [AtKeyword, String$2], [AtKeyword, Colon], [Percentage$1, Percentage$1], [Percentage$1, Dimension$1], [Percentage$1, Function$1], [Percentage$1, "-"], [RightParenthesis, Ident], [RightParenthesis, Function$1], [RightParenthesis, Percentage$1], [RightParenthesis, Dimension$1], [RightParenthesis, Hash$1], [RightParenthesis, "-"]]); function createMap(e) { const t = new Set(e.map((([e, t]) => code(e) << 16 | code(t)))); return function (e, n, r) { const a = code(n, r), o = r.charCodeAt(0); return (45 === o && n !== Ident && n !== Function$1 && n !== CDC$1 || 43 === o ? t.has(e << 16 | o << 8) : t.has(e << 16 | a)) && this.emit(" ", WhiteSpace$1, !0), a } } const spec = createMap(specPairs), safe = createMap(safePairs); var tokenBefore = Object.freeze({ __proto__: null, safe: safe, spec: spec }); const REVERSESOLIDUS = 92; function processChildren(e, t) { if ("function" != typeof t) e.children.forEach(this.node, this); else { let n = null; e.children.forEach((e => { null !== n && t.call(this, n), this.node(e), n = e })) } } function processChunk(e) { tokenize$2(e, ((t, n, r) => { this.token(t, e.slice(n, r)) })) } function createGenerator(e) { const t = new Map; for (let n in e.node) { const r = e.node[n]; "function" == typeof (r.generate || r) && t.set(n, r.generate || r) } return function (e, n) { let r = "", a = 0, o = { node(e) { if (!t.has(e.type)) throw new Error("Unknown node type: " + e.type); t.get(e.type).call(i, e) }, tokenBefore: safe, token(e, t) { a = this.tokenBefore(a, e, t), this.emit(t, e, !1), e === Delim && t.charCodeAt(0) === REVERSESOLIDUS && this.emit("\n", WhiteSpace$1, !0) }, emit(e) { r += e }, result: () => r }; n && ("function" == typeof n.decorator && (o = n.decorator(o)), n.sourceMap && (o = generateSourceMap(o)), n.mode in tokenBefore && (o.tokenBefore = tokenBefore[n.mode])); const i = { node: e => o.node(e), children: processChildren, token: (e, t) => o.token(e, t), tokenize: processChunk }; return o.node(e), o.result() } } function createConvertor(e) { return { fromPlainObject: t => (e(t, { enter(e) { e.children && e.children instanceof List == !1 && (e.children = (new List).fromArray(e.children)) } }), t), toPlainObject: t => (e(t, { leave(e) { e.children && e.children instanceof List && (e.children = e.children.toArray()) } }), t) } } const { hasOwnProperty: hasOwnProperty$8 } = Object.prototype, noop$2 = function () { }; function ensureFunction$1(e) { return "function" == typeof e ? e : noop$2 } function invokeForType(e, t) { return function (n, r, a) { n.type === t && e.call(this, n, r, a) } } function getWalkersFromStructure(e, t) { const n = t.structure, r = []; for (const e in n) { if (!1 === hasOwnProperty$8.call(n, e)) continue; let t = n[e]; const a = { name: e, type: !1, nullable: !1 }; Array.isArray(t) || (t = [t]); for (const e of t) null === e ? a.nullable = !0 : "string" == typeof e ? a.type = "node" : Array.isArray(e) && (a.type = "list"); a.type && r.push(a) } return r.length ? { context: t.walkContext, fields: r } : null } function getTypesFromConfig(e) { const t = {}; for (const n in e.node) if (hasOwnProperty$8.call(e.node, n)) { const r = e.node[n]; if (!r.structure) throw new Error("Missed `structure` field in `" + n + "` node type definition"); t[n] = getWalkersFromStructure(n, r) } return t } function createTypeIterator(e, t) { const n = e.fields.slice(), r = e.context, a = "string" == typeof r; return t && n.reverse(), function (e, o, i, s) { let l; a && (l = o[r], o[r] = e); for (const r of n) { const n = e[r.name]; if (!r.nullable || n) if ("list" === r.type) { if (t ? n.reduceRight(s, !1) : n.reduce(s, !1)) return !0 } else if (i(n)) return !0 } a && (o[r] = l) } } function createFastTraveralMap({ StyleSheet: e, Atrule: t, Rule: n, Block: r, DeclarationList: a }) { return { Atrule: { StyleSheet: e, Atrule: t, Rule: n, Block: r }, Rule: { StyleSheet: e, Atrule: t, Rule: n, Block: r }, Declaration: { StyleSheet: e, Atrule: t, Rule: n, Block: r, DeclarationList: a } } } function createWalker(e) { const t = getTypesFromConfig(e), n = {}, r = {}, a = Symbol("break-walk"), o = Symbol("skip-node"); for (const e in t) hasOwnProperty$8.call(t, e) && null !== t[e] && (n[e] = createTypeIterator(t[e], !1), r[e] = createTypeIterator(t[e], !0)); const i = createFastTraveralMap(n), s = createFastTraveralMap(r), l = function (e, l) { function c(e, t, n) { const r = u.call(m, e, t, n); return r === a || r !== o && (!(!p.hasOwnProperty(e.type) || !p[e.type](e, m, c, h)) || d.call(m, e, t, n) === a) } let u = noop$2, d = noop$2, p = n, h = (e, t, n, r) => e || c(t, n, r); const m = { break: a, skip: o, root: e, stylesheet: null, atrule: null, atrulePrelude: null, rule: null, selector: null, block: null, declaration: null, function: null }; if ("function" == typeof l) u = l; else if (l && (u = ensureFunction$1(l.enter), d = ensureFunction$1(l.leave), l.reverse && (p = r), l.visit)) { if (i.hasOwnProperty(l.visit)) p = l.reverse ? s[l.visit] : i[l.visit]; else if (!t.hasOwnProperty(l.visit)) throw new Error("Bad value `" + l.visit + "` for `visit` option (should be: " + Object.keys(t).sort().join(", ") + ")"); u = invokeForType(u, l.visit), d = invokeForType(d, l.visit) } if (u === noop$2 && d === noop$2) throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function"); c(e) }; return l.break = a, l.skip = o, l.find = function (e, t) { let n = null; return l(e, (function (e, r, o) { if (t.call(this, e, r, o)) return n = e, a })), n }, l.findLast = function (e, t) { let n = null; return l(e, { reverse: !0, enter(e, r, o) { if (t.call(this, e, r, o)) return n = e, a } }), n }, l.findAll = function (e, t) { const n = []; return l(e, (function (e, r, a) { t.call(this, e, r, a) && n.push(e) })), n }, l } function noop$1(e) { return e } function generateMultiplier(e) { const { min: t, max: n, comma: r } = e; return 0 === t && 0 === n ? r ? "#?" : "*" : 0 === t && 1 === n ? "?" : 1 === t && 0 === n ? r ? "#" : "+" : 1 === t && 1 === n ? "" : (r ? "#" : "") + (t === n ? "{" + t + "}" : "{" + t + "," + (0 !== n ? n : "") + "}") } function generateTypeOpts(e) { if ("Range" === e.type) return " [" + (null === e.min ? "-" : e.min) + "," + (null === e.max ? "" : e.max) + "]"; throw new Error("Unknown node type `" + e.type + "`") } function generateSequence(e, t, n, r) { const a = " " === e.combinator || r ? e.combinator : " " + e.combinator + " ", o = e.terms.map((e => internalGenerate(e, t, n, r))).join(a); return e.explicit || n ? (r || "," === o[0] ? "[" : "[ ") + o + (r ? "]" : " ]") : o } function internalGenerate(e, t, n, r) { let a; switch (e.type) { case "Group": a = generateSequence(e, t, n, r) + (e.disallowEmpty ? "!" : ""); break; case "Multiplier": return internalGenerate(e.term, t, n, r) + t(generateMultiplier(e), e); case "Type": a = "<" + e.name + (e.opts ? t(generateTypeOpts(e.opts), e.opts) : "") + ">"; break; case "Property": a = "<'" + e.name + "'>"; break; case "Keyword": a = e.name; break; case "AtKeyword": a = "@" + e.name; break; case "Function": a = e.name + "("; break; case "String": case "Token": a = e.value; break; case "Comma": a = ","; break; default: throw new Error("Unknown node type `" + e.type + "`") }return t(a, e) } function generate$H(e, t) { let n = noop$1, r = !1, a = !1; return "function" == typeof t ? n = t : t && (r = Boolean(t.forceBraces), a = Boolean(t.compact), "function" == typeof t.decorate && (n = t.decorate)), internalGenerate(e, n, r, a) } const defaultLoc = { offset: 0, line: 1, column: 1 }; function locateMismatch(e, t) { const n = e.tokens, r = e.longestMatch, a = r < n.length && n[r].node || null, o = a !== t ? a : null; let i, s, l = 0, c = 0, u = 0, d = ""; for (let e = 0; e < n.length; e++) { const t = n[e].value; e === r && (c = t.length, l = d.length), null !== o && n[e].node === o && (e <= r ? u++ : u = 0), d += t } return r === n.length || u > 1 ? (i = fromLoc(o || t, "end") || buildLoc(defaultLoc, d), s = buildLoc(i)) : (i = fromLoc(o, "start") || buildLoc(fromLoc(t, "start") || defaultLoc, d.slice(0, l)), s = fromLoc(o, "end") || buildLoc(i, d.substr(l, c))), { css: d, mismatchOffset: l, mismatchLength: c, start: i, end: s } } function fromLoc(e, t) { const n = e && e.loc && e.loc[t]; return n ? "line" in n ? buildLoc(n) : n : null } function buildLoc({ offset: e, line: t, column: n }, r) { const a = { offset: e, line: t, column: n }; if (r) { const e = r.split(/\n|\r\n?|\f/); a.offset += r.length, a.line += e.length - 1, a.column = 1 === e.length ? a.column + r.length : e.pop().length + 1 } return a } const SyntaxReferenceError = function (e, t) { const n = createCustomError("SyntaxReferenceError", e + (t ? " `" + t + "`" : "")); return n.reference = t, n }, SyntaxMatchError = function (e, t, n, r) { const a = createCustomError("SyntaxMatchError", e), { css: o, mismatchOffset: i, mismatchLength: s, start: l, end: c } = locateMismatch(r, n); return a.rawMessage = e, a.syntax = t ? generate$H(t) : "<generic>", a.css = o, a.mismatchOffset = i, a.mismatchLength = s, a.message = e + "\n  syntax: " + a.syntax + "\n   value: " + (o || "<empty string>") + "\n  --------" + new Array(a.mismatchOffset + 1).join("-") + "^", Object.assign(a, l), a.loc = { source: n && n.loc && n.loc.source || "<unknown>", start: l, end: c }, a }, keywords = new Map, properties = new Map, HYPHENMINUS$5 = 45, keyword = getKeywordDescriptor, property = getPropertyDescriptor; function isCustomProperty(e, t) { return t = t || 0, e.length - t >= 2 && e.charCodeAt(t) === HYPHENMINUS$5 && e.charCodeAt(t + 1) === HYPHENMINUS$5 } function getVendorPrefix(e, t) { if (t = t || 0, e.length - t >= 3 && e.charCodeAt(t) === HYPHENMINUS$5 && e.charCodeAt(t + 1) !== HYPHENMINUS$5) { const n = e.indexOf("-", t + 2); if (-1 !== n) return e.substring(t, n + 1) } return "" } function getKeywordDescriptor(e) { if (keywords.has(e)) return keywords.get(e); const t = e.toLowerCase(); let n = keywords.get(t); if (void 0 === n) { const e = isCustomProperty(t, 0), r = e ? "" : getVendorPrefix(t, 0); n = Object.freeze({ basename: t.substr(r.length), name: t, prefix: r, vendor: r, custom: e }) } return keywords.set(e, n), n } function getPropertyDescriptor(e) { if (properties.has(e)) return properties.get(e); let t = e, n = e[0]; "/" === n ? n = "/" === e[1] ? "//" : "/" : "_" !== n && "*" !== n && "$" !== n && "#" !== n && "+" !== n && "&" !== n && (n = ""); const r = isCustomProperty(t, n.length); if (!r && (t = t.toLowerCase(), properties.has(t))) { const n = properties.get(t); return properties.set(e, n), n } const a = r ? "" : getVendorPrefix(t, n.length), o = t.substr(0, n.length + a.length), i = Object.freeze({ basename: t.substr(o.length), name: t.substr(n.length), hack: n, vendor: a, prefix: o, custom: r }); return properties.set(e, i), i } const cssWideKeywords = ["initial", "inherit", "unset", "revert", "revert-layer"], PLUSSIGN$8 = 43, HYPHENMINUS$4 = 45, N$3 = 110, DISALLOW_SIGN$1 = !0, ALLOW_SIGN$1 = !1; function isDelim$1(e, t) { return null !== e && e.type === Delim && e.value.charCodeAt(0) === t } function skipSC(e, t, n) { for (; null !== e && (e.type === WhiteSpace$1 || e.type === Comment$1);)e = n(++t); return t } function checkInteger$1(e, t, n, r) { if (!e) return 0; const a = e.value.charCodeAt(t); if (a === PLUSSIGN$8 || a === HYPHENMINUS$4) { if (n) return 0; t++ } for (; t < e.value.length; t++)if (!isDigit$1(e.value.charCodeAt(t))) return 0; return r + 1 } function consumeB$1(e, t, n) { let r = !1, a = skipSC(e, t, n); if (null === (e = n(a))) return t; if (e.type !== Number$3) { if (!isDelim$1(e, PLUSSIGN$8) && !isDelim$1(e, HYPHENMINUS$4)) return t; if (r = !0, a = skipSC(n(++a), a, n), null === (e = n(a)) || e.type !== Number$3) return 0 } if (!r) { const t = e.value.charCodeAt(0); if (t !== PLUSSIGN$8 && t !== HYPHENMINUS$4) return 0 } return checkInteger$1(e, r ? 0 : 1, r, a) } function anPlusB(e, t) { let n = 0; if (!e) return 0; if (e.type === Number$3) return checkInteger$1(e, 0, false, n); if (e.type === Ident && e.value.charCodeAt(0) === HYPHENMINUS$4) { if (!cmpChar(e.value, 1, 110)) return 0; switch (e.value.length) { case 2: return consumeB$1(t(++n), n, t); case 3: return e.value.charCodeAt(2) !== HYPHENMINUS$4 ? 0 : (n = skipSC(t(++n), n, t), checkInteger$1(e = t(n), 0, true, n)); default: return e.value.charCodeAt(2) !== HYPHENMINUS$4 ? 0 : checkInteger$1(e, 3, true, n) } } else if (e.type === Ident || isDelim$1(e, PLUSSIGN$8) && t(n + 1).type === Ident) { if (e.type !== Ident && (e = t(++n)), null === e || !cmpChar(e.value, 0, 110)) return 0; switch (e.value.length) { case 1: return consumeB$1(t(++n), n, t); case 2: return e.value.charCodeAt(1) !== HYPHENMINUS$4 ? 0 : (n = skipSC(t(++n), n, t), checkInteger$1(e = t(n), 0, true, n)); default: return e.value.charCodeAt(1) !== HYPHENMINUS$4 ? 0 : checkInteger$1(e, 2, true, n) } } else if (e.type === Dimension$1) { let r = e.value.charCodeAt(0), a = r === PLUSSIGN$8 || r === HYPHENMINUS$4 ? 1 : 0, o = a; for (; o < e.value.length && isDigit$1(e.value.charCodeAt(o)); o++); return o === a ? 0 : cmpChar(e.value, o, 110) ? o + 1 === e.value.length ? consumeB$1(t(++n), n, t) : e.value.charCodeAt(o + 1) !== HYPHENMINUS$4 ? 0 : o + 2 === e.value.length ? (n = skipSC(t(++n), n, t), checkInteger$1(e = t(n), 0, true, n)) : checkInteger$1(e, o + 2, true, n) : 0 } return 0 } const PLUSSIGN$7 = 43, HYPHENMINUS$3 = 45, QUESTIONMARK$2 = 63, U$1 = 117; function isDelim(e, t) { return null !== e && e.type === Delim && e.value.charCodeAt(0) === t } function startsWith$1(e, t) { return e.value.charCodeAt(0) === t } function hexSequence(e, t, n) { let r = 0; for (let a = t; a < e.value.length; a++) { const o = e.value.charCodeAt(a); if (o === HYPHENMINUS$3 && n && 0 !== r) return hexSequence(e, t + r + 1, !1), 6; if (!isHexDigit(o)) return 0; if (++r > 6) return 0 } return r } function withQuestionMarkSequence(e, t, n) { if (!e) return 0; for (; isDelim(n(t), QUESTIONMARK$2);) { if (++e > 6) return 0; t++ } return t } function urange(e, t) { let n = 0; if (null === e || e.type !== Ident || !cmpChar(e.value, 0, 117)) return 0; if (null === (e = t(++n))) return 0; if (isDelim(e, 43)) return null === (e = t(++n)) ? 0 : e.type === Ident ? withQuestionMarkSequence(hexSequence(e, 0, !0), ++n, t) : isDelim(e, QUESTIONMARK$2) ? withQuestionMarkSequence(1, ++n, t) : 0; if (e.type === Number$3) { const r = hexSequence(e, 1, !0); return 0 === r ? 0 : null === (e = t(++n)) ? n : e.type === Dimension$1 || e.type === Number$3 ? startsWith$1(e, HYPHENMINUS$3) && hexSequence(e, 1, !1) ? n + 1 : 0 : withQuestionMarkSequence(r, n, t) } return e.type === Dimension$1 ? withQuestionMarkSequence(hexSequence(e, 1, !0), ++n, t) : 0 } const calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("], balancePair = new Map([[Function$1, RightParenthesis], [LeftParenthesis, RightParenthesis], [LeftSquareBracket, RightSquareBracket], [LeftCurlyBracket, RightCurlyBracket]]), LENGTH = ["cm", "mm", "q", "in", "pt", "pc", "px", "em", "rem", "ex", "rex", "cap", "rcap", "ch", "rch", "ic", "ric", "lh", "rlh", "vw", "svw", "lvw", "dvw", "vh", "svh", "lvh", "dvh", "vi", "svi", "lvi", "dvi", "vb", "svb", "lvb", "dvb", "vmin", "svmin", "lvmin", "dvmin", "vmax", "svmax", "lvmax", "dvmax", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"], ANGLE = ["deg", "grad", "rad", "turn"], TIME = ["s", "ms"], FREQUENCY = ["hz", "khz"], RESOLUTION = ["dpi", "dpcm", "dppx", "x"], FLEX = ["fr"], DECIBEL = ["db"], SEMITONES = ["st"]; function charCodeAt(e, t) { return t < e.length ? e.charCodeAt(t) : 0 } function eqStr(e, t) { return cmpStr(e, 0, e.length, t) } function eqStrAny(e, t) { for (let n = 0; n < t.length; n++)if (eqStr(e, t[n])) return !0; return !1 } function isPostfixIeHack(e, t) { return t === e.length - 2 && (92 === charCodeAt(e, t) && isDigit$1(charCodeAt(e, t + 1))) } function outOfRange(e, t, n) { if (e && "Range" === e.type) { const r = Number(void 0 !== n && n !== t.length ? t.substr(0, n) : t); if (isNaN(r)) return !0; if (null !== e.min && r < e.min && "string" != typeof e.min) return !0; if (null !== e.max && r > e.max && "string" != typeof e.max) return !0 } return !1 } function consumeFunction(e, t) { let n = 0, r = [], a = 0; e: do { switch (e.type) { case RightCurlyBracket: case RightParenthesis: case RightSquareBracket: if (e.type !== n) break e; if (n = r.pop(), 0 === r.length) { a++; break e } break; case Function$1: case LeftParenthesis: case LeftSquareBracket: case LeftCurlyBracket: r.push(n), n = balancePair.get(e.type) }a++ } while (e = t(a)); return a } function calc(e) { return function (t, n, r) { return null === t ? 0 : t.type === Function$1 && eqStrAny(t.value, calcFunctionNames) ? consumeFunction(t, n) : e(t, n, r) } } function tokenType(e) { return function (t) { return null === t || t.type !== e ? 0 : 1 } } function customIdent(e) { if (null === e || e.type !== Ident) return 0; const t = e.value.toLowerCase(); return eqStrAny(t, cssWideKeywords) || eqStr(t, "default") ? 0 : 1 } function customPropertyName(e) { return null === e || e.type !== Ident || 45 !== charCodeAt(e.value, 0) || 45 !== charCodeAt(e.value, 1) ? 0 : 1 } function hexColor(e) { if (null === e || e.type !== Hash$1) return 0; const t = e.value.length; if (4 !== t && 5 !== t && 7 !== t && 9 !== t) return 0; for (let n = 1; n < t; n++)if (!isHexDigit(charCodeAt(e.value, n))) return 0; return 1 } function idSelector(e) { return null === e || e.type !== Hash$1 ? 0 : isIdentifierStart(charCodeAt(e.value, 1), charCodeAt(e.value, 2), charCodeAt(e.value, 3)) ? 1 : 0 } function declarationValue(e, t) { if (!e) return 0; let n = 0, r = [], a = 0; e: do { switch (e.type) { case BadString: case BadUrl: break e; case RightCurlyBracket: case RightParenthesis: case RightSquareBracket: if (e.type !== n) break e; n = r.pop(); break; case Semicolon: if (0 === n) break e; break; case Delim: if (0 === n && "!" === e.value) break e; break; case Function$1: case LeftParenthesis: case LeftSquareBracket: case LeftCurlyBracket: r.push(n), n = balancePair.get(e.type) }a++ } while (e = t(a)); return a } function anyValue(e, t) { if (!e) return 0; let n = 0, r = [], a = 0; e: do { switch (e.type) { case BadString: case BadUrl: break e; case RightCurlyBracket: case RightParenthesis: case RightSquareBracket: if (e.type !== n) break e; n = r.pop(); break; case Function$1: case LeftParenthesis: case LeftSquareBracket: case LeftCurlyBracket: r.push(n), n = balancePair.get(e.type) }a++ } while (e = t(a)); return a } function dimension(e) { return e && (e = new Set(e)), function (t, n, r) { if (null === t || t.type !== Dimension$1) return 0; const a = consumeNumber$1(t.value, 0); if (null !== e) { const n = t.value.indexOf("\\", a), r = -1 !== n && isPostfixIeHack(t.value, n) ? t.value.substring(a, n) : t.value.substr(a); if (!1 === e.has(r.toLowerCase())) return 0 } return outOfRange(r, t.value, a) ? 0 : 1 } } function percentage(e, t, n) { return null === e || e.type !== Percentage$1 || outOfRange(n, e.value, e.value.length - 1) ? 0 : 1 } function zero(e) { return "function" != typeof e && (e = function () { return 0 }), function (t, n, r) { return null !== t && t.type === Number$3 && 0 === Number(t.value) ? 1 : e(t, n, r) } } function number(e, t, n) { if (null === e) return 0; const r = consumeNumber$1(e.value, 0); return r === e.value.length || isPostfixIeHack(e.value, r) ? outOfRange(n, e.value, r) ? 0 : 1 : 0 } function integer(e, t, n) { if (null === e || e.type !== Number$3) return 0; let r = 43 === charCodeAt(e.value, 0) || 45 === charCodeAt(e.value, 0) ? 1 : 0; for (; r < e.value.length; r++)if (!isDigit$1(charCodeAt(e.value, r))) return 0; return outOfRange(n, e.value, r) ? 0 : 1 } var generic = { "ident-token": tokenType(Ident), "function-token": tokenType(Function$1), "at-keyword-token": tokenType(AtKeyword), "hash-token": tokenType(Hash$1), "string-token": tokenType(String$2), "bad-string-token": tokenType(BadString), "url-token": tokenType(Url$2), "bad-url-token": tokenType(BadUrl), "delim-token": tokenType(Delim), "number-token": tokenType(Number$3), "percentage-token": tokenType(Percentage$1), "dimension-token": tokenType(Dimension$1), "whitespace-token": tokenType(WhiteSpace$1), "CDO-token": tokenType(CDO$1), "CDC-token": tokenType(CDC$1), "colon-token": tokenType(Colon), "semicolon-token": tokenType(Semicolon), "comma-token": tokenType(Comma), "[-token": tokenType(LeftSquareBracket), "]-token": tokenType(RightSquareBracket), "(-token": tokenType(LeftParenthesis), ")-token": tokenType(RightParenthesis), "{-token": tokenType(LeftCurlyBracket), "}-token": tokenType(RightCurlyBracket), string: tokenType(String$2), ident: tokenType(Ident), "custom-ident": customIdent, "custom-property-name": customPropertyName, "hex-color": hexColor, "id-selector": idSelector, "an-plus-b": anPlusB, urange: urange, "declaration-value": declarationValue, "any-value": anyValue, dimension: calc(dimension(null)), angle: calc(dimension(ANGLE)), decibel: calc(dimension(DECIBEL)), frequency: calc(dimension(FREQUENCY)), flex: calc(dimension(FLEX)), length: calc(zero(dimension(LENGTH))), resolution: calc(dimension(RESOLUTION)), semitones: calc(dimension(SEMITONES)), time: calc(dimension(TIME)), percentage: calc(percentage), zero: zero(), number: calc(number), integer: calc(integer) }; function SyntaxError$1(e, t, n) { return Object.assign(createCustomError("SyntaxError", e), { input: t, offset: n, rawMessage: e, message: e + "\n  " + t + "\n--" + new Array((n || t.length) + 1).join("-") + "^" }) } const TAB$1 = 9, N$2 = 10, F$1 = 12, R$1 = 13, SPACE$3 = 32; class Tokenizer { constructor(e) { this.str = e, this.pos = 0 } charCodeAt(e) { return e < this.str.length ? this.str.charCodeAt(e) : 0 } charCode() { return this.charCodeAt(this.pos) } nextCharCode() { return this.charCodeAt(this.pos + 1) } nextNonWsCode(e) { return this.charCodeAt(this.findWsEnd(e)) } findWsEnd(e) { for (; e < this.str.length; e++) { const t = this.str.charCodeAt(e); if (13 !== t && 10 !== t && 12 !== t && 32 !== t && 9 !== t) break } return e } substringToPos(e) { return this.str.substring(this.pos, this.pos = e) } eat(e) { this.charCode() !== e && this.error("Expect `" + String.fromCharCode(e) + "`"), this.pos++ } peek() { return this.pos < this.str.length ? this.str.charAt(this.pos++) : "" } error(e) { throw new SyntaxError$1(e, this.str, this.pos) } } const TAB = 9, N$1 = 10, F = 12, R = 13, SPACE$2 = 32, EXCLAMATIONMARK$2 = 33, NUMBERSIGN$3 = 35, AMPERSAND$1 = 38, APOSTROPHE$2 = 39, LEFTPARENTHESIS$2 = 40, RIGHTPARENTHESIS$2 = 41, ASTERISK$6 = 42, PLUSSIGN$6 = 43, COMMA = 44, HYPERMINUS = 45, LESSTHANSIGN = 60, GREATERTHANSIGN$2 = 62, QUESTIONMARK$1 = 63, COMMERCIALAT = 64, LEFTSQUAREBRACKET = 91, RIGHTSQUAREBRACKET = 93, LEFTCURLYBRACKET = 123, VERTICALLINE$3 = 124, RIGHTCURLYBRACKET = 125, INFINITY = 8734, NAME_CHAR = new Uint8Array(128).map(((e, t) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(t)) ? 1 : 0)), COMBINATOR_PRECEDENCE = { " ": 1, "&&": 2, "||": 3, "|": 4 }; function scanSpaces(e) { return e.substringToPos(e.findWsEnd(e.pos)) } function scanWord(e) { let t = e.pos; for (; t < e.str.length; t++) { const n = e.str.charCodeAt(t); if (n >= 128 || 0 === NAME_CHAR[n]) break } return e.pos === t && e.error("Expect a keyword"), e.substringToPos(t) } function scanNumber(e) { let t = e.pos; for (; t < e.str.length; t++) { const n = e.str.charCodeAt(t); if (n < 48 || n > 57) break } return e.pos === t && e.error("Expect a number"), e.substringToPos(t) } function scanString(e) { const t = e.str.indexOf("'", e.pos + 1); return -1 === t && (e.pos = e.str.length, e.error("Expect an apostrophe")), e.substringToPos(t + 1) } function readMultiplierRange(e) { let t = null, n = null; return e.eat(LEFTCURLYBRACKET), t = scanNumber(e), e.charCode() === COMMA ? (e.pos++, e.charCode() !== RIGHTCURLYBRACKET && (n = scanNumber(e))) : n = t, e.eat(RIGHTCURLYBRACKET), { min: Number(t), max: n ? Number(n) : 0 } } function readMultiplier(e) { let t = null, n = !1; switch (e.charCode()) { case ASTERISK$6: e.pos++, t = { min: 0, max: 0 }; break; case PLUSSIGN$6: e.pos++, t = { min: 1, max: 0 }; break; case QUESTIONMARK$1: e.pos++, t = { min: 0, max: 1 }; break; case NUMBERSIGN$3: e.pos++, n = !0, e.charCode() === LEFTCURLYBRACKET ? t = readMultiplierRange(e) : e.charCode() === QUESTIONMARK$1 ? (e.pos++, t = { min: 0, max: 0 }) : t = { min: 1, max: 0 }; break; case LEFTCURLYBRACKET: t = readMultiplierRange(e); break; default: return null }return { type: "Multiplier", comma: n, min: t.min, max: t.max, term: null } } function maybeMultiplied(e, t) { const n = readMultiplier(e); return null !== n ? (n.term = t, e.charCode() === NUMBERSIGN$3 && e.charCodeAt(e.pos - 1) === PLUSSIGN$6 ? maybeMultiplied(e, n) : n) : t } function maybeToken(e) { const t = e.peek(); return "" === t ? null : { type: "Token", value: t } } function readProperty$1(e) { let t; return e.eat(LESSTHANSIGN), e.eat(APOSTROPHE$2), t = scanWord(e), e.eat(APOSTROPHE$2), e.eat(GREATERTHANSIGN$2), maybeMultiplied(e, { type: "Property", name: t }) } function readTypeRange(e) { let t = null, n = null, r = 1; return e.eat(LEFTSQUAREBRACKET), e.charCode() === HYPERMINUS && (e.peek(), r = -1), -1 == r && e.charCode() === INFINITY ? e.peek() : (t = r * Number(scanNumber(e)), 0 !== NAME_CHAR[e.charCode()] && (t += scanWord(e))), scanSpaces(e), e.eat(COMMA), scanSpaces(e), e.charCode() === INFINITY ? e.peek() : (r = 1, e.charCode() === HYPERMINUS && (e.peek(), r = -1), n = r * Number(scanNumber(e)), 0 !== NAME_CHAR[e.charCode()] && (n += scanWord(e))), e.eat(RIGHTSQUAREBRACKET), { type: "Range", min: t, max: n } } function readType(e) { let t, n = null; return e.eat(LESSTHANSIGN), t = scanWord(e), e.charCode() === LEFTPARENTHESIS$2 && e.nextCharCode() === RIGHTPARENTHESIS$2 && (e.pos += 2, t += "()"), e.charCodeAt(e.findWsEnd(e.pos)) === LEFTSQUAREBRACKET && (scanSpaces(e), n = readTypeRange(e)), e.eat(GREATERTHANSIGN$2), maybeMultiplied(e, { type: "Type", name: t, opts: n }) } function readKeywordOrFunction(e) { const t = scanWord(e); return e.charCode() === LEFTPARENTHESIS$2 ? (e.pos++, { type: "Function", name: t }) : maybeMultiplied(e, { type: "Keyword", name: t }) } function regroupTerms(e, t) { function n(e, t) { return { type: "Group", terms: e, combinator: t, disallowEmpty: !1, explicit: !1 } } let r; for (t = Object.keys(t).sort(((e, t) => COMBINATOR_PRECEDENCE[e] - COMBINATOR_PRECEDENCE[t])); t.length > 0;) { r = t.shift(); let a = 0, o = 0; for (; a < e.length; a++) { const t = e[a]; "Combinator" === t.type && (t.value === r ? (-1 === o && (o = a - 1), e.splice(a, 1), a--) : (-1 !== o && a - o > 1 && (e.splice(o, a - o, n(e.slice(o, a), r)), a = o + 1), o = -1)) } -1 !== o && t.length && e.splice(o, a - o, n(e.slice(o, a), r)) } return r } function readImplicitGroup(e) { const t = [], n = {}; let r, a = null, o = e.pos; for (; r = peek(e);)"Spaces" !== r.type && ("Combinator" === r.type ? (null !== a && "Combinator" !== a.type || (e.pos = o, e.error("Unexpected combinator")), n[r.value] = !0) : null !== a && "Combinator" !== a.type && (n[" "] = !0, t.push({ type: "Combinator", value: " " })), t.push(r), a = r, o = e.pos); return null !== a && "Combinator" === a.type && (e.pos -= o, e.error("Unexpected combinator")), { type: "Group", terms: t, combinator: regroupTerms(t, n) || " ", disallowEmpty: !1, explicit: !1 } } function readGroup(e) { let t; return e.eat(LEFTSQUAREBRACKET), t = readImplicitGroup(e), e.eat(RIGHTSQUAREBRACKET), t.explicit = !0, e.charCode() === EXCLAMATIONMARK$2 && (e.pos++, t.disallowEmpty = !0), t } function peek(e) { let t = e.charCode(); if (t < 128 && 1 === NAME_CHAR[t]) return readKeywordOrFunction(e); switch (t) { case RIGHTSQUAREBRACKET: break; case LEFTSQUAREBRACKET: return maybeMultiplied(e, readGroup(e)); case LESSTHANSIGN: return e.nextCharCode() === APOSTROPHE$2 ? readProperty$1(e) : readType(e); case VERTICALLINE$3: return { type: "Combinator", value: e.substringToPos(e.pos + (e.nextCharCode() === VERTICALLINE$3 ? 2 : 1)) }; case AMPERSAND$1: return e.pos++, e.eat(AMPERSAND$1), { type: "Combinator", value: "&&" }; case COMMA: return e.pos++, { type: "Comma" }; case APOSTROPHE$2: return maybeMultiplied(e, { type: "String", value: scanString(e) }); case SPACE$2: case TAB: case N$1: case R: case F: return { type: "Spaces", value: scanSpaces(e) }; case COMMERCIALAT: return t = e.nextCharCode(), t < 128 && 1 === NAME_CHAR[t] ? (e.pos++, { type: "AtKeyword", name: scanWord(e) }) : maybeToken(e); case ASTERISK$6: case PLUSSIGN$6: case QUESTIONMARK$1: case NUMBERSIGN$3: case EXCLAMATIONMARK$2: break; case LEFTCURLYBRACKET: if (t = e.nextCharCode(), t < 48 || t > 57) return maybeToken(e); break; default: return maybeToken(e) } } function parse$H(e) { const t = new Tokenizer(e), n = readImplicitGroup(t); return t.pos !== e.length && t.error("Unexpected input"), 1 === n.terms.length && "Group" === n.terms[0].type ? n.terms[0] : n } const noop = function () { }; function ensureFunction(e) { return "function" == typeof e ? e : noop } function walk$2(e, t, n) { let r = noop, a = noop; if ("function" == typeof t ? r = t : t && (r = ensureFunction(t.enter), a = ensureFunction(t.leave)), r === noop && a === noop) throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function"); !function e(t) { switch (r.call(n, t), t.type) { case "Group": t.terms.forEach(e); break; case "Multiplier": e(t.term); break; case "Type": case "Property": case "Keyword": case "AtKeyword": case "Function": case "String": case "Token": case "Comma": break; default: throw new Error("Unknown type: " + t.type) }a.call(n, t) }(e) } const astToTokens = { decorator(e) { const t = []; let n = null; return { ...e, node(t) { const r = n; n = t, e.node.call(this, t), n = r }, emit(e, r, a) { t.push({ type: r, value: e, node: a ? null : n }) }, result: () => t } } }; function stringToTokens(e) { const t = []; return tokenize$2(e, ((n, r, a) => t.push({ type: n, value: e.slice(r, a), node: null }))), t } function prepareTokens(e, t) { return "string" == typeof e ? stringToTokens(e) : t.generate(e, astToTokens) } const MATCH = { type: "Match" }, MISMATCH = { type: "Mismatch" }, DISALLOW_EMPTY = { type: "DisallowEmpty" }, LEFTPARENTHESIS$1 = 40, RIGHTPARENTHESIS$1 = 41; function createCondition(e, t, n) { return t === MATCH && n === MISMATCH || e === MATCH && t === MATCH && n === MATCH ? e : ("If" === e.type && e.else === MISMATCH && t === MATCH && (t = e.then, e = e.match), { type: "If", match: e, then: t, else: n }) } function isFunctionType(e) { return e.length > 2 && e.charCodeAt(e.length - 2) === LEFTPARENTHESIS$1 && e.charCodeAt(e.length - 1) === RIGHTPARENTHESIS$1 } function isEnumCapatible(e) { return "Keyword" === e.type || "AtKeyword" === e.type || "Function" === e.type || "Type" === e.type && isFunctionType(e.name) } function buildGroupMatchGraph(e, t, n) { switch (e) { case " ": { let e = MATCH; for (let n = t.length - 1; n >= 0; n--) { e = createCondition(t[n], e, MISMATCH) } return e } case "|": { let e = MISMATCH, n = null; for (let r = t.length - 1; r >= 0; r--) { let a = t[r]; if (isEnumCapatible(a) && (null === n && r > 0 && isEnumCapatible(t[r - 1]) && (n = Object.create(null), e = createCondition({ type: "Enum", map: n }, MATCH, e)), null !== n)) { const e = (isFunctionType(a.name) ? a.name.slice(0, -1) : a.name).toLowerCase(); if (e in n == !1) { n[e] = a; continue } } n = null, e = createCondition(a, MATCH, e) } return e } case "&&": { if (t.length > 5) return { type: "MatchOnce", terms: t, all: !0 }; let n = MISMATCH; for (let r = t.length - 1; r >= 0; r--) { const a = t[r]; let o; o = t.length > 1 ? buildGroupMatchGraph(e, t.filter((function (e) { return e !== a })), !1) : MATCH, n = createCondition(a, o, n) } return n } case "||": { if (t.length > 5) return { type: "MatchOnce", terms: t, all: !1 }; let r = n ? MATCH : MISMATCH; for (let n = t.length - 1; n >= 0; n--) { const a = t[n]; let o; o = t.length > 1 ? buildGroupMatchGraph(e, t.filter((function (e) { return e !== a })), !0) : MATCH, r = createCondition(a, o, r) } return r } } } function buildMultiplierMatchGraph(e) { let t = MATCH, n = buildMatchGraphInternal(e.term); if (0 === e.max) n = createCondition(n, DISALLOW_EMPTY, MISMATCH), t = createCondition(n, null, MISMATCH), t.then = createCondition(MATCH, MATCH, t), e.comma && (t.then.else = createCondition({ type: "Comma", syntax: e }, t, MISMATCH)); else for (let r = e.min || 1; r <= e.max; r++)e.comma && t !== MATCH && (t = createCondition({ type: "Comma", syntax: e }, t, MISMATCH)), t = createCondition(n, createCondition(MATCH, MATCH, t), MISMATCH); if (0 === e.min) t = createCondition(MATCH, MATCH, t); else for (let r = 0; r < e.min - 1; r++)e.comma && t !== MATCH && (t = createCondition({ type: "Comma", syntax: e }, t, MISMATCH)), t = createCondition(n, t, MISMATCH); return t } function buildMatchGraphInternal(e) { if ("function" == typeof e) return { type: "Generic", fn: e }; switch (e.type) { case "Group": { let t = buildGroupMatchGraph(e.combinator, e.terms.map(buildMatchGraphInternal), !1); return e.disallowEmpty && (t = createCondition(t, DISALLOW_EMPTY, MISMATCH)), t } case "Multiplier": return buildMultiplierMatchGraph(e); case "Type": case "Property": return { type: e.type, name: e.name, syntax: e }; case "Keyword": return { type: e.type, name: e.name.toLowerCase(), syntax: e }; case "AtKeyword": return { type: e.type, name: "@" + e.name.toLowerCase(), syntax: e }; case "Function": return { type: e.type, name: e.name.toLowerCase() + "(", syntax: e }; case "String": return 3 === e.value.length ? { type: "Token", value: e.value.charAt(1), syntax: e } : { type: e.type, value: e.value.substr(1, e.value.length - 2).replace(/\\'/g, "'"), syntax: e }; case "Token": return { type: e.type, value: e.value, syntax: e }; case "Comma": return { type: e.type, syntax: e }; default: throw new Error("Unknown node type:", e.type) } } function buildMatchGraph(e, t) { return "string" == typeof e && (e = parse$H(e)), { type: "MatchGraph", match: buildMatchGraphInternal(e), syntax: t || null, source: e } } const { hasOwnProperty: hasOwnProperty$7 } = Object.prototype, STUB = 0, TOKEN = 1, OPEN_SYNTAX = 2, CLOSE_SYNTAX = 3, EXIT_REASON_MATCH = "Match", EXIT_REASON_MISMATCH = "Mismatch", EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)", ITERATION_LIMIT = 15e3; function reverseList(e) { let t = null, n = null, r = e; for (; null !== r;)n = r.prev, r.prev = t, t = r, r = n; return t } function areStringsEqualCaseInsensitive(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; n++) { const r = t.charCodeAt(n); let a = e.charCodeAt(n); if (a >= 65 && a <= 90 && (a |= 32), a !== r) return !1 } return !0 } function isContextEdgeDelim(e) { return e.type === Delim && "?" !== e.value } function isCommaContextStart(e) { return null === e || (e.type === Comma || e.type === Function$1 || e.type === LeftParenthesis || e.type === LeftSquareBracket || e.type === LeftCurlyBracket || isContextEdgeDelim(e)) } function isCommaContextEnd(e) { return null === e || (e.type === RightParenthesis || e.type === RightSquareBracket || e.type === RightCurlyBracket || e.type === Delim && "/" === e.value) } function internalMatch(e, t, n) { function r() { do { b++, g = b < e.length ? e[b] : null } while (null !== g && (g.type === WhiteSpace$1 || g.type === Comment$1)) } function a(t) { const n = b + t; return n < e.length ? e[n] : null } function o(e, t) { return { nextState: e, matchStack: $, syntaxStack: u, thenStack: d, tokenIndex: b, prev: t } } function i(e) { d = { nextState: e, matchStack: $, syntaxStack: u, prev: d } } function s(e) { p = o(e, p) } function l() { $ = { type: TOKEN, syntax: t.syntax, token: g, prev: $ }, r(), h = null, b > y && (y = b) } function c() { $ = $.type === OPEN_SYNTAX ? $.prev : { type: CLOSE_SYNTAX, syntax: u.syntax, token: $.token, prev: $ }, u = u.prev } let u = null, d = null, p = null, h = null, m = 0, f = null, g = null, b = -1, y = 0, $ = { type: STUB, syntax: null, token: null, prev: null }; for (r(); null === f && ++m < ITERATION_LIMIT;)switch (t.type) { case "Match": if (null === d) { if (null !== g && (b !== e.length - 1 || "\\0" !== g.value && "\\9" !== g.value)) { t = MISMATCH; break } f = EXIT_REASON_MATCH; break } if ((t = d.nextState) === DISALLOW_EMPTY) { if (d.matchStack === $) { t = MISMATCH; break } t = MATCH } for (; d.syntaxStack !== u;)c(); d = d.prev; break; case "Mismatch": if (null !== h && !1 !== h) (null === p || b > p.tokenIndex) && (p = h, h = !1); else if (null === p) { f = EXIT_REASON_MISMATCH; break } t = p.nextState, d = p.thenStack, u = p.syntaxStack, $ = p.matchStack, b = p.tokenIndex, g = b < e.length ? e[b] : null, p = p.prev; break; case "MatchGraph": t = t.match; break; case "If": t.else !== MISMATCH && s(t.else), t.then !== MATCH && i(t.then), t = t.match; break; case "MatchOnce": t = { type: "MatchOnceBuffer", syntax: t, index: 0, mask: 0 }; break; case "MatchOnceBuffer": { const e = t.syntax.terms; if (t.index === e.length) { if (0 === t.mask || t.syntax.all) { t = MISMATCH; break } t = MATCH; break } if (t.mask === (1 << e.length) - 1) { t = MATCH; break } for (; t.index < e.length; t.index++) { const n = 1 << t.index; if (0 == (t.mask & n)) { s(t), i({ type: "AddMatchOnce", syntax: t.syntax, mask: t.mask | n }), t = e[t.index++]; break } } break } case "AddMatchOnce": t = { type: "MatchOnceBuffer", syntax: t.syntax, index: 0, mask: t.mask }; break; case "Enum": if (null !== g) { let e = g.value.toLowerCase(); if (-1 !== e.indexOf("\\") && (e = e.replace(/\\[09].*$/, "")), hasOwnProperty$7.call(t.map, e)) { t = t.map[e]; break } } t = MISMATCH; break; case "Generic": { const e = null !== u ? u.opts : null, n = b + Math.floor(t.fn(g, a, e)); if (!isNaN(n) && n > b) { for (; b < n;)l(); t = MATCH } else t = MISMATCH; break } case "Type": case "Property": { const e = "Type" === t.type ? "types" : "properties", r = hasOwnProperty$7.call(n, e) ? n[e][t.name] : null; if (!r || !r.match) throw new Error("Bad syntax reference: " + ("Type" === t.type ? "<" + t.name + ">" : "<'" + t.name + "'>")); if (!1 !== h && null !== g && "Type" === t.type) { if ("custom-ident" === t.name && g.type === Ident || "length" === t.name && "0" === g.value) { null === h && (h = o(t, p)), t = MISMATCH; break } } u = { syntax: t.syntax, opts: t.syntax.opts || null !== u && u.opts || null, prev: u }, $ = { type: OPEN_SYNTAX, syntax: t.syntax, token: $.token, prev: $ }, t = r.match; break } case "Keyword": { const e = t.name; if (null !== g) { let n = g.value; if (-1 !== n.indexOf("\\") && (n = n.replace(/\\[09].*$/, "")), areStringsEqualCaseInsensitive(n, e)) { l(), t = MATCH; break } } t = MISMATCH; break } case "AtKeyword": case "Function": if (null !== g && areStringsEqualCaseInsensitive(g.value, t.name)) { l(), t = MATCH; break } t = MISMATCH; break; case "Token": if (null !== g && g.value === t.value) { l(), t = MATCH; break } t = MISMATCH; break; case "Comma": null !== g && g.type === Comma ? isCommaContextStart($.token) ? t = MISMATCH : (l(), t = isCommaContextEnd(g) ? MISMATCH : MATCH) : t = isCommaContextStart($.token) || isCommaContextEnd(g) ? MATCH : MISMATCH; break; case "String": let r = "", m = b; for (; m < e.length && r.length < t.value.length; m++)r += e[m].value; if (areStringsEqualCaseInsensitive(r, t.value)) { for (; b < m;)l(); t = MATCH } else t = MISMATCH; break; default: throw new Error("Unknown node type: " + t.type) }switch (f) { case null: console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations"), f = EXIT_REASON_ITERATION_LIMIT, $ = null; break; case EXIT_REASON_MATCH: for (; null !== u;)c(); break; default: $ = null }return { tokens: e, reason: f, iterations: m, match: $, longestMatch: y } } function matchAsTree(e, t, n) { const r = internalMatch(e, t, n || {}); if (null === r.match) return r; let a = r.match, o = r.match = { syntax: t.syntax || null, match: [] }; const i = [o]; for (a = reverseList(a).prev; null !== a;) { switch (a.type) { case OPEN_SYNTAX: o.match.push(o = { syntax: a.syntax, match: [] }), i.push(o); break; case CLOSE_SYNTAX: i.pop(), o = i[i.length - 1]; break; default: o.match.push({ syntax: a.syntax || null, token: a.token.value, node: a.token.node }) }a = a.prev } return r } function getTrace(e) { function t(e) { return null !== e && ("Type" === e.type || "Property" === e.type || "Keyword" === e.type) } let n = null; return null !== this.matched && function r(a) { if (Array.isArray(a.match)) { for (let e = 0; e < a.match.length; e++)if (r(a.match[e])) return t(a.syntax) && n.unshift(a.syntax), !0 } else if (a.node === e) return n = t(a.syntax) ? [a.syntax] : [], !0; return !1 }(this.matched), n } function isType(e, t) { return testNode(this, e, (e => "Type" === e.type && e.name === t)) } function isProperty(e, t) { return testNode(this, e, (e => "Property" === e.type && e.name === t)) } function isKeyword(e) { return testNode(this, e, (e => "Keyword" === e.type)) } function testNode(e, t, n) { const r = getTrace.call(e, t); return null !== r && r.some(n) } var trace = Object.freeze({ __proto__: null, getTrace: getTrace, isKeyword: isKeyword, isProperty: isProperty, isType: isType }); function getFirstMatchNode(e) { return "node" in e ? e.node : getFirstMatchNode(e.match[0]) } function getLastMatchNode(e) { return "node" in e ? e.node : getLastMatchNode(e.match[e.match.length - 1]) } function matchFragments(e, t, n, r, a) { const o = []; return null !== n.matched && function n(i) { if (null !== i.syntax && i.syntax.type === r && i.syntax.name === a) { const n = getFirstMatchNode(i), r = getLastMatchNode(i); e.syntax.walk(t, (function (e, t, a) { if (e === n) { const e = new List; do { if (e.appendData(t.data), t.data === r) break; t = t.next } while (null !== t); o.push({ parent: a, nodes: e }) } })) } Array.isArray(i.match) && i.match.forEach(n) }(n.matched), o } const { hasOwnProperty: hasOwnProperty$6 } = Object.prototype; function isValidNumber(e) { return "number" == typeof e && isFinite(e) && Math.floor(e) === e && e >= 0 } function isValidLocation(e) { return Boolean(e) && isValidNumber(e.offset) && isValidNumber(e.line) && isValidNumber(e.column) } function createNodeStructureChecker(e, t) { return function (n, r) { if (!n || n.constructor !== Object) return r(n, "Type of node should be an Object"); for (let a in n) { let o = !0; if (!1 !== hasOwnProperty$6.call(n, a)) { if ("type" === a) n.type !== e && r(n, "Wrong node type `" + n.type + "`, expected `" + e + "`"); else if ("loc" === a) { if (null === n.loc) continue; if (n.loc && n.loc.constructor === Object) if ("string" != typeof n.loc.source) a += ".source"; else if (isValidLocation(n.loc.start)) { if (isValidLocation(n.loc.end)) continue; a += ".end" } else a += ".start"; o = !1 } else if (t.hasOwnProperty(a)) { o = !1; for (let e = 0; !o && e < t[a].length; e++) { const r = t[a][e]; switch (r) { case String: o = "string" == typeof n[a]; break; case Boolean: o = "boolean" == typeof n[a]; break; case null: o = null === n[a]; break; default: "string" == typeof r ? o = n[a] && n[a].type === r : Array.isArray(r) && (o = n[a] instanceof List) } } } else r(n, "Unknown field `" + a + "` for " + e + " node type"); o || r(n, "Bad value for `" + e + "." + a + "`") } } for (const a in t) hasOwnProperty$6.call(t, a) && !1 === hasOwnProperty$6.call(n, a) && r(n, "Field `" + e + "." + a + "` is missed") } } function processStructure(e, t) { const n = t.structure, r = { type: String, loc: !0 }, a = { type: '"' + e + '"' }; for (const t in n) { if (!1 === hasOwnProperty$6.call(n, t)) continue; const o = [], i = r[t] = Array.isArray(n[t]) ? n[t].slice() : [n[t]]; for (let n = 0; n < i.length; n++) { const r = i[n]; if (r === String || r === Boolean) o.push(r.name); else if (null === r) o.push("null"); else if ("string" == typeof r) o.push("<" + r + ">"); else { if (!Array.isArray(r)) throw new Error("Wrong value `" + r + "` in `" + e + "." + t + "` structure definition"); o.push("List") } } a[t] = o.join(" | ") } return { docs: a, check: createNodeStructureChecker(e, r) } } function getStructureFromConfig(e) { const t = {}; if (e.node) for (const n in e.node) if (hasOwnProperty$6.call(e.node, n)) { const r = e.node[n]; if (!r.structure) throw new Error("Missed `structure` field in `" + n + "` node type definition"); t[n] = processStructure(n, r) } return t } const cssWideKeywordsSyntax = buildMatchGraph(cssWideKeywords.join(" | ")); function dumpMapSyntax(e, t, n) { const r = {}; for (const a in e) e[a].syntax && (r[a] = n ? e[a].syntax : generate$H(e[a].syntax, { compact: t })); return r } function dumpAtruleMapSyntax(e, t, n) { const r = {}; for (const [a, o] of Object.entries(e)) r[a] = { prelude: o.prelude && (n ? o.prelude.syntax : generate$H(o.prelude.syntax, { compact: t })), descriptors: o.descriptors && dumpMapSyntax(o.descriptors, t, n) }; return r } function valueHasVar(e) { for (let t = 0; t < e.length; t++)if ("var(" === e[t].value.toLowerCase()) return !0; return !1 } function buildMatchResult(e, t, n) { return { matched: e, iterations: n, error: t, ...trace } } function matchSyntax(e, t, n, r) { const a = prepareTokens(n, e.syntax); let o; return valueHasVar(a) ? buildMatchResult(null, new Error("Matching for a tree with var() is not supported")) : (r && (o = matchAsTree(a, e.cssWideKeywordsSyntax, e)), r && o.match || (o = matchAsTree(a, t.match, e), o.match) ? buildMatchResult(o.match, null, o.iterations) : buildMatchResult(null, new SyntaxMatchError(o.reason, t.syntax, n, o), o.iterations)) } class Lexer { constructor(e, t, n) { if (this.cssWideKeywordsSyntax = cssWideKeywordsSyntax, this.syntax = t, this.generic = !1, this.atrules = Object.create(null), this.properties = Object.create(null), this.types = Object.create(null), this.structure = n || getStructureFromConfig(e), e) { if (e.types) for (const t in e.types) this.addType_(t, e.types[t]); if (e.generic) { this.generic = !0; for (const e in generic) this.addType_(e, generic[e]) } if (e.atrules) for (const t in e.atrules) this.addAtrule_(t, e.atrules[t]); if (e.properties) for (const t in e.properties) this.addProperty_(t, e.properties[t]) } } checkStructure(e) { function t(e, t) { r.push({ node: e, message: t }) } const n = this.structure, r = []; return this.syntax.walk(e, (function (e) { n.hasOwnProperty(e.type) ? n[e.type].check(e, t) : t(e, "Unknown node type `" + e.type + "`") })), !!r.length && r } createDescriptor(e, t, n, r = null) { const a = { type: t, name: n }, o = { type: t, name: n, parent: r, serializable: "string" == typeof e || e && "string" == typeof e.type, syntax: null, match: null }; return "function" == typeof e ? o.match = buildMatchGraph(e, a) : ("string" == typeof e ? Object.defineProperty(o, "syntax", { get: () => (Object.defineProperty(o, "syntax", { value: parse$H(e) }), o.syntax) }) : o.syntax = e, Object.defineProperty(o, "match", { get: () => (Object.defineProperty(o, "match", { value: buildMatchGraph(o.syntax, a) }), o.match) })), o } addAtrule_(e, t) { t && (this.atrules[e] = { type: "Atrule", name: e, prelude: t.prelude ? this.createDescriptor(t.prelude, "AtrulePrelude", e) : null, descriptors: t.descriptors ? Object.keys(t.descriptors).reduce(((n, r) => (n[r] = this.createDescriptor(t.descriptors[r], "AtruleDescriptor", r, e), n)), Object.create(null)) : null }) } addProperty_(e, t) { t && (this.properties[e] = this.createDescriptor(t, "Property", e)) } addType_(e, t) { t && (this.types[e] = this.createDescriptor(t, "Type", e)) } checkAtruleName(e) { if (!this.getAtrule(e)) return new SyntaxReferenceError("Unknown at-rule", "@" + e) } checkAtrulePrelude(e, t) { const n = this.checkAtruleName(e); if (n) return n; const r = this.getAtrule(e); return !r.prelude && t ? new SyntaxError("At-rule `@" + e + "` should not contain a prelude") : !r.prelude || t || matchSyntax(this, r.prelude, "", !1).matched ? void 0 : new SyntaxError("At-rule `@" + e + "` should contain a prelude") } checkAtruleDescriptorName(e, t) { const n = this.checkAtruleName(e); if (n) return n; const r = this.getAtrule(e), a = keyword(t); return r.descriptors ? r.descriptors[a.name] || r.descriptors[a.basename] ? void 0 : new SyntaxReferenceError("Unknown at-rule descriptor", t) : new SyntaxError("At-rule `@" + e + "` has no known descriptors") } checkPropertyName(e) { if (!this.getProperty(e)) return new SyntaxReferenceError("Unknown property", e) } matchAtrulePrelude(e, t) { const n = this.checkAtrulePrelude(e, t); if (n) return buildMatchResult(null, n); const r = this.getAtrule(e); return r.prelude ? matchSyntax(this, r.prelude, t || "", !1) : buildMatchResult(null, null) } matchAtruleDescriptor(e, t, n) { const r = this.checkAtruleDescriptorName(e, t); if (r) return buildMatchResult(null, r); const a = this.getAtrule(e), o = keyword(t); return matchSyntax(this, a.descriptors[o.name] || a.descriptors[o.basename], n, !1) } matchDeclaration(e) { return "Declaration" !== e.type ? buildMatchResult(null, new Error("Not a Declaration node")) : this.matchProperty(e.property, e.value) } matchProperty(e, t) { if (property(e).custom) return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties")); const n = this.checkPropertyName(e); return n ? buildMatchResult(null, n) : matchSyntax(this, this.getProperty(e), t, !0) } matchType(e, t) { const n = this.getType(e); return n ? matchSyntax(this, n, t, !1) : buildMatchResult(null, new SyntaxReferenceError("Unknown type", e)) } match(e, t) { return "string" == typeof e || e && e.type ? ("string" != typeof e && e.match || (e = this.createDescriptor(e, "Type", "anonymous")), matchSyntax(this, e, t, !1)) : buildMatchResult(null, new SyntaxReferenceError("Bad syntax")) } findValueFragments(e, t, n, r) { return matchFragments(this, t, this.matchProperty(e, t), n, r) } findDeclarationValueFragments(e, t, n) { return matchFragments(this, e.value, this.matchDeclaration(e), t, n) } findAllFragments(e, t, n) { const r = []; return this.syntax.walk(e, { visit: "Declaration", enter: e => { r.push.apply(r, this.findDeclarationValueFragments(e, t, n)) } }), r } getAtrule(e, t = !0) { const n = keyword(e); return (n.vendor && t ? this.atrules[n.name] || this.atrules[n.basename] : this.atrules[n.name]) || null } getAtrulePrelude(e, t = !0) { const n = this.getAtrule(e, t); return n && n.prelude || null } getAtruleDescriptor(e, t) { return this.atrules.hasOwnProperty(e) && this.atrules.declarators && this.atrules[e].declarators[t] || null } getProperty(e, t = !0) { const n = property(e); return (n.vendor && t ? this.properties[n.name] || this.properties[n.basename] : this.properties[n.name]) || null } getType(e) { return hasOwnProperty.call(this.types, e) ? this.types[e] : null } validate() { function e(r, a, o, i) { if (o.has(a)) return o.get(a); o.set(a, !1), null !== i.syntax && walk$2(i.syntax, (function (i) { if ("Type" !== i.type && "Property" !== i.type) return; const s = "Type" === i.type ? r.types : r.properties, l = "Type" === i.type ? t : n; hasOwnProperty.call(s, i.name) && !e(r, i.name, l, s[i.name]) || o.set(a, !0) }), this) } let t = new Map, n = new Map; for (const n in this.types) e(this, n, t, this.types[n]); for (const t in this.properties) e(this, t, n, this.properties[t]); return t = [...t.keys()].filter((e => t.get(e))), n = [...n.keys()].filter((e => n.get(e))), t.length || n.length ? { types: t, properties: n } : null } dump(e, t) { return { generic: this.generic, types: dumpMapSyntax(this.types, !t, e), properties: dumpMapSyntax(this.properties, !t, e), atrules: dumpAtruleMapSyntax(this.atrules, !t, e) } } toString() { return JSON.stringify(this.dump()) } } const { hasOwnProperty: hasOwnProperty$5 } = Object.prototype, shape = { generic: !0, types: appendOrAssign, atrules: { prelude: appendOrAssignOrNull, descriptors: appendOrAssignOrNull }, properties: appendOrAssign, parseContext: assign, scope: deepAssign, atrule: ["parse"], pseudo: ["parse"], node: ["name", "structure", "parse", "generate", "walkContext"] }; function isObject(e) { return e && e.constructor === Object } function copy(e) { return isObject(e) ? { ...e } : e } function assign(e, t) { return Object.assign(e, t) } function deepAssign(e, t) { for (const n in t) hasOwnProperty$5.call(t, n) && (isObject(e[n]) ? deepAssign(e[n], t[n]) : e[n] = copy(t[n])); return e } function append(e, t) { return "string" == typeof t && /^\s*\|/.test(t) ? "string" == typeof e ? e + t : t.replace(/^\s*\|\s*/, "") : t || null } function appendOrAssign(e, t) { if ("string" == typeof t) return append(e, t); const n = { ...e }; for (let r in t) hasOwnProperty$5.call(t, r) && (n[r] = append(hasOwnProperty$5.call(e, r) ? e[r] : void 0, t[r])); return n } function appendOrAssignOrNull(e, t) { const n = appendOrAssign(e, t); return !isObject(n) || Object.keys(n).length ? n : null } function mix(e, t, n) { for (const r in n) if (!1 !== hasOwnProperty$5.call(n, r)) if (!0 === n[r]) hasOwnProperty$5.call(t, r) && (e[r] = copy(t[r])); else if (n[r]) if ("function" == typeof n[r]) { const a = n[r]; e[r] = a({}, e[r]), e[r] = a(e[r] || {}, t[r]) } else if (isObject(n[r])) { const a = {}; for (let t in e[r]) a[t] = mix({}, e[r][t], n[r]); for (let e in t[r]) a[e] = mix(a[e] || {}, t[r][e], n[r]); e[r] = a } else if (Array.isArray(n[r])) { const a = {}, o = n[r].reduce((function (e, t) { return e[t] = !0, e }), {}); for (const [t, n] of Object.entries(e[r] || {})) a[t] = {}, n && mix(a[t], n, o); for (const e in t[r]) hasOwnProperty$5.call(t[r], e) && (a[e] || (a[e] = {}), t[r] && t[r][e] && mix(a[e], t[r][e], o)); e[r] = a } return e } var mix$1 = (e, t) => mix(e, t, shape); function createSyntax(e) { const t = createParser(e), n = createWalker(e), r = createGenerator(e), { fromPlainObject: a, toPlainObject: o } = createConvertor(n), i = { lexer: null, createLexer: e => new Lexer(e, i, i.lexer.structure), tokenize: tokenize$2, parse: t, generate: r, walk: n, find: n.find, findLast: n.findLast, findAll: n.findAll, fromPlainObject: a, toPlainObject: o, fork(t) { const n = mix$1({}, e); return createSyntax("function" == typeof t ? t(n, Object.assign) : mix$1(n, t)) } }; return i.lexer = new Lexer({ generic: !0, types: e.types, atrules: e.atrules, properties: e.properties, node: e.node }, i), i } var createSyntax$1 = e => createSyntax(mix$1({}, e)), definitions = { generic: !0, types: { "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large", "alpha-value": "<number>|<percentage>", "angle-percentage": "<angle>|<percentage>", "angular-color-hint": "<angle-percentage>", "angular-color-stop": "<color>&&<color-stop-angle>?", "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>", "animateable-feature": "scroll-position|contents|<custom-ident>", attachment: "scroll|fixed|local", "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )", "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='", "attr-modifier": "i|s", "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'", "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )", "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?", "baseline-position": "[first|last]? baseline", "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>", "bg-image": "none|<image>", "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>", "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]", "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain", "blur()": "blur( <length> )", "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity", box: "border-box|padding-box|content-box", "brightness()": "brightness( <number-percentage> )", "calc()": "calc( <calc-sum> )", "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*", "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*", "calc-value": "<number>|<dimension>|<percentage>|( <calc-sum> )", "cf-final-image": "<image>|<color>", "cf-mixing-image": "<percentage>?&&<image>", "circle()": "circle( [<shape-radius>]? [at <position>]? )", "clamp()": "clamp( <calc-sum>#{3} )", "class-selector": "'.' <ident-token>", "clip-source": "<url>", color: "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>", "color-stop": "<color-stop-length>|<color-stop-angle>", "color-stop-angle": "<angle-percentage>{1,2}", "color-stop-length": "<length-percentage>{1,2}", "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>", combinator: "'>'|'+'|'~'|['||']", "common-lig-values": "[common-ligatures|no-common-ligatures]", "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button", "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor", "compositing-operator": "add|subtract|intersect|exclude", "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!", "compound-selector-list": "<compound-selector>#", "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*", "complex-selector-list": "<complex-selector>#", "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )", "contextual-alt-values": "[contextual|no-contextual]", "content-distribution": "space-between|space-around|space-evenly|stretch", "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+", "content-position": "center|start|end|flex-start|flex-end", "content-replacement": "<image>", "contrast()": "contrast( [<number-percentage>] )", counter: "<counter()>|<counters()>", "counter()": "counter( <counter-name> , <counter-style>? )", "counter-name": "<custom-ident>", "counter-style": "<counter-style-name>|symbols( )", "counter-style-name": "<custom-ident>", "counters()": "counters( <counter-name> , <string> , <counter-style>? )", "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )", "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )", "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText", "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]", "display-box": "contents|none", "display-inside": "flow|flow-root|table|flex|grid|ruby", "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container", "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid", "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item", "display-outside": "block|inline|run-in", "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )", "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]", "east-asian-width-values": "[full-width|proportional-width]", "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )", "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )", "ending-shape": "circle|ellipse", "env()": "env( <custom-ident> , <declaration-value>? )", "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?", "family-name": "<string>|<custom-ident>+", "feature-tag-value": "<string> [<integer>|on|off]?", "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation", "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'", "feature-value-block-list": "<feature-value-block>+", "feature-value-declaration": "<custom-ident> : <integer>+ ;", "feature-value-declaration-list": "<feature-value-declaration>", "feature-value-name": "<custom-ident>", "fill-rule": "nonzero|evenodd", "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>", "filter-function-list": "[<filter-function>|<url>]+", "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>", "fit-content()": "fit-content( [<length>|<percentage>] )", "fixed-breadth": "<length-percentage>", "fixed-repeat": "repeat( [<integer [1,]>] , [<line-names>? <fixed-size>]+ <line-names>? )", "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )", "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>", "font-variant-css21": "[normal|small-caps]", "font-weight-absolute": "normal|bold|<number [1,1000]>", "frequency-percentage": "<frequency>|<percentage>", "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )", "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system", "generic-name": "serif|sans-serif|cursive|fantasy|monospace", "geometry-box": "<shape-box>|fill-box|stroke-box|view-box", gradient: "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>", "grayscale()": "grayscale( <number-percentage> )", "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]", "historical-lig-values": "[historical-ligatures|no-historical-ligatures]", "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )", "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )", hue: "<number>|<angle>", "hue-rotate()": "hue-rotate( <angle> )", "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )", image: "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>", "image()": "image( <image-tags>? [<image-src>? , <color>?]! )", "image-set()": "image-set( <image-set-option># )", "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]", "image-src": "<url>|<string>", "image-tags": "ltr|rtl", "inflexible-breadth": "<length>|<percentage>|min-content|max-content|auto", "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )", "invert()": "invert( <number-percentage> )", "keyframes-name": "<custom-ident>|<string>", "keyframe-block": "<keyframe-selector># { <declaration-list> }", "keyframe-block-list": "<keyframe-block>+", "keyframe-selector": "from|to|<percentage>", "layer()": "layer( <layer-name> )", "layer-name": "<ident> ['.' <ident>]*", "leader()": "leader( <leader-type> )", "leader-type": "dotted|solid|space|<string>", "length-percentage": "<length>|<percentage>", "line-names": "'[' <custom-ident>* ']'", "line-name-list": "[<line-names>|<name-repeat>]+", "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset", "line-width": "<length>|thin|medium|thick", "linear-color-hint": "<length-percentage>", "linear-color-stop": "<color> <color-stop-length>?", "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )", "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>", "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?", "mask-reference": "none|<image>|<mask-source>", "mask-source": "<url>", "masking-mode": "alpha|luminance|match-source", "matrix()": "matrix( <number>#{6} )", "matrix3d()": "matrix3d( <number>#{16} )", "max()": "max( <calc-sum># )", "media-and": "<media-in-parens> [and <media-in-parens>]+", "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>", "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>", "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )", "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>", "media-not": "not <media-in-parens>", "media-or": "<media-in-parens> [or <media-in-parens>]+", "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?", "media-query-list": "<media-query>#", "media-type": "<ident>", "mf-boolean": "<mf-name>", "mf-name": "<ident>", "mf-plain": "<mf-name> : <mf-value>", "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>", "mf-value": "<number>|<dimension>|<ident>|<ratio>", "min()": "min( <calc-sum># )", "minmax()": "minmax( [<length>|<percentage>|min-content|max-content|auto] , [<length>|<percentage>|<flex>|min-content|max-content|auto] )", "name-repeat": "repeat( [<integer [1,]>|auto-fill] , <line-names>+ )", "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>", "namespace-prefix": "<ident>", "ns-prefix": "[<ident-token>|'*']? '|'", "number-percentage": "<number>|<percentage>", "numeric-figure-values": "[lining-nums|oldstyle-nums]", "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]", "numeric-spacing-values": "[proportional-nums|tabular-nums]", nth: "<an-plus-b>|even|odd", "opacity()": "opacity( [<number-percentage>] )", "overflow-position": "unsafe|safe", "outline-radius": "<length>|<percentage>", "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>", "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'", "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom", "page-selector-list": "[<page-selector>#]?", "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*", "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger", "path()": "path( [<fill-rule> ,]? <string> )", "paint()": "paint( <ident> , <declaration-value>? )", "perspective()": "perspective( <length> )", "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )", position: "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]", "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'", "pseudo-element-selector": "':' <pseudo-class-selector>", "pseudo-page": ": [left|right|first|blank]", quote: "open-quote|close-quote|no-open-quote|no-close-quote", "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )", "relative-selector": "<combinator>? <complex-selector>", "relative-selector-list": "<relative-selector>#", "relative-size": "larger|smaller", "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}", "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )", "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )", "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )", "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )", "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )", "rotate()": "rotate( [<angle>|<zero>] )", "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )", "rotateX()": "rotateX( [<angle>|<zero>] )", "rotateY()": "rotateY( [<angle>|<zero>] )", "rotateZ()": "rotateZ( [<angle>|<zero>] )", "saturate()": "saturate( <number-percentage> )", "scale()": "scale( <number> , <number>? )", "scale3d()": "scale3d( <number> , <number> , <number> )", "scaleX()": "scaleX( <number> )", "scaleY()": "scaleY( <number> )", "scaleZ()": "scaleZ( <number> )", "self-position": "center|start|end|self-start|self-end|flex-start|flex-end", "shape-radius": "<length-percentage>|closest-side|farthest-side", "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )", "skewX()": "skewX( [<angle>|<zero>] )", "skewY()": "skewY( [<angle>|<zero>] )", "sepia()": "sepia( <number-percentage> )", shadow: "inset?&&<length>{2,4}&&<color>?", "shadow-t": "[<length>{2,3}&&<color>?]", shape: "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )", "shape-box": "<box>|margin-box", "side-or-corner": "[left|right]||[top|bottom]", "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]", "single-animation-direction": "normal|reverse|alternate|alternate-reverse", "single-animation-fill-mode": "none|forwards|backwards|both", "single-animation-iteration-count": "infinite|<number>", "single-animation-play-state": "running|paused", "single-animation-timeline": "auto|none|<timeline-name>", "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>", "single-transition-property": "all|<custom-ident>", size: "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}", "step-position": "jump-start|jump-end|jump-none|jump-both|start|end", "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )", "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>", "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*", "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>", "supports-feature": "<supports-decl>|<supports-selector-fn>", "supports-decl": "( <declaration> )", "supports-selector-fn": "selector( <complex-selector> )", symbol: "<string>|<image>|<custom-ident>", target: "<target-counter()>|<target-counters()>|<target-text()>", "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )", "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )", "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )", "time-percentage": "<time>|<percentage>", "timeline-name": "<custom-ident>|<string>", "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>", "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto", "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?", "track-repeat": "repeat( [<integer [1,]>] , [<line-names>? <track-size>]+ <line-names>? )", "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( [<length>|<percentage>] )", "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>", "transform-list": "<transform-function>+", "translate()": "translate( <length-percentage> , <length-percentage>? )", "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )", "translateX()": "translateX( <length-percentage> )", "translateY()": "translateY( <length-percentage> )", "translateZ()": "translateZ( <length> )", "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%", "type-selector": "<wq-name>|<ns-prefix>? '*'", "var()": "var( <custom-property-name> , <declaration-value>? )", "viewport-length": "auto|<length-percentage>", "visual-box": "content-box|padding-box|border-box", "wq-name": "<ns-prefix>? <ident-token>", "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>", "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )", "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )", "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>", "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )", "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )", "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>", "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover", "-legacy-radial-gradient-shape": "circle|ellipse", "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body", "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text", "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast", "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable", "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content", "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )", "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )", "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]", "-webkit-gradient-radius": "<length>|<percentage>", "-webkit-gradient-type": "linear|radial", "-webkit-mask-box-repeat": "repeat|stretch|round", "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text", "-ms-filter-function-list": "<-ms-filter-function>+", "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>", "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]", "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )", "-ms-filter": "<string>", age: "child|young|old", "attr-name": "<wq-name>", "attr-fallback": "<any-value>", "bg-clip": "<box>|border|text", "border-radius": "<length-percentage>{1,2}", bottom: "<length>|auto", "generic-voice": "[<age>? <gender> <integer>?]", gender: "male|female|neutral", "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )", "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )", left: "<length>|auto", "mask-image": "<mask-reference>#", paint: "none|<color>|<url> [none|<color>]?|context-fill|context-stroke", ratio: "<number [0,]> [/ <number [0,]>]?", "reversed-counter-name": "reversed( <counter-name> )", right: "<length>|auto", "svg-length": "<percentage>|<length>|<number>", "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb", top: "<length>|auto", "track-group": "'(' [<string>* <track-minmax> <string>*]+ ')' ['[' <positive-integer> ']']?|<track-minmax>", "track-list-v0": "[<string>* <track-group> <string>*]+|none", "track-minmax": "minmax( <track-breadth> , <track-breadth> )|auto|<track-breadth>|fit-content", x: "<number>", y: "<number>", declaration: "<ident-token> : <declaration-value>? ['!' important]?", "declaration-list": "[<declaration>? ';']* <declaration>?", url: "url( <string> <url-modifier>* )|<url-token>", "url-modifier": "<ident>|<function-token> <any-value> )", "number-zero-one": "<number [0,1]>", "number-one-or-greater": "<number [1,]>", "positive-integer": "<integer [0,]>", "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box" }, properties: { "--*": "<declaration-value>", "-ms-accelerator": "false|true", "-ms-block-progression": "tb|rl|bt|lr", "-ms-content-zoom-chaining": "none|chained", "-ms-content-zooming": "none|zoom", "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>", "-ms-content-zoom-limit-max": "<percentage>", "-ms-content-zoom-limit-min": "<percentage>", "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>", "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )", "-ms-content-zoom-snap-type": "none|proximity|mandatory", "-ms-filter": "<string>", "-ms-flow-from": "[none|<custom-ident>]#", "-ms-flow-into": "[none|<custom-ident>]#", "-ms-grid-columns": "none|<track-list>|<auto-track-list>", "-ms-grid-rows": "none|<track-list>|<auto-track-list>", "-ms-high-contrast-adjust": "auto|none", "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}", "-ms-hyphenate-limit-lines": "no-limit|<integer>", "-ms-hyphenate-limit-zone": "<percentage>|<length>", "-ms-ime-align": "auto|after", "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar", "-ms-scrollbar-3dlight-color": "<color>", "-ms-scrollbar-arrow-color": "<color>", "-ms-scrollbar-base-color": "<color>", "-ms-scrollbar-darkshadow-color": "<color>", "-ms-scrollbar-face-color": "<color>", "-ms-scrollbar-highlight-color": "<color>", "-ms-scrollbar-shadow-color": "<color>", "-ms-scrollbar-track-color": "<color>", "-ms-scroll-chaining": "chained|none", "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>", "-ms-scroll-limit-x-max": "auto|<length>", "-ms-scroll-limit-x-min": "<length>", "-ms-scroll-limit-y-max": "auto|<length>", "-ms-scroll-limit-y-min": "<length>", "-ms-scroll-rails": "none|railed", "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )", "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )", "-ms-scroll-snap-type": "none|proximity|mandatory", "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>", "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>", "-ms-scroll-translation": "none|vertical-to-horizontal", "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space", "-ms-touch-select": "grippers|none", "-ms-user-select": "none|element|text", "-ms-wrap-flow": "auto|both|start|end|maximum|clear", "-ms-wrap-margin": "<length>", "-ms-wrap-through": "wrap|none", "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized", "-moz-binding": "<url>|none", "-moz-border-bottom-colors": "<color>+|none", "-moz-border-left-colors": "<color>+|none", "-moz-border-right-colors": "<color>+|none", "-moz-border-top-colors": "<color>+|none", "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#", "-moz-float-edge": "border-box|content-box|margin-box|padding-box", "-moz-force-broken-image-icon": "0|1", "-moz-image-region": "<shape>|auto", "-moz-orient": "inline|block|horizontal|vertical", "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?", "-moz-outline-radius-bottomleft": "<outline-radius>", "-moz-outline-radius-bottomright": "<outline-radius>", "-moz-outline-radius-topleft": "<outline-radius>", "-moz-outline-radius-topright": "<outline-radius>", "-moz-stack-sizing": "ignore|stretch-to-fit", "-moz-text-blink": "none|blink", "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none", "-moz-user-input": "auto|none|enabled|disabled", "-moz-user-modify": "read-only|read-write|write-only", "-moz-window-dragging": "drag|no-drag", "-moz-window-shadow": "default|menu|tooltip|sheet|none", "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button", "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>", "-webkit-border-before-color": "<color>", "-webkit-border-before-style": "<'border-style'>", "-webkit-border-before-width": "<'border-width'>", "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?", "-webkit-line-clamp": "none|<integer>", "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#", "-webkit-mask-attachment": "<attachment>#", "-webkit-mask-clip": "[<box>|border|padding|content|text]#", "-webkit-mask-composite": "<composite-style>#", "-webkit-mask-image": "<mask-reference>#", "-webkit-mask-origin": "[<box>|border|padding|content]#", "-webkit-mask-position": "<position>#", "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#", "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#", "-webkit-mask-repeat": "<repeat-style>#", "-webkit-mask-repeat-x": "repeat|no-repeat|space|round", "-webkit-mask-repeat-y": "repeat|no-repeat|space|round", "-webkit-mask-size": "<bg-size>#", "-webkit-overflow-scrolling": "auto|touch", "-webkit-tap-highlight-color": "<color>", "-webkit-text-fill-color": "<color>", "-webkit-text-stroke": "<length>||<color>", "-webkit-text-stroke-color": "<color>", "-webkit-text-stroke-width": "<length>", "-webkit-touch-callout": "default|none", "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only", "accent-color": "auto|<color>", "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>", "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]", "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>", "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#", all: "initial|inherit|unset|revert|revert-layer", animation: "<single-animation>#", "animation-delay": "<time>#", "animation-direction": "<single-animation-direction>#", "animation-duration": "<time>#", "animation-fill-mode": "<single-animation-fill-mode>#", "animation-iteration-count": "<single-animation-iteration-count>#", "animation-name": "[none|<keyframes-name>]#", "animation-play-state": "<single-animation-play-state>#", "animation-timing-function": "<easing-function>#", "animation-timeline": "<single-animation-timeline>#", appearance: "none|auto|textfield|menulist-button|<compat-auto>", "aspect-ratio": "auto|<ratio>", azimuth: "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards", "backdrop-filter": "none|<filter-function-list>", "backface-visibility": "visible|hidden", background: "[<bg-layer> ,]* <final-bg-layer>", "background-attachment": "<attachment>#", "background-blend-mode": "<blend-mode>#", "background-clip": "<bg-clip>#", "background-color": "<color>", "background-image": "<bg-image>#", "background-origin": "<box>#", "background-position": "<bg-position>#", "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#", "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#", "background-repeat": "<repeat-style>#", "background-size": "<bg-size>#", "block-overflow": "clip|ellipsis|<string>", "block-size": "<'width'>", border: "<line-width>||<line-style>||<color>", "border-block": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-color": "<'border-top-color'>{1,2}", "border-block-style": "<'border-top-style'>", "border-block-width": "<'border-top-width'>", "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-end-color": "<'border-top-color'>", "border-block-end-style": "<'border-top-style'>", "border-block-end-width": "<'border-top-width'>", "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-start-color": "<'border-top-color'>", "border-block-start-style": "<'border-top-style'>", "border-block-start-width": "<'border-top-width'>", "border-bottom": "<line-width>||<line-style>||<color>", "border-bottom-color": "<'border-top-color'>", "border-bottom-left-radius": "<length-percentage>{1,2}", "border-bottom-right-radius": "<length-percentage>{1,2}", "border-bottom-style": "<line-style>", "border-bottom-width": "<line-width>", "border-collapse": "collapse|separate", "border-color": "<color>{1,4}", "border-end-end-radius": "<length-percentage>{1,2}", "border-end-start-radius": "<length-percentage>{1,2}", "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>", "border-image-outset": "[<length>|<number>]{1,4}", "border-image-repeat": "[stretch|repeat|round|space]{1,2}", "border-image-slice": "<number-percentage>{1,4}&&fill?", "border-image-source": "none|<image>", "border-image-width": "[<length-percentage>|<number>|auto]{1,4}", "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-color": "<'border-top-color'>{1,2}", "border-inline-style": "<'border-top-style'>", "border-inline-width": "<'border-top-width'>", "border-inline-end-color": "<'border-top-color'>", "border-inline-end-style": "<'border-top-style'>", "border-inline-end-width": "<'border-top-width'>", "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-start-color": "<'border-top-color'>", "border-inline-start-style": "<'border-top-style'>", "border-inline-start-width": "<'border-top-width'>", "border-left": "<line-width>||<line-style>||<color>", "border-left-color": "<color>", "border-left-style": "<line-style>", "border-left-width": "<line-width>", "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?", "border-right": "<line-width>||<line-style>||<color>", "border-right-color": "<color>", "border-right-style": "<line-style>", "border-right-width": "<line-width>", "border-spacing": "<length> <length>?", "border-start-end-radius": "<length-percentage>{1,2}", "border-start-start-radius": "<length-percentage>{1,2}", "border-style": "<line-style>{1,4}", "border-top": "<line-width>||<line-style>||<color>", "border-top-color": "<color>", "border-top-left-radius": "<length-percentage>{1,2}", "border-top-right-radius": "<length-percentage>{1,2}", "border-top-style": "<line-style>", "border-top-width": "<line-width>", "border-width": "<line-width>{1,4}", bottom: "<length>|<percentage>|auto", "box-align": "start|center|end|baseline|stretch", "box-decoration-break": "slice|clone", "box-direction": "normal|reverse|inherit", "box-flex": "<number>", "box-flex-group": "<integer>", "box-lines": "single|multiple", "box-ordinal-group": "<integer>", "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit", "box-pack": "start|center|end|justify", "box-shadow": "none|<shadow>#", "box-sizing": "content-box|border-box", "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region", "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region", "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region", "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end", "caret-color": "auto|<color>", clear: "none|left|right|both|inline-start|inline-end", clip: "<shape>|auto", "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none", color: "<color>", "print-color-adjust": "economy|exact", "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?", "column-count": "<integer>|auto", "column-fill": "auto|balance|balance-all", "column-gap": "normal|<length-percentage>", "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>", "column-rule-color": "<color>", "column-rule-style": "<'border-style'>", "column-rule-width": "<'border-width'>", "column-span": "none|all", "column-width": "<length>|auto", columns: "<'column-width'>||<'column-count'>", contain: "none|strict|content|[size||layout||style||paint]", content: "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?", "content-visibility": "visible|auto|hidden", "counter-increment": "[<counter-name> <integer>?]+|none", "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none", "counter-set": "[<counter-name> <integer>?]+|none", cursor: "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]", direction: "ltr|rtl", display: "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>", "empty-cells": "show|hide", filter: "none|<filter-function-list>|<-ms-filter-function-list>", flex: "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]", "flex-basis": "content|<'width'>", "flex-direction": "row|row-reverse|column|column-reverse", "flex-flow": "<'flex-direction'>||<'flex-wrap'>", "flex-grow": "<number>", "flex-shrink": "<number>", "flex-wrap": "nowrap|wrap|wrap-reverse", float: "left|right|none|inline-start|inline-end", font: "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar", "font-family": "[<family-name>|<generic-family>]#", "font-feature-settings": "normal|<feature-tag-value>#", "font-kerning": "auto|normal|none", "font-language-override": "normal|<string>", "font-optical-sizing": "auto|none", "font-variation-settings": "normal|[<string> <number>]#", "font-size": "<absolute-size>|<relative-size>|<length-percentage>", "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]", "font-smooth": "auto|never|always|<absolute-size>|<length>", "font-stretch": "<font-stretch-absolute>", "font-style": "normal|italic|oblique <angle>?", "font-synthesis": "none|[weight||style||small-caps]", "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]", "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]", "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps", "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]", "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]", "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]", "font-variant-position": "normal|sub|super", "font-weight": "<font-weight-absolute>|bolder|lighter", "forced-color-adjust": "auto|none", gap: "<'row-gap'> <'column-gap'>?", grid: "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>", "grid-area": "<grid-line> [/ <grid-line>]{0,3}", "grid-auto-columns": "<track-size>+", "grid-auto-flow": "[row|column]||dense", "grid-auto-rows": "<track-size>+", "grid-column": "<grid-line> [/ <grid-line>]?", "grid-column-end": "<grid-line>", "grid-column-gap": "<length-percentage>", "grid-column-start": "<grid-line>", "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?", "grid-row": "<grid-line> [/ <grid-line>]?", "grid-row-end": "<grid-line>", "grid-row-gap": "<length-percentage>", "grid-row-start": "<grid-line>", "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?", "grid-template-areas": "none|<string>+", "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?", "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?", "hanging-punctuation": "none|[first||[force-end|allow-end]||last]", height: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "hyphenate-character": "auto|<string>", hyphens: "none|manual|auto", "image-orientation": "from-image|<angle>|[<angle>? flip]", "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>", "image-resolution": "[from-image||<resolution>]&&snap?", "ime-mode": "auto|normal|active|inactive|disabled", "initial-letter": "normal|[<number> <integer>?]", "initial-letter-align": "[auto|alphabetic|hanging|ideographic]", "inline-size": "<'width'>", "input-security": "auto|none", inset: "<'top'>{1,4}", "inset-block": "<'top'>{1,2}", "inset-block-end": "<'top'>", "inset-block-start": "<'top'>", "inset-inline": "<'top'>{1,2}", "inset-inline-end": "<'top'>", "inset-inline-start": "<'top'>", isolation: "auto|isolate", "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]", "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]", "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]", "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#", left: "<length>|<percentage>|auto", "letter-spacing": "normal|<length-percentage>", "line-break": "auto|loose|normal|strict|anywhere", "line-clamp": "none|<integer>", "line-height": "normal|<number>|<length>|<percentage>", "line-height-step": "<length>", "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>", "list-style-image": "<image>|none", "list-style-position": "inside|outside", "list-style-type": "<counter-style>|<string>|none", margin: "[<length>|<percentage>|auto]{1,4}", "margin-block": "<'margin-left'>{1,2}", "margin-block-end": "<'margin-left'>", "margin-block-start": "<'margin-left'>", "margin-bottom": "<length>|<percentage>|auto", "margin-inline": "<'margin-left'>{1,2}", "margin-inline-end": "<'margin-left'>", "margin-inline-start": "<'margin-left'>", "margin-left": "<length>|<percentage>|auto", "margin-right": "<length>|<percentage>|auto", "margin-top": "<length>|<percentage>|auto", "margin-trim": "none|in-flow|all", mask: "<mask-layer>#", "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>", "mask-border-mode": "luminance|alpha", "mask-border-outset": "[<length>|<number>]{1,4}", "mask-border-repeat": "[stretch|repeat|round|space]{1,2}", "mask-border-slice": "<number-percentage>{1,4} fill?", "mask-border-source": "none|<image>", "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}", "mask-clip": "[<geometry-box>|no-clip]#", "mask-composite": "<compositing-operator>#", "mask-image": "<mask-reference>#", "mask-mode": "<masking-mode>#", "mask-origin": "<geometry-box>#", "mask-position": "<position>#", "mask-repeat": "<repeat-style>#", "mask-size": "<bg-size>#", "mask-type": "luminance|alpha", "masonry-auto-flow": "[pack|next]||[definite-first|ordered]", "math-style": "normal|compact", "max-block-size": "<'max-width'>", "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "max-inline-size": "<'max-width'>", "max-lines": "none|<integer>", "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>", "min-block-size": "<'min-width'>", "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "min-inline-size": "<'min-width'>", "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>", "mix-blend-mode": "<blend-mode>|plus-lighter", "object-fit": "fill|contain|cover|none|scale-down", "object-position": "<position>", offset: "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?", "offset-anchor": "auto|<position>", "offset-distance": "<length-percentage>", "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]", "offset-position": "auto|<position>", "offset-rotate": "[auto|reverse]||<angle>", opacity: "<alpha-value>", order: "<integer>", orphans: "<integer>", outline: "[<'outline-color'>||<'outline-style'>||<'outline-width'>]", "outline-color": "<color>|invert", "outline-offset": "<length>", "outline-style": "auto|<'border-style'>", "outline-width": "<line-width>", overflow: "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>", "overflow-anchor": "auto|none", "overflow-block": "visible|hidden|clip|scroll|auto", "overflow-clip-box": "padding-box|content-box", "overflow-clip-margin": "<visual-box>||<length [0,]>", "overflow-inline": "visible|hidden|clip|scroll|auto", "overflow-wrap": "normal|break-word|anywhere", "overflow-x": "visible|hidden|clip|scroll|auto", "overflow-y": "visible|hidden|clip|scroll|auto", "overscroll-behavior": "[contain|none|auto]{1,2}", "overscroll-behavior-block": "contain|none|auto", "overscroll-behavior-inline": "contain|none|auto", "overscroll-behavior-x": "contain|none|auto", "overscroll-behavior-y": "contain|none|auto", padding: "[<length>|<percentage>]{1,4}", "padding-block": "<'padding-left'>{1,2}", "padding-block-end": "<'padding-left'>", "padding-block-start": "<'padding-left'>", "padding-bottom": "<length>|<percentage>", "padding-inline": "<'padding-left'>{1,2}", "padding-inline-end": "<'padding-left'>", "padding-inline-start": "<'padding-left'>", "padding-left": "<length>|<percentage>", "padding-right": "<length>|<percentage>", "padding-top": "<length>|<percentage>", "page-break-after": "auto|always|avoid|left|right|recto|verso", "page-break-before": "auto|always|avoid|left|right|recto|verso", "page-break-inside": "auto|avoid", "paint-order": "normal|[fill||stroke||markers]", perspective: "none|<length>", "perspective-origin": "<position>", "place-content": "<'align-content'> <'justify-content'>?", "place-items": "<'align-items'> <'justify-items'>?", "place-self": "<'align-self'> <'justify-self'>?", "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit", position: "static|relative|absolute|sticky|fixed|-webkit-sticky", quotes: "none|auto|[<string> <string>]+", resize: "none|both|horizontal|vertical|block|inline", right: "<length>|<percentage>|auto", rotate: "none|<angle>|[x|y|z|<number>{3}]&&<angle>", "row-gap": "normal|<length-percentage>", "ruby-align": "start|center|space-between|space-around", "ruby-merge": "separate|collapse|auto", "ruby-position": "[alternate||[over|under]]|inter-character", scale: "none|<number>{1,3}", "scrollbar-color": "auto|<color>{2}", "scrollbar-gutter": "auto|stable&&both-edges?", "scrollbar-width": "auto|thin|none", "scroll-behavior": "auto|smooth", "scroll-margin": "<length>{1,4}", "scroll-margin-block": "<length>{1,2}", "scroll-margin-block-start": "<length>", "scroll-margin-block-end": "<length>", "scroll-margin-bottom": "<length>", "scroll-margin-inline": "<length>{1,2}", "scroll-margin-inline-start": "<length>", "scroll-margin-inline-end": "<length>", "scroll-margin-left": "<length>", "scroll-margin-right": "<length>", "scroll-margin-top": "<length>", "scroll-padding": "[auto|<length-percentage>]{1,4}", "scroll-padding-block": "[auto|<length-percentage>]{1,2}", "scroll-padding-block-start": "auto|<length-percentage>", "scroll-padding-block-end": "auto|<length-percentage>", "scroll-padding-bottom": "auto|<length-percentage>", "scroll-padding-inline": "[auto|<length-percentage>]{1,2}", "scroll-padding-inline-start": "auto|<length-percentage>", "scroll-padding-inline-end": "auto|<length-percentage>", "scroll-padding-left": "auto|<length-percentage>", "scroll-padding-right": "auto|<length-percentage>", "scroll-padding-top": "auto|<length-percentage>", "scroll-snap-align": "[none|start|end|center]{1,2}", "scroll-snap-coordinate": "none|<position>#", "scroll-snap-destination": "<position>", "scroll-snap-points-x": "none|repeat( <length-percentage> )", "scroll-snap-points-y": "none|repeat( <length-percentage> )", "scroll-snap-stop": "normal|always", "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?", "scroll-snap-type-x": "none|mandatory|proximity", "scroll-snap-type-y": "none|mandatory|proximity", "shape-image-threshold": "<alpha-value>", "shape-margin": "<length-percentage>", "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>", "tab-size": "<integer>|<length>", "table-layout": "auto|fixed", "text-align": "start|end|left|right|center|justify|match-parent", "text-align-last": "auto|start|end|left|right|center|justify", "text-combine-upright": "none|all|[digits <integer>?]", "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>", "text-decoration-color": "<color>", "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error", "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]", "text-decoration-skip-ink": "auto|all|none", "text-decoration-style": "solid|double|dotted|dashed|wavy", "text-decoration-thickness": "auto|from-font|<length>|<percentage>", "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>", "text-emphasis-color": "<color>", "text-emphasis-position": "[over|under]&&[right|left]", "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>", "text-indent": "<length-percentage>&&hanging?&&each-line?", "text-justify": "auto|inter-character|inter-word|none", "text-orientation": "mixed|upright|sideways", "text-overflow": "[clip|ellipsis|<string>]{1,2}", "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision", "text-shadow": "none|<shadow-t>#", "text-size-adjust": "none|auto|<percentage>", "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana", "text-underline-offset": "auto|<length>|<percentage>", "text-underline-position": "auto|from-font|[under||[left|right]]", top: "<length>|<percentage>|auto", "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation", transform: "none|<transform-list>", "transform-box": "content-box|border-box|fill-box|stroke-box|view-box", "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?", "transform-style": "flat|preserve-3d", transition: "<single-transition>#", "transition-delay": "<time>#", "transition-duration": "<time>#", "transition-property": "none|<single-transition-property>#", "transition-timing-function": "<easing-function>#", translate: "none|<length-percentage> [<length-percentage> <length>?]?", "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext", "user-select": "auto|text|none|contain|all", "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>", visibility: "visible|hidden|collapse", "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces", widows: "<integer>", width: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fill|stretch|intrinsic|-moz-max-content|-webkit-max-content|-moz-fit-content|-webkit-fit-content", "will-change": "auto|<animateable-feature>#", "word-break": "normal|break-all|keep-all|break-word", "word-spacing": "normal|<length>", "word-wrap": "normal|break-word", "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>", "z-index": "auto|<integer>", zoom: "normal|reset|<number>|<percentage>", "-moz-background-clip": "padding|border", "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>", "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>", "-moz-border-radius-topleft": "<'border-top-left-radius'>", "-moz-border-radius-topright": "<'border-bottom-right-radius'>", "-moz-control-character-visibility": "visible|hidden", "-moz-osx-font-smoothing": "auto|grayscale", "-moz-user-select": "none|text|all|-moz-none", "-ms-flex-align": "start|end|center|baseline|stretch", "-ms-flex-item-align": "auto|start|end|center|baseline|stretch", "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch", "-ms-flex-negative": "<'flex-shrink'>", "-ms-flex-pack": "start|end|center|justify|distribute", "-ms-flex-order": "<integer>", "-ms-flex-positive": "<'flex-grow'>", "-ms-flex-preferred-size": "<'flex-basis'>", "-ms-interpolation-mode": "nearest-neighbor|bicubic", "-ms-grid-column-align": "start|end|center|stretch", "-ms-grid-row-align": "start|end|center|stretch", "-ms-hyphenate-limit-last": "none|always|column|page|spread", "-webkit-background-clip": "[<box>|border|padding|content|text]#", "-webkit-column-break-after": "always|auto|avoid", "-webkit-column-break-before": "always|auto|avoid", "-webkit-column-break-inside": "always|auto|avoid", "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased", "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?", "-webkit-print-color-adjust": "economy|exact", "-webkit-text-security": "none|circle|disc|square", "-webkit-user-drag": "none|element|auto", "-webkit-user-select": "auto|none|text|all", "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical", "baseline-shift": "baseline|sub|super|<svg-length>", behavior: "<url>+", "clip-rule": "nonzero|evenodd", cue: "<'cue-before'> <'cue-after'>?", "cue-after": "<url> <decibel>?|none", "cue-before": "<url> <decibel>?|none", "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge", fill: "<paint>", "fill-opacity": "<number-zero-one>", "fill-rule": "nonzero|evenodd", "glyph-orientation-horizontal": "<angle>", "glyph-orientation-vertical": "<angle>", kerning: "auto|<svg-length>", marker: "none|<url>", "marker-end": "none|<url>", "marker-mid": "none|<url>", "marker-start": "none|<url>", pause: "<'pause-before'> <'pause-after'>?", "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong", "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong", rest: "<'rest-before'> <'rest-after'>?", "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong", "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong", "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision", src: "[<url> [format( <string># )]?|local( <family-name> )]#", speak: "auto|none|normal", "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]", stroke: "<paint>", "stroke-dasharray": "none|[<svg-length>+]#", "stroke-dashoffset": "<svg-length>", "stroke-linecap": "butt|round|square", "stroke-linejoin": "miter|round|bevel", "stroke-miterlimit": "<number-one-or-greater>", "stroke-opacity": "<number-zero-one>", "stroke-width": "<svg-length>", "text-anchor": "start|middle|end", "unicode-range": "<urange>#", "voice-balance": "<number>|left|center|right|leftwards|rightwards", "voice-duration": "auto|<time>", "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve", "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]", "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]", "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>", "voice-stress": "normal|strong|moderate|none|reduced", "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]" }, atrules: { charset: { prelude: "<string>", descriptors: null }, "counter-style": { prelude: "<counter-style-name>", descriptors: { "additive-symbols": "[<integer>&&<symbol>]#", fallback: "<counter-style-name>", negative: "<symbol> <symbol>?", pad: "<integer>&&<symbol>", prefix: "<symbol>", range: "[[<integer>|infinite]{2}]#|auto", "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>", suffix: "<symbol>", symbols: "<symbol>+", system: "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]" } }, document: { prelude: "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#", descriptors: null }, "font-face": { prelude: null, descriptors: { "ascent-override": "normal|<percentage>", "descent-override": "normal|<percentage>", "font-display": "[auto|block|swap|fallback|optional]", "font-family": "<family-name>", "font-feature-settings": "normal|<feature-tag-value>#", "font-variation-settings": "normal|[<string> <number>]#", "font-stretch": "<font-stretch-absolute>{1,2}", "font-style": "normal|italic|oblique <angle>{0,2}", "font-weight": "<font-weight-absolute>{1,2}", "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]", "line-gap-override": "normal|<percentage>", "size-adjust": "<percentage>", src: "[<url> [format( <string># )]?|local( <family-name> )]#", "unicode-range": "<urange>#" } }, "font-feature-values": { prelude: "<family-name>#", descriptors: null }, import: { prelude: "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?", descriptors: null }, keyframes: { prelude: "<keyframes-name>", descriptors: null }, layer: { prelude: "[<layer-name>#|<layer-name>?]", descriptors: null }, media: { prelude: "<media-query-list>", descriptors: null }, namespace: { prelude: "<namespace-prefix>? [<string>|<url>]", descriptors: null }, page: { prelude: "<page-selector-list>", descriptors: { bleed: "auto|<length>", marks: "none|[crop||cross]", size: "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]" } }, property: { prelude: "<custom-property-name>", descriptors: { syntax: "<string>", inherits: "true|false", "initial-value": "<string>" } }, "scroll-timeline": { prelude: "<timeline-name>", descriptors: null }, supports: { prelude: "<supports-condition>", descriptors: null }, viewport: { prelude: null, descriptors: { height: "<viewport-length>{1,2}", "max-height": "<viewport-length>", "max-width": "<viewport-length>", "max-zoom": "auto|<number>|<percentage>", "min-height": "<viewport-length>", "min-width": "<viewport-length>", "min-zoom": "auto|<number>|<percentage>", orientation: "auto|portrait|landscape", "user-zoom": "zoom|fixed", "viewport-fit": "auto|contain|cover", width: "<viewport-length>{1,2}", zoom: "auto|<number>|<percentage>" } } } }; const PLUSSIGN$5 = 43, HYPHENMINUS$2 = 45, N = 110, DISALLOW_SIGN = !0, ALLOW_SIGN = !1; function checkInteger(e, t) { let n = this.tokenStart + e; const r = this.charCodeAt(n); for (r !== PLUSSIGN$5 && r !== HYPHENMINUS$2 || (t && this.error("Number sign is not allowed"), n++); n < this.tokenEnd; n++)isDigit$1(this.charCodeAt(n)) || this.error("Integer is expected", n) } function checkTokenIsInteger(e) { return checkInteger.call(this, 0, e) } function expectCharCode(e, t) { if (!this.cmpChar(this.tokenStart + e, t)) { let n = ""; switch (t) { case N: n = "N is expected"; break; case HYPHENMINUS$2: n = "HyphenMinus is expected" }this.error(n, this.tokenStart + e) } } function consumeB() { let e = 0, t = 0, n = this.tokenType; for (; n === WhiteSpace$1 || n === Comment$1;)n = this.lookupType(++e); if (n !== Number$3) { if (!this.isDelim(PLUSSIGN$5, e) && !this.isDelim(HYPHENMINUS$2, e)) return null; t = this.isDelim(PLUSSIGN$5, e) ? PLUSSIGN$5 : HYPHENMINUS$2; do { n = this.lookupType(++e) } while (n === WhiteSpace$1 || n === Comment$1); n !== Number$3 && (this.skip(e), checkTokenIsInteger.call(this, DISALLOW_SIGN)) } return e > 0 && this.skip(e), 0 === t && (n = this.charCodeAt(this.tokenStart), n !== PLUSSIGN$5 && n !== HYPHENMINUS$2 && this.error("Number sign is expected")), checkTokenIsInteger.call(this, 0 !== t), t === HYPHENMINUS$2 ? "-" + this.consume(Number$3) : this.consume(Number$3) } const name$1p = "AnPlusB", structure$D = { a: [String, null], b: [String, null] }; function parse$G() { const e = this.tokenStart; let t = null, n = null; if (this.tokenType === Number$3) checkTokenIsInteger.call(this, false), n = this.consume(Number$3); else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$2)) switch (t = "-1", expectCharCode.call(this, 1, N), this.tokenEnd - this.tokenStart) { case 2: this.next(), n = consumeB.call(this); break; case 3: expectCharCode.call(this, 2, HYPHENMINUS$2), this.next(), this.skipSC(), checkTokenIsInteger.call(this, DISALLOW_SIGN), n = "-" + this.consume(Number$3); break; default: expectCharCode.call(this, 2, HYPHENMINUS$2), checkInteger.call(this, 3, DISALLOW_SIGN), this.next(), n = this.substrToCursor(e + 2) } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN$5) && this.lookupType(1) === Ident) { let r = 0; switch (t = "1", this.isDelim(PLUSSIGN$5) && (r = 1, this.next()), expectCharCode.call(this, 0, N), this.tokenEnd - this.tokenStart) { case 1: this.next(), n = consumeB.call(this); break; case 2: expectCharCode.call(this, 1, HYPHENMINUS$2), this.next(), this.skipSC(), checkTokenIsInteger.call(this, DISALLOW_SIGN), n = "-" + this.consume(Number$3); break; default: expectCharCode.call(this, 1, HYPHENMINUS$2), checkInteger.call(this, 2, DISALLOW_SIGN), this.next(), n = this.substrToCursor(e + r + 1) } } else if (this.tokenType === Dimension$1) { const r = this.charCodeAt(this.tokenStart), a = r === PLUSSIGN$5 || r === HYPHENMINUS$2; let o = this.tokenStart + a; for (; o < this.tokenEnd && isDigit$1(this.charCodeAt(o)); o++); o === this.tokenStart + a && this.error("Integer is expected", this.tokenStart + a), expectCharCode.call(this, o - this.tokenStart, N), t = this.substring(e, o), o + 1 === this.tokenEnd ? (this.next(), n = consumeB.call(this)) : (expectCharCode.call(this, o - this.tokenStart + 1, HYPHENMINUS$2), o + 2 === this.tokenEnd ? (this.next(), this.skipSC(), checkTokenIsInteger.call(this, DISALLOW_SIGN), n = "-" + this.consume(Number$3)) : (checkInteger.call(this, o - this.tokenStart + 2, DISALLOW_SIGN), this.next(), n = this.substrToCursor(o + 1))) } else this.error(); return null !== t && t.charCodeAt(0) === PLUSSIGN$5 && (t = t.substr(1)), null !== n && n.charCodeAt(0) === PLUSSIGN$5 && (n = n.substr(1)), { type: "AnPlusB", loc: this.getLocation(e, this.tokenStart), a: t, b: n } } function generate$G(e) { if (e.a) { const t = ("+1" === e.a || "1" === e.a ? "n" : "-1" === e.a && "-n") || e.a + "n"; if (e.b) { const n = "-" === e.b[0] || "+" === e.b[0] ? e.b : "+" + e.b; this.tokenize(t + n) } else this.tokenize(t) } else this.tokenize(e.b) } var AnPlusB = Object.freeze({ __proto__: null, generate: generate$G, name: name$1p, parse: parse$G, structure: structure$D }); function consumeRaw$5(e) { return this.Raw(e, this.consumeUntilLeftCurlyBracketOrSemicolon, !0) } function isDeclarationBlockAtrule() { for (let e, t = 1; e = this.lookupType(t); t++) { if (e === RightCurlyBracket) return !0; if (e === LeftCurlyBracket || e === AtKeyword) return !1 } return !1 } const name$1o = "Atrule", walkContext$9 = "atrule", structure$C = { name: String, prelude: ["AtrulePrelude", "Raw", null], block: ["Block", null] }; function parse$F() { const e = this.tokenStart; let t, n, r = null, a = null; switch (this.eat(AtKeyword), t = this.substrToCursor(e + 1), n = t.toLowerCase(), this.skipSC(), !1 === this.eof && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon && (r = this.parseAtrulePrelude ? this.parseWithFallback(this.AtrulePrelude.bind(this, t), consumeRaw$5) : consumeRaw$5.call(this, this.tokenIndex), this.skipSC()), this.tokenType) { case Semicolon: this.next(); break; case LeftCurlyBracket: a = hasOwnProperty.call(this.atrule, n) && "function" == typeof this.atrule[n].block ? this.atrule[n].block.call(this) : this.Block(isDeclarationBlockAtrule.call(this)) }return { type: "Atrule", loc: this.getLocation(e, this.tokenStart), name: t, prelude: r, block: a } } function generate$F(e) { this.token(AtKeyword, "@" + e.name), null !== e.prelude && this.node(e.prelude), e.block ? this.node(e.block) : this.token(Semicolon, ";") } var Atrule$1 = Object.freeze({ __proto__: null, generate: generate$F, name: name$1o, parse: parse$F, structure: structure$C, walkContext: "atrule" }); const name$1n = "AtrulePrelude", walkContext$8 = "atrulePrelude", structure$B = { children: [[]] }; function parse$E(e) { let t = null; return null !== e && (e = e.toLowerCase()), this.skipSC(), t = hasOwnProperty.call(this.atrule, e) && "function" == typeof this.atrule[e].prelude ? this.atrule[e].prelude.call(this) : this.readSequence(this.scope.AtrulePrelude), this.skipSC(), !0 !== this.eof && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon && this.error("Semicolon or block is expected"), { type: "AtrulePrelude", loc: this.getLocationFromList(t), children: t } } function generate$E(e) { this.children(e) } var AtrulePrelude = Object.freeze({ __proto__: null, generate: generate$E, name: name$1n, parse: parse$E, structure: structure$B, walkContext: walkContext$8 }); const DOLLARSIGN$1 = 36, ASTERISK$5 = 42, EQUALSSIGN = 61, CIRCUMFLEXACCENT = 94, VERTICALLINE$2 = 124, TILDE$2 = 126; function getAttributeName() { this.eof && this.error("Unexpected end of input"); const e = this.tokenStart; let t = !1; return this.isDelim(ASTERISK$5) ? (t = !0, this.next()) : this.isDelim(VERTICALLINE$2) || this.eat(Ident), this.isDelim(VERTICALLINE$2) ? this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN ? (this.next(), this.eat(Ident)) : t && this.error("Identifier is expected", this.tokenEnd) : t && this.error("Vertical line is expected"), { type: "Identifier", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e) } } function getOperator() { const e = this.tokenStart, t = this.charCodeAt(e); return t !== EQUALSSIGN && t !== TILDE$2 && t !== CIRCUMFLEXACCENT && t !== DOLLARSIGN$1 && t !== ASTERISK$5 && t !== VERTICALLINE$2 && this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected"), this.next(), t !== EQUALSSIGN && (this.isDelim(EQUALSSIGN) || this.error("Equal sign is expected"), this.next()), this.substrToCursor(e) } const name$1m = "AttributeSelector", structure$A = { name: "Identifier", matcher: [String, null], value: ["String", "Identifier", null], flags: [String, null] }; function parse$D() { const e = this.tokenStart; let t, n = null, r = null, a = null; return this.eat(LeftSquareBracket), this.skipSC(), t = getAttributeName.call(this), this.skipSC(), this.tokenType !== RightSquareBracket && (this.tokenType !== Ident && (n = getOperator.call(this), this.skipSC(), r = this.tokenType === String$2 ? this.String() : this.Identifier(), this.skipSC()), this.tokenType === Ident && (a = this.consume(Ident), this.skipSC())), this.eat(RightSquareBracket), { type: "AttributeSelector", loc: this.getLocation(e, this.tokenStart), name: t, matcher: n, value: r, flags: a } } function generate$D(e) { this.token(Delim, "["), this.node(e.name), null !== e.matcher && (this.tokenize(e.matcher), this.node(e.value)), null !== e.flags && this.token(Ident, e.flags), this.token(Delim, "]") } var AttributeSelector$1 = Object.freeze({ __proto__: null, generate: generate$D, name: name$1m, parse: parse$D, structure: structure$A }); function consumeRaw$4(e) { return this.Raw(e, null, !0) } function consumeRule() { return this.parseWithFallback(this.Rule, consumeRaw$4) } function consumeRawDeclaration(e) { return this.Raw(e, this.consumeUntilSemicolonIncluded, !0) } function consumeDeclaration() { if (this.tokenType === Semicolon) return consumeRawDeclaration.call(this, this.tokenIndex); const e = this.parseWithFallback(this.Declaration, consumeRawDeclaration); return this.tokenType === Semicolon && this.next(), e } const name$1l = "Block", walkContext$7 = "block", structure$z = { children: [["Atrule", "Rule", "Declaration"]] }; function parse$C(e) { const t = e ? consumeDeclaration : consumeRule, n = this.tokenStart; let r = this.createList(); this.eat(LeftCurlyBracket); e: for (; !this.eof;)switch (this.tokenType) { case RightCurlyBracket: break e; case WhiteSpace$1: case Comment$1: this.next(); break; case AtKeyword: r.push(this.parseWithFallback(this.Atrule, consumeRaw$4)); break; default: r.push(t.call(this)) }return this.eof || this.eat(RightCurlyBracket), { type: "Block", loc: this.getLocation(n, this.tokenStart), children: r } } function generate$C(e) { this.token(LeftCurlyBracket, "{"), this.children(e, (e => { "Declaration" === e.type && this.token(Semicolon, ";") })), this.token(RightCurlyBracket, "}") } var Block = Object.freeze({ __proto__: null, generate: generate$C, name: "Block", parse: parse$C, structure: structure$z, walkContext: "block" }); const name$1k = "Brackets", structure$y = { children: [[]] }; function parse$B(e, t) { const n = this.tokenStart; let r = null; return this.eat(LeftSquareBracket), r = e.call(this, t), this.eof || this.eat(RightSquareBracket), { type: "Brackets", loc: this.getLocation(n, this.tokenStart), children: r } } function generate$B(e) { this.token(Delim, "["), this.children(e), this.token(Delim, "]") } var Brackets = Object.freeze({ __proto__: null, generate: generate$B, name: name$1k, parse: parse$B, structure: structure$y }); const name$1j = "CDC", structure$x = []; function parse$A() { const e = this.tokenStart; return this.eat(CDC$1), { type: "CDC", loc: this.getLocation(e, this.tokenStart) } } function generate$A() { this.token(CDC$1, "--\x3e") } var CDC = Object.freeze({ __proto__: null, generate: generate$A, name: "CDC", parse: parse$A, structure: structure$x }); const name$1i = "CDO", structure$w = []; function parse$z() { const e = this.tokenStart; return this.eat(CDO$1), { type: "CDO", loc: this.getLocation(e, this.tokenStart) } } function generate$z() { this.token(CDO$1, "\x3c!--") } var CDO = Object.freeze({ __proto__: null, generate: generate$z, name: "CDO", parse: parse$z, structure: structure$w }); const FULLSTOP$2 = 46, name$1h = "ClassSelector", structure$v = { name: String }; function parse$y() { return this.eatDelim(46), { type: "ClassSelector", loc: this.getLocation(this.tokenStart - 1, this.tokenEnd), name: this.consume(Ident) } } function generate$y(e) { this.token(Delim, "."), this.token(Ident, e.name) } var ClassSelector = Object.freeze({ __proto__: null, generate: generate$y, name: name$1h, parse: parse$y, structure: structure$v }); const PLUSSIGN$4 = 43, SOLIDUS$5 = 47, GREATERTHANSIGN$1 = 62, TILDE$1 = 126, name$1g = "Combinator", structure$u = { name: String }; function parse$x() { const e = this.tokenStart; let t; switch (this.tokenType) { case WhiteSpace$1: t = " "; break; case Delim: switch (this.charCodeAt(this.tokenStart)) { case 62: case 43: case 126: this.next(); break; case 47: this.next(), this.eatIdent("deep"), this.eatDelim(47); break; default: this.error("Combinator is expected") }t = this.substrToCursor(e) }return { type: "Combinator", loc: this.getLocation(e, this.tokenStart), name: t } } function generate$x(e) { this.tokenize(e.name) } var Combinator = Object.freeze({ __proto__: null, generate: generate$x, name: name$1g, parse: parse$x, structure: structure$u }); const ASTERISK$4 = 42, SOLIDUS$4 = 47, name$1f = "Comment", structure$t = { value: String }; function parse$w() { const e = this.tokenStart; let t = this.tokenEnd; return this.eat(Comment$1), t - e + 2 >= 2 && 42 === this.charCodeAt(t - 2) && 47 === this.charCodeAt(t - 1) && (t -= 2), { type: "Comment", loc: this.getLocation(e, this.tokenStart), value: this.substring(e + 2, t) } } function generate$w(e) { this.token(Comment$1, "/*" + e.value + "*/") } var Comment = Object.freeze({ __proto__: null, generate: generate$w, name: name$1f, parse: parse$w, structure: structure$t }); const EXCLAMATIONMARK$1 = 33, NUMBERSIGN$2 = 35, DOLLARSIGN = 36, AMPERSAND = 38, ASTERISK$3 = 42, PLUSSIGN$3 = 43, SOLIDUS$3 = 47; function consumeValueRaw(e) { return this.Raw(e, this.consumeUntilExclamationMarkOrSemicolon, !0) } function consumeCustomPropertyRaw(e) { return this.Raw(e, this.consumeUntilExclamationMarkOrSemicolon, !1) } function consumeValue() { const e = this.tokenIndex, t = this.Value(); return "Raw" !== t.type && !1 === this.eof && this.tokenType !== Semicolon && !1 === this.isDelim(EXCLAMATIONMARK$1) && !1 === this.isBalanceEdge(e) && this.error(), t } const name$1e = "Declaration", walkContext$6 = "declaration", structure$s = { important: [Boolean, String], property: String, value: ["Value", "Raw"] }; function parse$v() { const e = this.tokenStart, t = this.tokenIndex, n = readProperty.call(this), r = isCustomProperty(n), a = r ? this.parseCustomProperty : this.parseValue, o = r ? consumeCustomPropertyRaw : consumeValueRaw; let i, s = !1; this.skipSC(), this.eat(Colon); const l = this.tokenIndex; if (r || this.skipSC(), i = a ? this.parseWithFallback(consumeValue, o) : o.call(this, this.tokenIndex), r && "Value" === i.type && i.children.isEmpty) for (let e = l - this.tokenIndex; e <= 0; e++)if (this.lookupType(e) === WhiteSpace$1) { i.children.appendData({ type: "WhiteSpace", loc: null, value: " " }); break } return this.isDelim(EXCLAMATIONMARK$1) && (s = getImportant.call(this), this.skipSC()), !1 === this.eof && this.tokenType !== Semicolon && !1 === this.isBalanceEdge(t) && this.error(), { type: "Declaration", loc: this.getLocation(e, this.tokenStart), important: s, property: n, value: i } } function generate$v(e) { this.token(Ident, e.property), this.token(Colon, ":"), this.node(e.value), e.important && (this.token(Delim, "!"), this.token(Ident, !0 === e.important ? "important" : e.important)) } function readProperty() { const e = this.tokenStart; if (this.tokenType === Delim) switch (this.charCodeAt(this.tokenStart)) { case ASTERISK$3: case DOLLARSIGN: case PLUSSIGN$3: case NUMBERSIGN$2: case AMPERSAND: this.next(); break; case SOLIDUS$3: this.next(), this.isDelim(SOLIDUS$3) && this.next() }return this.tokenType === Hash$1 ? this.eat(Hash$1) : this.eat(Ident), this.substrToCursor(e) } function getImportant() { this.eat(Delim), this.skipSC(); const e = this.consume(Ident); return "important" === e || e } var Declaration = Object.freeze({ __proto__: null, generate: generate$v, name: name$1e, parse: parse$v, structure: structure$s, walkContext: "declaration" }); function consumeRaw$3(e) { return this.Raw(e, this.consumeUntilSemicolonIncluded, !0) } const name$1d = "DeclarationList", structure$r = { children: [["Declaration"]] }; function parse$u() { const e = this.createList(); for (; !this.eof;)switch (this.tokenType) { case WhiteSpace$1: case Comment$1: case Semicolon: this.next(); break; default: e.push(this.parseWithFallback(this.Declaration, consumeRaw$3)) }return { type: "DeclarationList", loc: this.getLocationFromList(e), children: e } } function generate$u(e) { this.children(e, (e => { "Declaration" === e.type && this.token(Semicolon, ";") })) } var DeclarationList = Object.freeze({ __proto__: null, generate: generate$u, name: name$1d, parse: parse$u, structure: structure$r }); const name$1c = "Dimension", structure$q = { value: String, unit: String }; function parse$t() { const e = this.tokenStart, t = this.consumeNumber(Dimension$1); return { type: "Dimension", loc: this.getLocation(e, this.tokenStart), value: t, unit: this.substring(e + t.length, this.tokenStart) } } function generate$t(e) { this.token(Dimension$1, e.value + e.unit) } var Dimension = Object.freeze({ __proto__: null, generate: generate$t, name: name$1c, parse: parse$t, structure: structure$q }); const name$1b = "Function", walkContext$5 = "function", structure$p = { name: String, children: [[]] }; function parse$s(e, t) { const n = this.tokenStart, r = this.consumeFunctionName(), a = r.toLowerCase(); let o; return o = t.hasOwnProperty(a) ? t[a].call(this, t) : e.call(this, t), this.eof || this.eat(RightParenthesis), { type: "Function", loc: this.getLocation(n, this.tokenStart), name: r, children: o } } function generate$s(e) { this.token(Function$1, e.name + "("), this.children(e), this.token(RightParenthesis, ")") } var Function = Object.freeze({ __proto__: null, generate: generate$s, name: name$1b, parse: parse$s, structure: structure$p, walkContext: "function" }); const xxx = "XXX", name$1a = "Hash", structure$o = { value: String }; function parse$r() { const e = this.tokenStart; return this.eat(Hash$1), { type: "Hash", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e + 1) } } function generate$r(e) { this.token(Hash$1, "#" + e.value) } var Hash = Object.freeze({ __proto__: null, generate: generate$r, name: "Hash", parse: parse$r, structure: structure$o, xxx: xxx }); const name$19 = "Identifier", structure$n = { name: String }; function parse$q() { return { type: "Identifier", loc: this.getLocation(this.tokenStart, this.tokenEnd), name: this.consume(Ident) } } function generate$q(e) { this.token(Ident, e.name) } var Identifier = Object.freeze({ __proto__: null, generate: generate$q, name: name$19, parse: parse$q, structure: structure$n }); const name$18 = "IdSelector", structure$m = { name: String }; function parse$p() { const e = this.tokenStart; return this.eat(Hash$1), { type: "IdSelector", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e + 1) } } function generate$p(e) { this.token(Delim, "#" + e.name) } var IdSelector = Object.freeze({ __proto__: null, generate: generate$p, name: name$18, parse: parse$p, structure: structure$m }); const name$17 = "MediaFeature", structure$l = { name: String, value: ["Identifier", "Number", "Dimension", "Ratio", null] }; function parse$o() { const e = this.tokenStart; let t, n = null; if (this.eat(LeftParenthesis), this.skipSC(), t = this.consume(Ident), this.skipSC(), this.tokenType !== RightParenthesis) { switch (this.eat(Colon), this.skipSC(), this.tokenType) { case Number$3: n = this.lookupNonWSType(1) === Delim ? this.Ratio() : this.Number(); break; case Dimension$1: n = this.Dimension(); break; case Ident: n = this.Identifier(); break; default: this.error("Number, dimension, ratio or identifier is expected") }this.skipSC() } return this.eat(RightParenthesis), { type: "MediaFeature", loc: this.getLocation(e, this.tokenStart), name: t, value: n } } function generate$o(e) { this.token(LeftParenthesis, "("), this.token(Ident, e.name), null !== e.value && (this.token(Colon, ":"), this.node(e.value)), this.token(RightParenthesis, ")") } var MediaFeature = Object.freeze({ __proto__: null, generate: generate$o, name: name$17, parse: parse$o, structure: structure$l }); const name$16 = "MediaQuery", structure$k = { children: [["Identifier", "MediaFeature", "WhiteSpace"]] }; function parse$n() { const e = this.createList(); let t = null; this.skipSC(); e: for (; !this.eof;) { switch (this.tokenType) { case Comment$1: case WhiteSpace$1: this.next(); continue; case Ident: t = this.Identifier(); break; case LeftParenthesis: t = this.MediaFeature(); break; default: break e }e.push(t) } return null === t && this.error("Identifier or parenthesis is expected"), { type: "MediaQuery", loc: this.getLocationFromList(e), children: e } } function generate$n(e) { this.children(e) } var MediaQuery = Object.freeze({ __proto__: null, generate: generate$n, name: name$16, parse: parse$n, structure: structure$k }); const name$15 = "MediaQueryList", structure$j = { children: [["MediaQuery"]] }; function parse$m() { const e = this.createList(); for (this.skipSC(); !this.eof && (e.push(this.MediaQuery()), this.tokenType === Comma);)this.next(); return { type: "MediaQueryList", loc: this.getLocationFromList(e), children: e } } function generate$m(e) { this.children(e, (() => this.token(Comma, ","))) } var MediaQueryList = Object.freeze({ __proto__: null, generate: generate$m, name: name$15, parse: parse$m, structure: structure$j }); const name$14 = "Nth", structure$i = { nth: ["AnPlusB", "Identifier"], selector: ["SelectorList", null] }; function parse$l() { this.skipSC(); const e = this.tokenStart; let t, n = e, r = null; return t = this.lookupValue(0, "odd") || this.lookupValue(0, "even") ? this.Identifier() : this.AnPlusB(), n = this.tokenStart, this.skipSC(), this.lookupValue(0, "of") && (this.next(), r = this.SelectorList(), n = this.tokenStart), { type: "Nth", loc: this.getLocation(e, n), nth: t, selector: r } } function generate$l(e) { this.node(e.nth), null !== e.selector && (this.token(Ident, "of"), this.node(e.selector)) } var Nth = Object.freeze({ __proto__: null, generate: generate$l, name: "Nth", parse: parse$l, structure: structure$i }); const name$13 = "Number", structure$h = { value: String }; function parse$k() { return { type: "Number", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consume(Number$3) } } function generate$k(e) { this.token(Number$3, e.value) } var Number$2 = Object.freeze({ __proto__: null, generate: generate$k, name: name$13, parse: parse$k, structure: structure$h }); const name$12 = "Operator", structure$g = { value: String }; function parse$j() { const e = this.tokenStart; return this.next(), { type: "Operator", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e) } } function generate$j(e) { this.tokenize(e.value) } var Operator = Object.freeze({ __proto__: null, generate: generate$j, name: name$12, parse: parse$j, structure: structure$g }); const name$11 = "Parentheses", structure$f = { children: [[]] }; function parse$i(e, t) { const n = this.tokenStart; let r = null; return this.eat(LeftParenthesis), r = e.call(this, t), this.eof || this.eat(RightParenthesis), { type: "Parentheses", loc: this.getLocation(n, this.tokenStart), children: r } } function generate$i(e) { this.token(LeftParenthesis, "("), this.children(e), this.token(RightParenthesis, ")") } var Parentheses = Object.freeze({ __proto__: null, generate: generate$i, name: name$11, parse: parse$i, structure: structure$f }); const name$10 = "Percentage", structure$e = { value: String }; function parse$h() { return { type: "Percentage", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consumeNumber(Percentage$1) } } function generate$h(e) { this.token(Percentage$1, e.value + "%") } var Percentage = Object.freeze({ __proto__: null, generate: generate$h, name: name$10, parse: parse$h, structure: structure$e }); const name$$ = "PseudoClassSelector", walkContext$4 = "function", structure$d = { name: String, children: [["Raw"], null] }; function parse$g() { const e = this.tokenStart; let t, n, r = null; return this.eat(Colon), this.tokenType === Function$1 ? (t = this.consumeFunctionName(), n = t.toLowerCase(), hasOwnProperty.call(this.pseudo, n) ? (this.skipSC(), r = this.pseudo[n].call(this), this.skipSC()) : (r = this.createList(), r.push(this.Raw(this.tokenIndex, null, !1))), this.eat(RightParenthesis)) : t = this.consume(Ident), { type: "PseudoClassSelector", loc: this.getLocation(e, this.tokenStart), name: t, children: r } } function generate$g(e) { this.token(Colon, ":"), null === e.children ? this.token(Ident, e.name) : (this.token(Function$1, e.name + "("), this.children(e), this.token(RightParenthesis, ")")) } var PseudoClassSelector = Object.freeze({ __proto__: null, generate: generate$g, name: name$$, parse: parse$g, structure: structure$d, walkContext: "function" }); const name$_ = "PseudoElementSelector", walkContext$3 = "function", structure$c = { name: String, children: [["Raw"], null] }; function parse$f() { const e = this.tokenStart; let t, n, r = null; return this.eat(Colon), this.eat(Colon), this.tokenType === Function$1 ? (t = this.consumeFunctionName(), n = t.toLowerCase(), hasOwnProperty.call(this.pseudo, n) ? (this.skipSC(), r = this.pseudo[n].call(this), this.skipSC()) : (r = this.createList(), r.push(this.Raw(this.tokenIndex, null, !1))), this.eat(RightParenthesis)) : t = this.consume(Ident), { type: "PseudoElementSelector", loc: this.getLocation(e, this.tokenStart), name: t, children: r } } function generate$f(e) { this.token(Colon, ":"), this.token(Colon, ":"), null === e.children ? this.token(Ident, e.name) : (this.token(Function$1, e.name + "("), this.children(e), this.token(RightParenthesis, ")")) } var PseudoElementSelector = Object.freeze({ __proto__: null, generate: generate$f, name: name$_, parse: parse$f, structure: structure$c, walkContext: "function" }); const SOLIDUS$2 = 47, FULLSTOP$1 = 46; function consumeNumber() { this.skipSC(); const e = this.consume(Number$3); for (let t = 0; t < e.length; t++) { const n = e.charCodeAt(t); isDigit$1(n) || n === FULLSTOP$1 || this.error("Unsigned number is expected", this.tokenStart - e.length + t) } return 0 === Number(e) && this.error("Zero number is not allowed", this.tokenStart - e.length), e } const name$Z = "Ratio", structure$b = { left: String, right: String }; function parse$e() { const e = this.tokenStart, t = consumeNumber.call(this); let n; return this.skipSC(), this.eatDelim(47), n = consumeNumber.call(this), { type: "Ratio", loc: this.getLocation(e, this.tokenStart), left: t, right: n } } function generate$e(e) { this.token(Number$3, e.left), this.token(Delim, "/"), this.token(Number$3, e.right) } var Ratio = Object.freeze({ __proto__: null, generate: generate$e, name: name$Z, parse: parse$e, structure: structure$b }); function getOffsetExcludeWS() { return this.tokenIndex > 0 && this.lookupType(-1) === WhiteSpace$1 ? this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset : this.tokenStart } const name$Y = "Raw", structure$a = { value: String }; function parse$d(e, t, n) { const r = this.getTokenStart(e); let a; return this.skipUntilBalanced(e, t || this.consumeUntilBalanceEnd), a = n && this.tokenStart > r ? getOffsetExcludeWS.call(this) : this.tokenStart, { type: "Raw", loc: this.getLocation(r, a), value: this.substring(r, a) } } function generate$d(e) { this.tokenize(e.value) } var Raw = Object.freeze({ __proto__: null, generate: generate$d, name: "Raw", parse: parse$d, structure: structure$a }); function consumeRaw$2(e) { return this.Raw(e, this.consumeUntilLeftCurlyBracket, !0) } function consumePrelude() { const e = this.SelectorList(); return "Raw" !== e.type && !1 === this.eof && this.tokenType !== LeftCurlyBracket && this.error(), e } const name$X = "Rule", walkContext$2 = "rule", structure$9 = { prelude: ["SelectorList", "Raw"], block: ["Block"] }; function parse$c() { const e = this.tokenIndex, t = this.tokenStart; let n, r; return n = this.parseRulePrelude ? this.parseWithFallback(consumePrelude, consumeRaw$2) : consumeRaw$2.call(this, e), r = this.Block(!0), { type: "Rule", loc: this.getLocation(t, this.tokenStart), prelude: n, block: r } } function generate$c(e) { this.node(e.prelude), this.node(e.block) } var Rule = Object.freeze({ __proto__: null, generate: generate$c, name: "Rule", parse: parse$c, structure: structure$9, walkContext: "rule" }); const name$W = "Selector", structure$8 = { children: [["TypeSelector", "IdSelector", "ClassSelector", "AttributeSelector", "PseudoClassSelector", "PseudoElementSelector", "Combinator", "WhiteSpace"]] }; function parse$b() { const e = this.readSequence(this.scope.Selector); return null === this.getFirstListNode(e) && this.error("Selector is expected"), { type: "Selector", loc: this.getLocationFromList(e), children: e } } function generate$b(e) { this.children(e) } var Selector = Object.freeze({ __proto__: null, generate: generate$b, name: name$W, parse: parse$b, structure: structure$8 }); const name$V = "SelectorList", walkContext$1 = "selector", structure$7 = { children: [["Selector", "Raw"]] }; function parse$a() { const e = this.createList(); for (; !this.eof && (e.push(this.Selector()), this.tokenType === Comma);)this.next(); return { type: "SelectorList", loc: this.getLocationFromList(e), children: e } } function generate$a(e) { this.children(e, (() => this.token(Comma, ","))) } var SelectorList = Object.freeze({ __proto__: null, generate: generate$a, name: name$V, parse: parse$a, structure: structure$7, walkContext: "selector" }); const REVERSE_SOLIDUS$1 = 92, QUOTATION_MARK$1 = 34, APOSTROPHE$1 = 39; function decode$1(e) { const t = e.length, n = e.charCodeAt(0), r = n === QUOTATION_MARK$1 || n === APOSTROPHE$1 ? 1 : 0, a = 1 === r && t > 1 && e.charCodeAt(t - 1) === n ? t - 2 : t - 1; let o = ""; for (let n = r; n <= a; n++) { let r = e.charCodeAt(n); if (r === REVERSE_SOLIDUS$1) { if (n === a) { n !== t - 1 && (o = e.substr(n + 1)); break } if (r = e.charCodeAt(++n), isValidEscape(REVERSE_SOLIDUS$1, r)) { const t = n - 1, r = consumeEscaped(e, t); n = r - 1, o += decodeEscaped(e.substring(t + 1, r)) } else 13 === r && 10 === e.charCodeAt(n + 1) && n++ } else o += e[n] } return o } function encode$1(e, t) { const n = t ? "'" : '"', r = t ? APOSTROPHE$1 : QUOTATION_MARK$1; let a = "", o = !1; for (let t = 0; t < e.length; t++) { const n = e.charCodeAt(t); 0 !== n ? n <= 31 || 127 === n ? (a += "\\" + n.toString(16), o = !0) : n === r || n === REVERSE_SOLIDUS$1 ? (a += "\\" + e.charAt(t), o = !1) : (o && (isHexDigit(n) || isWhiteSpace$1(n)) && (a += " "), a += e.charAt(t), o = !1) : a += "" } return n + a + n } const name$U = "String", structure$6 = { value: String }; function parse$9() { return { type: "String", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: decode$1(this.consume(String$2)) } } function generate$9(e) { this.token(String$2, encode$1(e.value)) } var String$1 = Object.freeze({ __proto__: null, generate: generate$9, name: name$U, parse: parse$9, structure: structure$6 }); const EXCLAMATIONMARK = 33; function consumeRaw$1(e) { return this.Raw(e, null, !1) } const name$T = "StyleSheet", walkContext = "stylesheet", structure$5 = { children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]] }; function parse$8() { const e = this.tokenStart, t = this.createList(); let n; for (; !this.eof;) { switch (this.tokenType) { case WhiteSpace$1: this.next(); continue; case Comment$1: if (33 !== this.charCodeAt(this.tokenStart + 2)) { this.next(); continue } n = this.Comment(); break; case CDO$1: n = this.CDO(); break; case CDC$1: n = this.CDC(); break; case AtKeyword: n = this.parseWithFallback(this.Atrule, consumeRaw$1); break; default: n = this.parseWithFallback(this.Rule, consumeRaw$1) }t.push(n) } return { type: "StyleSheet", loc: this.getLocation(e, this.tokenStart), children: t } } function generate$8(e) { this.children(e) } var StyleSheet = Object.freeze({ __proto__: null, generate: generate$8, name: name$T, parse: parse$8, structure: structure$5, walkContext: walkContext }); const ASTERISK$2 = 42, VERTICALLINE$1 = 124; function eatIdentifierOrAsterisk() { this.tokenType !== Ident && !1 === this.isDelim(ASTERISK$2) && this.error("Identifier or asterisk is expected"), this.next() } const name$S = "TypeSelector", structure$4 = { name: String }; function parse$7() { const e = this.tokenStart; return this.isDelim(124) ? (this.next(), eatIdentifierOrAsterisk.call(this)) : (eatIdentifierOrAsterisk.call(this), this.isDelim(124) && (this.next(), eatIdentifierOrAsterisk.call(this))), { type: "TypeSelector", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e) } } function generate$7(e) { this.tokenize(e.name) } var TypeSelector = Object.freeze({ __proto__: null, generate: generate$7, name: name$S, parse: parse$7, structure: structure$4 }); const PLUSSIGN$2 = 43, HYPHENMINUS$1 = 45, QUESTIONMARK = 63; function eatHexSequence(e, t) { let n = 0; for (let r = this.tokenStart + e; r < this.tokenEnd; r++) { const a = this.charCodeAt(r); if (a === HYPHENMINUS$1 && t && 0 !== n) return eatHexSequence.call(this, e + n + 1, !1), -1; isHexDigit(a) || this.error(t && 0 !== n ? "Hyphen minus" + (n < 6 ? " or hex digit" : "") + " is expected" : n < 6 ? "Hex digit is expected" : "Unexpected input", r), ++n > 6 && this.error("Too many hex digits", r) } return this.next(), n } function eatQuestionMarkSequence(e) { let t = 0; for (; this.isDelim(QUESTIONMARK);)++t > e && this.error("Too many question marks"), this.next() } function startsWith(e) { this.charCodeAt(this.tokenStart) !== e && this.error((e === PLUSSIGN$2 ? "Plus sign" : "Hyphen minus") + " is expected") } function scanUnicodeRange() { let e = 0; switch (this.tokenType) { case Number$3: if (e = eatHexSequence.call(this, 1, !0), this.isDelim(QUESTIONMARK)) { eatQuestionMarkSequence.call(this, 6 - e); break } if (this.tokenType === Dimension$1 || this.tokenType === Number$3) { startsWith.call(this, HYPHENMINUS$1), eatHexSequence.call(this, 1, !1); break } break; case Dimension$1: e = eatHexSequence.call(this, 1, !0), e > 0 && eatQuestionMarkSequence.call(this, 6 - e); break; default: if (this.eatDelim(PLUSSIGN$2), this.tokenType === Ident) { e = eatHexSequence.call(this, 0, !0), e > 0 && eatQuestionMarkSequence.call(this, 6 - e); break } if (this.isDelim(QUESTIONMARK)) { this.next(), eatQuestionMarkSequence.call(this, 5); break } this.error("Hex digit or question mark is expected") } } const name$R = "UnicodeRange", structure$3 = { value: String }; function parse$6() { const e = this.tokenStart; return this.eatIdent("u"), scanUnicodeRange.call(this), { type: "UnicodeRange", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e) } } function generate$6(e) { this.tokenize(e.value) } var UnicodeRange = Object.freeze({ __proto__: null, generate: generate$6, name: name$R, parse: parse$6, structure: structure$3 }); const SPACE$1 = 32, REVERSE_SOLIDUS = 92, QUOTATION_MARK = 34, APOSTROPHE = 39, LEFTPARENTHESIS = 40, RIGHTPARENTHESIS = 41; function decode(e) { const t = e.length; let n = 4, r = e.charCodeAt(t - 1) === RIGHTPARENTHESIS ? t - 2 : t - 1, a = ""; for (; n < r && isWhiteSpace$1(e.charCodeAt(n));)n++; for (; n < r && isWhiteSpace$1(e.charCodeAt(r));)r--; for (let o = n; o <= r; o++) { let n = e.charCodeAt(o); if (n === REVERSE_SOLIDUS) { if (o === r) { o !== t - 1 && (a = e.substr(o + 1)); break } if (n = e.charCodeAt(++o), isValidEscape(REVERSE_SOLIDUS, n)) { const t = o - 1, n = consumeEscaped(e, t); o = n - 1, a += decodeEscaped(e.substring(t + 1, n)) } else 13 === n && 10 === e.charCodeAt(o + 1) && o++ } else a += e[o] } return a } function encode(e) { let t = "", n = !1; for (let r = 0; r < e.length; r++) { const a = e.charCodeAt(r); 0 !== a ? a <= 31 || 127 === a ? (t += "\\" + a.toString(16), n = !0) : a === SPACE$1 || a === REVERSE_SOLIDUS || a === QUOTATION_MARK || a === APOSTROPHE || a === LEFTPARENTHESIS || a === RIGHTPARENTHESIS ? (t += "\\" + e.charAt(r), n = !1) : (n && isHexDigit(a) && (t += " "), t += e.charAt(r), n = !1) : t += "" } return "url(" + t + ")" } const name$Q = "Url", structure$2 = { value: String }; function parse$5() { const e = this.tokenStart; let t; switch (this.tokenType) { case Url$2: t = decode(this.consume(Url$2)); break; case Function$1: this.cmpStr(this.tokenStart, this.tokenEnd, "url(") || this.error("Function name must be `url`"), this.eat(Function$1), this.skipSC(), t = decode$1(this.consume(String$2)), this.skipSC(), this.eof || this.eat(RightParenthesis); break; default: this.error("Url or Function is expected") }return { type: "Url", loc: this.getLocation(e, this.tokenStart), value: t } } function generate$5(e) { this.token(Url$2, encode(e.value)) } var Url$1 = Object.freeze({ __proto__: null, generate: generate$5, name: "Url", parse: parse$5, structure: structure$2 }); const name$P = "Value", structure$1 = { children: [[]] }; function parse$4() { const e = this.tokenStart, t = this.readSequence(this.scope.Value); return { type: "Value", loc: this.getLocation(e, this.tokenStart), children: t } } function generate$4(e) { this.children(e) } var Value = Object.freeze({ __proto__: null, generate: generate$4, name: name$P, parse: parse$4, structure: structure$1 }); const SPACE = Object.freeze({ type: "WhiteSpace", loc: null, value: " " }), name$O = "WhiteSpace", structure = { value: String }; function parse$3() { return this.eat(WhiteSpace$1), SPACE } function generate$3(e) { this.token(WhiteSpace$1, e.value) } var WhiteSpace = Object.freeze({ __proto__: null, generate: generate$3, name: name$O, parse: parse$3, structure: structure }), node$1 = Object.freeze({ __proto__: null, AnPlusB: AnPlusB, Atrule: Atrule$1, AtrulePrelude: AtrulePrelude, AttributeSelector: AttributeSelector$1, Block: Block, Brackets: Brackets, CDC: CDC, CDO: CDO, ClassSelector: ClassSelector, Combinator: Combinator, Comment: Comment, Declaration: Declaration, DeclarationList: DeclarationList, Dimension: Dimension, Function: Function, Hash: Hash, IdSelector: IdSelector, Identifier: Identifier, MediaFeature: MediaFeature, MediaQuery: MediaQuery, MediaQueryList: MediaQueryList, Nth: Nth, Number: Number$2, Operator: Operator, Parentheses: Parentheses, Percentage: Percentage, PseudoClassSelector: PseudoClassSelector, PseudoElementSelector: PseudoElementSelector, Ratio: Ratio, Raw: Raw, Rule: Rule, Selector: Selector, SelectorList: SelectorList, String: String$1, StyleSheet: StyleSheet, TypeSelector: TypeSelector, UnicodeRange: UnicodeRange, Url: Url$1, Value: Value, WhiteSpace: WhiteSpace }), lexerConfig = { generic: !0, ...definitions, node: node$1 }; const NUMBERSIGN$1 = 35, ASTERISK$1 = 42, PLUSSIGN$1 = 43, HYPHENMINUS = 45, SOLIDUS$1 = 47, U = 117; function defaultRecognizer(e) { switch (this.tokenType) { case Hash$1: return this.Hash(); case Comma: return this.Operator(); case LeftParenthesis: return this.Parentheses(this.readSequence, e.recognizer); case LeftSquareBracket: return this.Brackets(this.readSequence, e.recognizer); case String$2: return this.String(); case Dimension$1: return this.Dimension(); case Percentage$1: return this.Percentage(); case Number$3: return this.Number(); case Function$1: return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, e.recognizer); case Url$2: return this.Url(); case Ident: return this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, 43) ? this.UnicodeRange() : this.Identifier(); case Delim: { const e = this.charCodeAt(this.tokenStart); if (47 === e || 42 === e || 43 === e || 45 === e) return this.Operator(); 35 === e && this.error("Hex or identifier is expected", this.tokenStart + 1); break } } } var atrulePrelude = { getNode: defaultRecognizer }; const NUMBERSIGN = 35, ASTERISK = 42, PLUSSIGN = 43, SOLIDUS = 47, FULLSTOP = 46, GREATERTHANSIGN = 62, VERTICALLINE = 124, TILDE = 126; function onWhiteSpace(e, t) { null !== t.last && "Combinator" !== t.last.type && null !== e && "Combinator" !== e.type && t.push({ type: "Combinator", loc: null, name: " " }) } function getNode() { switch (this.tokenType) { case LeftSquareBracket: return this.AttributeSelector(); case Hash$1: return this.IdSelector(); case Colon: return this.lookupType(1) === Colon ? this.PseudoElementSelector() : this.PseudoClassSelector(); case Ident: return this.TypeSelector(); case Number$3: case Percentage$1: return this.Percentage(); case Dimension$1: 46 === this.charCodeAt(this.tokenStart) && this.error("Identifier is expected", this.tokenStart + 1); break; case Delim: switch (this.charCodeAt(this.tokenStart)) { case 43: case 62: case 126: case 47: return this.Combinator(); case 46: return this.ClassSelector(); case 42: case 124: return this.TypeSelector(); case 35: return this.IdSelector() }break } } var selector$1 = { onWhiteSpace: onWhiteSpace, getNode: getNode }; function expressionFn() { return this.createSingleNodeList(this.Raw(this.tokenIndex, null, !1)) } function varFn() { const e = this.createList(); if (this.skipSC(), e.push(this.Identifier()), this.skipSC(), this.tokenType === Comma) { e.push(this.Operator()); const t = this.tokenIndex, n = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, !1); if ("Value" === n.type && n.children.isEmpty) for (let e = t - this.tokenIndex; e <= 0; e++)if (this.lookupType(e) === WhiteSpace$1) { n.children.appendData({ type: "WhiteSpace", loc: null, value: " " }); break } e.push(n) } return e } function isPlusMinusOperator(e) { return null !== e && "Operator" === e.type && ("-" === e.value[e.value.length - 1] || "+" === e.value[e.value.length - 1]) } var value = { getNode: defaultRecognizer, onWhiteSpace(e, t) { isPlusMinusOperator(e) && (e.value = " " + e.value), isPlusMinusOperator(t.last) && (t.last.value += " ") }, expression: expressionFn, var: varFn }, scope = Object.freeze({ __proto__: null, AtrulePrelude: atrulePrelude, Selector: selector$1, Value: value }), fontFace = { parse: { prelude: null, block() { return this.Block(!0) } } }, importAtrule = { parse: { prelude() { const e = this.createList(); switch (this.skipSC(), this.tokenType) { case String$2: e.push(this.String()); break; case Url$2: case Function$1: e.push(this.Url()); break; default: this.error("String or url() is expected") }return this.lookupNonWSType(0) !== Ident && this.lookupNonWSType(0) !== LeftParenthesis || e.push(this.MediaQueryList()), e }, block: null } }, media = { parse: { prelude() { return this.createSingleNodeList(this.MediaQueryList()) }, block() { return this.Block(!1) } } }, page = { parse: { prelude() { return this.createSingleNodeList(this.SelectorList()) }, block() { return this.Block(!0) } } }; function consumeRaw() { return this.createSingleNodeList(this.Raw(this.tokenIndex, null, !1)) } function parentheses() { return this.skipSC(), this.tokenType === Ident && this.lookupNonWSType(1) === Colon ? this.createSingleNodeList(this.Declaration()) : readSequence.call(this) } function readSequence() { const e = this.createList(); let t; this.skipSC(); e: for (; !this.eof;) { switch (this.tokenType) { case Comment$1: case WhiteSpace$1: this.next(); continue; case Function$1: t = this.Function(consumeRaw, this.scope.AtrulePrelude); break; case Ident: t = this.Identifier(); break; case LeftParenthesis: t = this.Parentheses(parentheses, this.scope.AtrulePrelude); break; default: break e }e.push(t) } return e } var supports = { parse: { prelude() { const e = readSequence.call(this); return null === this.getFirstListNode(e) && this.error("Condition is expected"), e }, block() { return this.Block(!1) } } }, atrule = { "font-face": fontFace, import: importAtrule, media: media, page: page, supports: supports }; const selectorList = { parse() { return this.createSingleNodeList(this.SelectorList()) } }, selector = { parse() { return this.createSingleNodeList(this.Selector()) } }, identList = { parse() { return this.createSingleNodeList(this.Identifier()) } }, nth = { parse() { return this.createSingleNodeList(this.Nth()) } }; var pseudo = { dir: identList, has: selectorList, lang: identList, matches: selectorList, is: selectorList, "-moz-any": selectorList, "-webkit-any": selectorList, where: selectorList, not: selectorList, "nth-child": nth, "nth-last-child": nth, "nth-last-of-type": nth, "nth-of-type": nth, slotted: selector }, node = Object.freeze({ __proto__: null, AnPlusB: parse$G, Atrule: parse$F, AtrulePrelude: parse$E, AttributeSelector: parse$D, Block: parse$C, Brackets: parse$B, CDC: parse$A, CDO: parse$z, ClassSelector: parse$y, Combinator: parse$x, Comment: parse$w, Declaration: parse$v, DeclarationList: parse$u, Dimension: parse$t, Function: parse$s, Hash: parse$r, IdSelector: parse$p, Identifier: parse$q, MediaFeature: parse$o, MediaQuery: parse$n, MediaQueryList: parse$m, Nth: parse$l, Number: parse$k, Operator: parse$j, Parentheses: parse$i, Percentage: parse$h, PseudoClassSelector: parse$g, PseudoElementSelector: parse$f, Ratio: parse$e, Raw: parse$d, Rule: parse$c, Selector: parse$b, SelectorList: parse$a, String: parse$9, StyleSheet: parse$8, TypeSelector: parse$7, UnicodeRange: parse$6, Url: parse$5, Value: parse$4, WhiteSpace: parse$3 }), parserConfig = { parseContext: { default: "StyleSheet", stylesheet: "StyleSheet", atrule: "Atrule", atrulePrelude(e) { return this.AtrulePrelude(e.atrule ? String(e.atrule) : null) }, mediaQueryList: "MediaQueryList", mediaQuery: "MediaQuery", rule: "Rule", selectorList: "SelectorList", selector: "Selector", block() { return this.Block(!0) }, declarationList: "DeclarationList", declaration: "Declaration", value: "Value" }, scope: scope, atrule: atrule, pseudo: pseudo, node: node }, walkerConfig = { node: node$1 }, syntax$1 = createSyntax$1({ ...lexerConfig, ...parserConfig, ...walkerConfig }); function clone(e) { const t = {}; for (const n in e) { let r = e[n]; r && (Array.isArray(r) || r instanceof List ? r = r.map(clone) : r.constructor === Object && (r = clone(r))), t[n] = r } return t } const { tokenize: tokenize$1, parse: parse$2, generate: generate$2, lexer: lexer$1, createLexer: createLexer, walk: walk$1, find: find$1, findLast: findLast$1, findAll: findAll$1, toPlainObject: toPlainObject$1, fromPlainObject: fromPlainObject$1, fork: fork } = syntax$1, { hasOwnProperty: hasOwnProperty$4 } = Object.prototype; function buildMap(e, t) { const n = Object.create(null); if (!Array.isArray(e)) return null; for (let r of e) t && (r = r.toLowerCase()), n[r] = !0; return n } function buildList(e) { if (!e) return null; const t = buildMap(e.tags, !0), n = buildMap(e.ids), r = buildMap(e.classes); return null === t && null === n && null === r ? null : { tags: t, ids: n, classes: r } } function buildIndex(e) { let t = !1; if (e.scopes && Array.isArray(e.scopes)) { t = Object.create(null); for (let n = 0; n < e.scopes.length; n++) { const r = e.scopes[n]; if (!r || !Array.isArray(r)) throw new Error("Wrong usage format"); for (const e of r) { if (hasOwnProperty$4.call(t, e)) throw new Error(`Class can't be used for several scopes: ${e}`); t[e] = n + 1 } } } return { whitelist: buildList(e), blacklist: buildList(e.blacklist), scopes: t } } function hasNoChildren(e) { return !e || !e.children || e.children.isEmpty } function isNodeChildrenList(e, t) { return null !== e && e.children === t } function cleanAtrule(e, t, n) { if (e.block && (null !== this.stylesheet && (this.stylesheet.firstAtrulesAllowed = !1), hasNoChildren(e.block))) n.remove(t); else switch (e.name) { case "charset": if (hasNoChildren(e.prelude)) return void n.remove(t); if (t.prev) return void n.remove(t); break; case "import": if (null === this.stylesheet || !this.stylesheet.firstAtrulesAllowed) return void n.remove(t); n.prevUntil(t.prev, (function (e) { if ("Atrule" !== e.type || "import" !== e.name && "charset" !== e.name) return this.root.firstAtrulesAllowed = !1, n.remove(t), !0 }), this); break; default: { const r = keyword(e.name).basename; "keyframes" !== r && "media" !== r && "supports" !== r || (hasNoChildren(e.prelude) || hasNoChildren(e.block)) && n.remove(t) } } } function cleanComment(e, t, n) { n.remove(t) } function cleanDeclartion(e, t, n) { e.value.children && e.value.children.isEmpty ? n.remove(t) : property(e.property).custom && /\S/.test(e.value.value) && (e.value.value = e.value.value.trim()) } function cleanRaw(e, t, n) { (isNodeChildrenList(this.stylesheet, n) || isNodeChildrenList(this.block, n)) && n.remove(t) } const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype, skipUsageFilteringAtrule = new Set(["keyframes"]); function cleanUnused(e, t) { return e.children.forEach(((n, r, a) => { let o = !1; walk$1(n, (function (n) { if (null === this.selector || this.selector === e) switch (n.type) { case "SelectorList": null !== this.function && "not" === this.function.name.toLowerCase() || cleanUnused(n, t) && (o = !0); break; case "ClassSelector": null === t.whitelist || null === t.whitelist.classes || hasOwnProperty$3.call(t.whitelist.classes, n.name) || (o = !0), null !== t.blacklist && null !== t.blacklist.classes && hasOwnProperty$3.call(t.blacklist.classes, n.name) && (o = !0); break; case "IdSelector": null === t.whitelist || null === t.whitelist.ids || hasOwnProperty$3.call(t.whitelist.ids, n.name) || (o = !0), null !== t.blacklist && null !== t.blacklist.ids && hasOwnProperty$3.call(t.blacklist.ids, n.name) && (o = !0); break; case "TypeSelector": "*" !== n.name.charAt(n.name.length - 1) && (null === t.whitelist || null === t.whitelist.tags || hasOwnProperty$3.call(t.whitelist.tags, n.name.toLowerCase()) || (o = !0), null !== t.blacklist && null !== t.blacklist.tags && hasOwnProperty$3.call(t.blacklist.tags, n.name.toLowerCase()) && (o = !0)) } })), o && a.remove(r) })), e.children.isEmpty } function cleanRule(e, t, n, r) { if (hasNoChildren(e.prelude) || hasNoChildren(e.block)) return void n.remove(t); if (this.atrule && skipUsageFilteringAtrule.has(keyword(this.atrule.name).basename)) return; const { usage: a } = r; !a || null === a.whitelist && null === a.blacklist || (cleanUnused(e.prelude, a), !hasNoChildren(e.prelude)) || n.remove(t) } function cleanTypeSelector(e, t, n) { if ("*" !== t.data.name) return; const r = t.next && t.next.data.type; "IdSelector" !== r && "ClassSelector" !== r && "AttributeSelector" !== r && "PseudoClassSelector" !== r && "PseudoElementSelector" !== r || n.remove(t) } function cleanWhitespace(e, t, n) { n.remove(t) } const handlers$2 = { Atrule: cleanAtrule, Comment: cleanComment, Declaration: cleanDeclartion, Raw: cleanRaw, Rule: cleanRule, TypeSelector: cleanTypeSelector, WhiteSpace: cleanWhitespace }; function clean(e, t) { walk$1(e, { leave(e, n, r) { handlers$2.hasOwnProperty(e.type) && handlers$2[e.type].call(this, e, n, r, t) } }) } function compressKeyframes(e) { e.block.children.forEach((e => { e.prelude.children.forEach((e => { e.children.forEach(((e, t) => { "Percentage" === e.type && "100" === e.value ? t.data = { type: "TypeSelector", loc: e.loc, name: "to" } : "TypeSelector" === e.type && "from" === e.name && (t.data = { type: "Percentage", loc: e.loc, value: "0" }) })) })) })) } function Atrule(e) { "keyframes" === keyword(e.name).basename && compressKeyframes(e) } const blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/; function canUnquote(e) { return "" !== e && "-" !== e && !blockUnquoteRx.test(e) } function AttributeSelector(e) { const t = e.value; t && "String" === t.type && canUnquote(t.value) && (e.value = { type: "Identifier", loc: t.loc, name: t.value }) } function compressFont(e) { const t = e.children; t.forEachRight((function (e, t) { if ("Identifier" === e.type) if ("bold" === e.name) t.data = { type: "Number", loc: e.loc, value: "700" }; else if ("normal" === e.name) { const e = t.prev; e && "Operator" === e.data.type && "/" === e.data.value && this.remove(e), this.remove(t) } })), t.isEmpty && t.insert(t.createItem({ type: "Identifier", name: "normal" })) } function compressFontWeight(e) { const t = e.children.head.data; if ("Identifier" === t.type) switch (t.name) { case "normal": e.children.head.data = { type: "Number", loc: t.loc, value: "400" }; break; case "bold": e.children.head.data = { type: "Number", loc: t.loc, value: "700" } } } function compressBackground(e) { function t() { r.length || r.unshift({ type: "Number", loc: null, value: "0" }, { type: "Number", loc: null, value: "0" }), n.push.apply(n, r), r = [] } let n = [], r = []; e.children.forEach((e => { if ("Operator" === e.type && "," === e.value) return t(), void n.push(e); ("Identifier" !== e.type || "transparent" !== e.name && "none" !== e.name && "repeat" !== e.name && "scroll" !== e.name) && r.push(e) })), t(), e.children = (new List).fromArray(n) } function compressBorder(e) { e.children.forEach(((e, t, n) => { "Identifier" === e.type && "none" === e.name.toLowerCase() && (n.head === n.tail ? t.data = { type: "Number", loc: e.loc, value: "0" } : n.remove(t)) })) } const handlers$1 = { font: compressFont, "font-weight": compressFontWeight, background: compressBackground, border: compressBorder, outline: compressBorder }; function compressValue(e) { if (!this.declaration) return; const t = property(this.declaration.property); handlers$1.hasOwnProperty(t.basename) && handlers$1[t.basename](e) } const OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/; function packNumber(e, t) { const n = OMIT_PLUSSIGN; return "" !== (e = String(e).replace(n, "$1$2$3")) && "-" !== e || (e = "0"), e } function Number$1(e) { e.value = packNumber(e.value) } const MATH_FUNCTIONS = new Set(["calc", "min", "max", "clamp"]), LENGTH_UNIT = new Set(["px", "mm", "cm", "in", "pt", "pc", "em", "ex", "ch", "rem", "vh", "vw", "vmin", "vmax", "vm"]); function compressDimension(e, t) { const n = packNumber(e.value); if (e.value = n, "0" === n && null !== this.declaration && null === this.atrulePrelude) { const r = e.unit.toLowerCase(); if (!LENGTH_UNIT.has(r)) return; if ("-ms-flex" === this.declaration.property || "flex" === this.declaration.property) return; if (this.function && MATH_FUNCTIONS.has(this.function.name)) return; t.data = { type: "Number", loc: e.loc, value: n } } } const blacklist = new Set(["width", "min-width", "max-width", "height", "min-height", "max-height", "flex", "-ms-flex"]); function compressPercentage(e, t) { e.value = packNumber(e.value), "0" === e.value && this.declaration && !blacklist.has(this.declaration.property) && (t.data = { type: "Number", loc: e.loc, value: e.value }, lexer$1.matchDeclaration(this.declaration).isType(t.data, "length") || (t.data = e)) } function Url(e) { e.value = e.value.replace(/\\/g, "/") } const NAME_TO_HEX = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgrey: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", grey: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "639", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, HEX_TO_NAME = { 8e5: "maroon", 800080: "purple", 808e3: "olive", 808080: "gray", "00ffff": "cyan", f0ffff: "azure", f5f5dc: "beige", ffe4c4: "bisque", "000000": "black", "0000ff": "blue", a52a2a: "brown", ff7f50: "coral", ffd700: "gold", "008000": "green", "4b0082": "indigo", fffff0: "ivory", f0e68c: "khaki", "00ff00": "lime", faf0e6: "linen", "000080": "navy", ffa500: "orange", da70d6: "orchid", cd853f: "peru", ffc0cb: "pink", dda0dd: "plum", f00: "red", ff0000: "red", fa8072: "salmon", a0522d: "sienna", c0c0c0: "silver", fffafa: "snow", d2b48c: "tan", "008080": "teal", ff6347: "tomato", ee82ee: "violet", f5deb3: "wheat", ffffff: "white", ffff00: "yellow" }; function hueToRgb(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function hslToRgb(e, t, n, r) { let a, o, i; if (0 === t) a = o = i = n; else { const r = n < .5 ? n * (1 + t) : n + t - n * t, s = 2 * n - r; a = hueToRgb(s, r, e + 1 / 3), o = hueToRgb(s, r, e), i = hueToRgb(s, r, e - 1 / 3) } return [Math.round(255 * a), Math.round(255 * o), Math.round(255 * i), r] } function toHex(e) { return 1 === (e = e.toString(16)).length ? "0" + e : e } function parseFunctionArgs(e, t, n) { let r = e.head, a = [], o = !1; for (; null !== r;) { const { type: e, value: t } = r.data; switch (e) { case "Number": case "Percentage": if (o) return; o = !0, a.push({ type: e, value: Number(t) }); break; case "Operator": if ("," === t) { if (!o) return; o = !1 } else if (o || "+" !== t) return; break; default: return }r = r.next } if (a.length === t) { if (4 === a.length) { if ("Number" !== a[3].type) return; a[3].type = "Alpha" } if (n) { if (a[0].type !== a[1].type || a[0].type !== a[2].type) return } else { if ("Number" !== a[0].type || "Percentage" !== a[1].type || "Percentage" !== a[2].type) return; a[0].type = "Angle" } return a.map((function (e) { let t = Math.max(0, e.value); switch (e.type) { case "Number": t = Math.min(t, 255); break; case "Percentage": if (t = Math.min(t, 100) / 100, !n) return t; t *= 255; break; case "Angle": return (t % 360 + 360) % 360 / 360; case "Alpha": return Math.min(t, 1) }return Math.round(t) })) } } function compressFunction(e, t) { let n, r = e.name; if ("rgba" === r || "hsla" === r) { if (n = parseFunctionArgs(e.children, 4, "rgba" === r), !n) return; if ("hsla" === r && (n = hslToRgb(...n), e.name = "rgba"), 0 === n[3]) { const r = this.function && this.function.name; if (0 === n[0] && 0 === n[1] && 0 === n[2] || !/^(?:to|from|color-stop)$|gradient$/i.test(r)) return void (t.data = { type: "Identifier", loc: e.loc, name: "transparent" }) } if (1 !== n[3]) return void e.children.forEach(((e, t, r) => { "Operator" !== e.type ? t.data = { type: "Number", loc: e.loc, value: packNumber(n.shift()) } : "," !== e.value && r.remove(t) })); r = "rgb" } if ("hsl" === r) { if (n = n || parseFunctionArgs(e.children, 3, !1), !n) return; n = hslToRgb(...n), r = "rgb" } if ("rgb" === r) { if (n = n || parseFunctionArgs(e.children, 3, !0), !n) return; t.data = { type: "Hash", loc: e.loc, value: toHex(n[0]) + toHex(n[1]) + toHex(n[2]) }, compressHex(t.data, t) } } function compressIdent(e, t) { if (null === this.declaration) return; let n = e.name.toLowerCase(); if (NAME_TO_HEX.hasOwnProperty(n) && lexer$1.matchDeclaration(this.declaration).isType(e, "color")) { const r = NAME_TO_HEX[n]; r.length + 1 <= n.length ? t.data = { type: "Hash", loc: e.loc, value: r } : ("grey" === n && (n = "gray"), e.name = n) } } function compressHex(e, t) { let n = e.value.toLowerCase(); 6 === n.length && n[0] === n[1] && n[2] === n[3] && n[4] === n[5] && (n = n[0] + n[2] + n[4]), HEX_TO_NAME[n] ? t.data = { type: "Identifier", loc: e.loc, name: HEX_TO_NAME[n] } : e.value = n } const handlers = { Atrule: Atrule, AttributeSelector: AttributeSelector, Value: compressValue, Dimension: compressDimension, Percentage: compressPercentage, Number: Number$1, Url: Url, Hash: compressHex, Identifier: compressIdent, Function: compressFunction }; function replace(e) { walk$1(e, { leave(e, t, n) { handlers.hasOwnProperty(e.type) && handlers[e.type].call(this, e, t, n) } }) } class Index { constructor() { this.map = new Map } resolve(e) { let t = this.map.get(e); return void 0 === t && (t = this.map.size + 1, this.map.set(e, t)), t } } function createDeclarationIndexer() { const e = new Index; return function (t) { const n = generate$2(t); return t.id = e.resolve(n), t.length = n.length, t.fingerprint = null, t } } function ensureSelectorList(e) { return "Raw" === e.type ? parse$2(e.value, { context: "selectorList" }) : e } function maxSpecificity(e, t) { for (let n = 0; n < 3; n++)if (e[n] !== t[n]) return e[n] > t[n] ? e : t; return e } function maxSelectorListSpecificity(e) { return ensureSelectorList(e).children.reduce(((e, t) => maxSpecificity(specificity(t), e)), [0, 0, 0]) } function specificity(e) { let t = 0, n = 0, r = 0; return e.children.forEach((e => { switch (e.type) { case "IdSelector": t++; break; case "ClassSelector": case "AttributeSelector": n++; break; case "PseudoClassSelector": switch (e.name.toLowerCase()) { case "not": case "has": case "is": case "matches": case "-webkit-any": case "-moz-any": { const [a, o, i] = maxSelectorListSpecificity(e.children.first); t += a, n += o, r += i; break } case "nth-child": case "nth-last-child": { const a = e.children.first; if ("Nth" === a.type && a.selector) { const [e, o, i] = maxSelectorListSpecificity(a.selector); t += e, n += o + 1, r += i } else n++; break } case "where": break; case "before": case "after": case "first-line": case "first-letter": r++; break; default: n++ }break; case "TypeSelector": e.name.endsWith("*") || r++; break; case "PseudoElementSelector": r++ } })), [t, n, r] } const nonFreezePseudoElements = new Set(["first-letter", "first-line", "after", "before"]), nonFreezePseudoClasses = new Set(["link", "visited", "hover", "active", "first-letter", "first-line", "after", "before"]); function processSelector(e, t) { const n = new Set; e.prelude.children.forEach((function (e) { let r = "*", a = 0; e.children.forEach((function (o) { switch (o.type) { case "ClassSelector": if (t && t.scopes) { const n = t.scopes[o.name] || 0; if (0 !== a && n !== a) throw new Error("Selector can't has classes from different scopes: " + generate$2(e)); a = n } break; case "PseudoClassSelector": { const e = o.name.toLowerCase(); nonFreezePseudoClasses.has(e) || n.add(`:${e}`); break } case "PseudoElementSelector": { const e = o.name.toLowerCase(); nonFreezePseudoElements.has(e) || n.add(`::${e}`); break } case "TypeSelector": r = o.name.toLowerCase(); break; case "AttributeSelector": o.flags && n.add(`[${o.flags.toLowerCase()}]`); break; case "Combinator": r = "*" } })), e.compareMarker = specificity(e).toString(), e.id = null, e.id = generate$2(e), a && (e.compareMarker += ":" + a), "*" !== r && (e.compareMarker += "," + r) })), e.pseudoSignature = n.size > 0 && [...n].sort().join(",") } function prepare(e, t) { const n = createDeclarationIndexer(); return walk$1(e, { visit: "Rule", enter(e) { e.block.children.forEach(n), processSelector(e, t.usage) } }), walk$1(e, { visit: "Atrule", enter(e) { e.prelude && (e.prelude.id = null, e.prelude.id = generate$2(e.prelude)), "keyframes" === keyword(e.name).basename && (e.block.avoidRulesMerge = !0, e.block.children.forEach((function (e) { e.prelude.children.forEach((function (e) { e.compareMarker = e.id })) }))) } }), { declaration: n } } const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype; function addRuleToMap(e, t, n, r) { const a = t.data, o = keyword(a.name).basename, i = a.name.toLowerCase() + "/" + (a.prelude ? a.prelude.id : null); hasOwnProperty$2.call(e, o) || (e[o] = Object.create(null)), r && delete e[o][i], hasOwnProperty$2.call(e[o], i) || (e[o][i] = new List), e[o][i].append(n.remove(t)) } function relocateAtrules(e, t) { const n = Object.create(null); let r = null; e.children.forEach((function (e, a, o) { if ("Atrule" === e.type) { const i = keyword(e.name).basename; switch (i) { case "keyframes": return void addRuleToMap(n, a, o, !0); case "media": if (t.forceMediaMerge) return void addRuleToMap(n, a, o, !1) }null === r && "charset" !== i && "import" !== i && (r = a) } else null === r && (r = a) })); for (const t in n) for (const a in n[t]) e.children.insertList(n[t][a], "media" === t ? null : r) } function isMediaRule(e) { return "Atrule" === e.type && "media" === e.name } function processAtrule(e, t, n) { if (!isMediaRule(e)) return; const r = t.prev && t.prev.data; r && isMediaRule(r) && e.prelude && r.prelude && e.prelude.id === r.prelude.id && (r.block.children.appendList(e.block.children), n.remove(t)) } function rejoinAtrule(e, t) { relocateAtrules(e, t), walk$1(e, { visit: "Atrule", reverse: !0, enter: processAtrule }) } const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype; function isEqualSelectors(e, t) { let n = e.head, r = t.head; for (; null !== n && null !== r && n.data.id === r.data.id;)n = n.next, r = r.next; return null === n && null === r } function isEqualDeclarations(e, t) { let n = e.head, r = t.head; for (; null !== n && null !== r && n.data.id === r.data.id;)n = n.next, r = r.next; return null === n && null === r } function compareDeclarations(e, t) { const n = { eq: [], ne1: [], ne2: [], ne2overrided: [] }, r = Object.create(null), a = Object.create(null); for (let e = t.head; e; e = e.next)a[e.data.id] = !0; for (let t = e.head; t; t = t.next) { const e = t.data; e.fingerprint && (r[e.fingerprint] = e.important), a[e.id] ? (a[e.id] = !1, n.eq.push(e)) : n.ne1.push(e) } for (let e = t.head; e; e = e.next) { const t = e.data; a[t.id] && ((!hasOwnProperty$1.call(r, t.fingerprint) || !r[t.fingerprint] && t.important) && n.ne2.push(t), n.ne2overrided.push(t)) } return n } function addSelectors(e, t) { return t.forEach((t => { const n = t.id; let r = e.head; for (; r;) { const e = r.data.id; if (e === n) return; if (e > n) break; r = r.next } e.insert(e.createItem(t), r) })), e } function hasSimilarSelectors(e, t) { let n = e.head; for (; null !== n;) { let e = t.head; for (; null !== e;) { if (n.data.compareMarker === e.data.compareMarker) return !0; e = e.next } n = n.next } return !1 } function unsafeToSkipNode(e) { switch (e.type) { case "Rule": return hasSimilarSelectors(e.prelude.children, this); case "Atrule": if (e.block) return e.block.children.some(unsafeToSkipNode, this); break; case "Declaration": return !1 }return !0 } function processRule$5(e, t, n) { const r = e.prelude.children, a = e.block.children; n.prevUntil(t.prev, (function (o) { if ("Rule" !== o.type) return unsafeToSkipNode.call(r, o); const i = o.prelude.children, s = o.block.children; if (e.pseudoSignature === o.pseudoSignature) { if (isEqualSelectors(i, r)) return s.appendList(a), n.remove(t), !0; if (isEqualDeclarations(a, s)) return addSelectors(i, r), n.remove(t), !0 } return hasSimilarSelectors(r, i) })) } function initialMergeRule(e) { walk$1(e, { visit: "Rule", enter: processRule$5 }) } function processRule$4(e, t, n) { const r = e.prelude.children; for (; r.head !== r.tail;) { const a = new List; a.insert(r.remove(r.head)), n.insert(n.createItem({ type: "Rule", loc: e.loc, prelude: { type: "SelectorList", loc: e.prelude.loc, children: a }, block: { type: "Block", loc: e.block.loc, children: e.block.children.copy() }, pseudoSignature: e.pseudoSignature }), t) } } function disjoinRule(e) { walk$1(e, { visit: "Rule", reverse: !0, enter: processRule$4 }) } const REPLACE = 1, REMOVE = 2, TOP = 0, RIGHT = 1, BOTTOM = 2, LEFT = 3, SIDES = ["top", "right", "bottom", "left"], SIDE = { "margin-top": "top", "margin-right": "right", "margin-bottom": "bottom", "margin-left": "left", "padding-top": "top", "padding-right": "right", "padding-bottom": "bottom", "padding-left": "left", "border-top-color": "top", "border-right-color": "right", "border-bottom-color": "bottom", "border-left-color": "left", "border-top-width": "top", "border-right-width": "right", "border-bottom-width": "bottom", "border-left-width": "left", "border-top-style": "top", "border-right-style": "right", "border-bottom-style": "bottom", "border-left-style": "left" }, MAIN_PROPERTY = { margin: "margin", "margin-top": "margin", "margin-right": "margin", "margin-bottom": "margin", "margin-left": "margin", padding: "padding", "padding-top": "padding", "padding-right": "padding", "padding-bottom": "padding", "padding-left": "padding", "border-color": "border-color", "border-top-color": "border-color", "border-right-color": "border-color", "border-bottom-color": "border-color", "border-left-color": "border-color", "border-width": "border-width", "border-top-width": "border-width", "border-right-width": "border-width", "border-bottom-width": "border-width", "border-left-width": "border-width", "border-style": "border-style", "border-top-style": "border-style", "border-right-style": "border-style", "border-bottom-style": "border-style", "border-left-style": "border-style" }; class TRBL { constructor(e) { this.name = e, this.loc = null, this.iehack = void 0, this.sides = { top: null, right: null, bottom: null, left: null } } getValueSequence(e, t) { const n = []; let r = ""; return !("Value" !== e.value.type || e.value.children.some((function (t) { let a = !1; switch (t.type) { case "Identifier": switch (t.name) { case "\\0": case "\\9": return void (r = t.name); case "inherit": case "initial": case "unset": case "revert": a = t.name }break; case "Dimension": switch (t.unit) { case "rem": case "vw": case "vh": case "vmin": case "vmax": case "vm": a = t.unit }break; case "Hash": case "Number": case "Percentage": break; case "Function": if ("var" === t.name) return !0; a = t.name; break; default: return !0 }n.push({ node: t, special: a, important: e.important }) })) || n.length > t) && (("string" != typeof this.iehack || this.iehack === r) && (this.iehack = r, n)) } canOverride(e, t) { const n = this.sides[e]; return !n || t.important && !n.important } add(e, t) { return !!function () { const n = this.sides, r = SIDE[e]; if (r) { if (r in n == !1) return !1; const e = this.getValueSequence(t, 1); if (!e || !e.length) return !1; for (const t in n) if (null !== n[t] && n[t].special !== e[0].special) return !1; return !this.canOverride(r, e[0]) || (n[r] = e[0], !0) } if (e === this.name) { const e = this.getValueSequence(t, 4); if (!e || !e.length) return !1; switch (e.length) { case 1: e[1] = e[0], e[2] = e[0], e[3] = e[0]; break; case 2: e[2] = e[0], e[3] = e[1]; break; case 3: e[3] = e[1] }for (let t = 0; t < 4; t++)for (const r in n) if (null !== n[r] && n[r].special !== e[t].special) return !1; for (let t = 0; t < 4; t++)this.canOverride(SIDES[t], e[t]) && (n[SIDES[t]] = e[t]); return !0 } }.call(this) && (this.loc || (this.loc = t.loc), !0) } isOkToMinimize() { const e = this.sides.top, t = this.sides.right, n = this.sides.bottom, r = this.sides.left; if (e && t && n && r) { const a = e.important + t.important + n.important + r.important; return 0 === a || 4 === a } return !1 } getValue() { const e = new List, t = this.sides, n = [t.top, t.right, t.bottom, t.left], r = [generate$2(t.top.node), generate$2(t.right.node), generate$2(t.bottom.node), generate$2(t.left.node)]; r[3] === r[1] && (n.pop(), r[2] === r[0] && (n.pop(), r[1] === r[0] && n.pop())); for (let t = 0; t < n.length; t++)e.appendData(n[t].node); return this.iehack && e.appendData({ type: "Identifier", loc: null, name: this.iehack }), { type: "Value", loc: null, children: e } } getDeclaration() { return { type: "Declaration", loc: this.loc, important: this.sides.top.important, property: this.name, value: this.getValue() } } } function processRule$3(e, t, n, r) { const a = e.block.children, o = e.prelude.children.first.id; return e.block.children.forEachRight((function (e, i) { const s = e.property; if (!MAIN_PROPERTY.hasOwnProperty(s)) return; const l = MAIN_PROPERTY[s]; let c, u; r && o !== r || !(l in t) || (u = REMOVE, c = t[l]), c && c.add(s, e) || (u = REPLACE, c = new TRBL(l), c.add(s, e)) ? (t[l] = c, n.push({ operation: u, block: a, item: i, shorthand: c }), r = o) : r = null })), r } function processShorthands(e, t) { e.forEach((function (e) { const n = e.shorthand; n.isOkToMinimize() && (e.operation === REPLACE ? e.item.data = t(n.getDeclaration()) : e.block.remove(e.item)) })) } function restructBlock$1(e, t) { const n = {}, r = []; walk$1(e, { visit: "Rule", reverse: !0, enter(e) { const t = this.block || this.stylesheet, a = (e.pseudoSignature || "") + "|" + e.prelude.children.first.id; let o, i; n.hasOwnProperty(t.id) ? o = n[t.id] : (o = { lastShortSelector: null }, n[t.id] = o), o.hasOwnProperty(a) ? i = o[a] : (i = {}, o[a] = i), o.lastShortSelector = processRule$3.call(this, e, i, r, o.lastShortSelector) } }), processShorthands(r, t.declaration) } let fingerprintId = 1; const dontRestructure = new Set(["src"]), DONT_MIX_VALUE = { display: /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i, "text-align": /^(start|end|match-parent|justify-all)$/i }, SAFE_VALUES = { cursor: ["auto", "crosshair", "default", "move", "text", "wait", "help", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "pointer", "progress", "not-allowed", "no-drop", "vertical-text", "all-scroll", "col-resize", "row-resize"], overflow: ["hidden", "visible", "scroll", "auto"], position: ["static", "relative", "absolute", "fixed"] }, NEEDLESS_TABLE = { "border-width": ["border"], "border-style": ["border"], "border-color": ["border"], "border-top": ["border"], "border-right": ["border"], "border-bottom": ["border"], "border-left": ["border"], "border-top-width": ["border-top", "border-width", "border"], "border-right-width": ["border-right", "border-width", "border"], "border-bottom-width": ["border-bottom", "border-width", "border"], "border-left-width": ["border-left", "border-width", "border"], "border-top-style": ["border-top", "border-style", "border"], "border-right-style": ["border-right", "border-style", "border"], "border-bottom-style": ["border-bottom", "border-style", "border"], "border-left-style": ["border-left", "border-style", "border"], "border-top-color": ["border-top", "border-color", "border"], "border-right-color": ["border-right", "border-color", "border"], "border-bottom-color": ["border-bottom", "border-color", "border"], "border-left-color": ["border-left", "border-color", "border"], "margin-top": ["margin"], "margin-right": ["margin"], "margin-bottom": ["margin"], "margin-left": ["margin"], "padding-top": ["padding"], "padding-right": ["padding"], "padding-bottom": ["padding"], "padding-left": ["padding"], "font-style": ["font"], "font-variant": ["font"], "font-weight": ["font"], "font-size": ["font"], "font-family": ["font"], "list-style-type": ["list-style"], "list-style-position": ["list-style"], "list-style-image": ["list-style"] }; function getPropertyFingerprint(e, t, n) { const r = property(e).basename; if ("background" === r) return e + ":" + generate$2(t.value); const a = t.id; let o = n[a]; if (!o) { switch (t.value.type) { case "Value": const e = {}; let n = "", a = "", i = !1; t.value.children.forEach((function t(o) { switch (o.type) { case "Value": case "Brackets": case "Parentheses": o.children.forEach(t); break; case "Raw": i = !0; break; case "Identifier": { const { name: t } = o; n || (n = keyword(t).vendor), /\\[09]/.test(t) && (a = RegExp.lastMatch), SAFE_VALUES.hasOwnProperty(r) ? -1 === SAFE_VALUES[r].indexOf(t) && (e[t] = !0) : DONT_MIX_VALUE.hasOwnProperty(r) && DONT_MIX_VALUE[r].test(t) && (e[t] = !0); break } case "Function": { let { name: r } = o; if (n || (n = keyword(r).vendor), "rect" === r) { o.children.some((e => "Operator" === e.type && "," === e.value)) || (r = "rect-backward") } e[r + "()"] = !0, o.children.forEach(t); break } case "Dimension": { const { unit: t } = o; switch (/\\[09]/.test(t) && (a = RegExp.lastMatch), t) { case "rem": case "vw": case "vh": case "vmin": case "vmax": case "vm": e[t] = !0 }break } } })), o = i ? "!" + fingerprintId++ : "!" + Object.keys(e).sort() + "|" + a + n; break; case "Raw": o = "!" + t.value.value; break; default: o = generate$2(t.value) }n[a] = o } return e + o } function needless(e, t, n) { const r = property(t.property); if (NEEDLESS_TABLE.hasOwnProperty(r.basename)) { const a = NEEDLESS_TABLE[r.basename]; for (const o of a) { const a = getPropertyFingerprint(r.prefix + o, t, n), i = e.hasOwnProperty(a) ? e[a] : null; if (i && (!t.important || i.item.data.important)) return i } } } function processRule$2(e, t, n, r, a) { const o = e.block.children; o.forEachRight((function (e, t) { const { property: n } = e, i = getPropertyFingerprint(n, e, a), s = r[i]; if (s && !dontRestructure.has(n)) e.important && !s.item.data.important ? (r[i] = { block: o, item: t }, s.block.remove(s.item)) : o.remove(t); else { needless(r, e, a) ? o.remove(t) : (e.fingerprint = i, r[i] = { block: o, item: t }) } })), o.isEmpty && n.remove(t) } function restructBlock(e) { const t = {}, n = Object.create(null); walk$1(e, { visit: "Rule", reverse: !0, enter(e, r, a) { const o = this.block || this.stylesheet, i = (e.pseudoSignature || "") + "|" + e.prelude.children.first.id; let s, l; t.hasOwnProperty(o.id) ? s = t[o.id] : (s = {}, t[o.id] = s), s.hasOwnProperty(i) ? l = s[i] : (l = {}, s[i] = l), processRule$2.call(this, e, r, a, l, n) } }) } function processRule$1(e, t, n) { const r = e.prelude.children, a = e.block.children, o = r.first.compareMarker, i = {}; n.nextUntil(t.next, (function (t, s) { if ("Rule" !== t.type) return unsafeToSkipNode.call(r, t); if (e.pseudoSignature !== t.pseudoSignature) return !0; const l = t.prelude.children.head, c = t.block.children, u = l.data.compareMarker; if (u in i) return !0; if (r.head === r.tail && r.first.id === l.data.id) return a.appendList(c), void n.remove(s); if (isEqualDeclarations(a, c)) { const e = l.data.id; return r.some(((t, n) => { const a = t.id; return e < a ? (r.insert(l, n), !0) : n.next ? void 0 : (r.insert(l), !0) })), void n.remove(s) } if (u === o) return !0; i[u] = !0 })) } function mergeRule(e) { walk$1(e, { visit: "Rule", enter: processRule$1 }) } function calcSelectorLength(e) { return e.reduce(((e, t) => e + t.id.length + 1), 0) - 1 } function calcDeclarationsLength(e) { let t = 0; for (const n of e) t += n.length; return t + e.length - 1 } function processRule(e, t, n) { const r = null !== this.block && this.block.avoidRulesMerge, a = e.prelude.children, o = e.block, i = Object.create(null); let s = !0, l = !0; n.prevUntil(t.prev, (function (c, u) { const d = c.block, p = c.type; if ("Rule" !== p) { const e = unsafeToSkipNode.call(a, c); return !e && "Atrule" === p && d && walk$1(d, { visit: "Rule", enter(e) { e.prelude.children.forEach((e => { i[e.compareMarker] = !0 })) } }), e } if (e.pseudoSignature !== c.pseudoSignature) return !0; const h = c.prelude.children; if (l = !h.some((e => e.compareMarker in i)), !l && !s) return !0; if (s && isEqualSelectors(h, a)) return d.children.appendList(o.children), n.remove(t), !0; const m = compareDeclarations(o.children, d.children); if (m.eq.length) { if (!m.ne1.length && !m.ne2.length) return l && (addSelectors(a, h), n.remove(u)), !0; if (!r) if (m.ne1.length && !m.ne2.length) { const e = calcSelectorLength(a), t = calcDeclarationsLength(m.eq); s && e < t && (addSelectors(h, a), o.children.fromArray(m.ne1)) } else if (!m.ne1.length && m.ne2.length) { const e = calcSelectorLength(h), t = calcDeclarationsLength(m.eq); l && e < t && (addSelectors(a, h), d.children.fromArray(m.ne2)) } else { const r = { type: "SelectorList", loc: null, children: addSelectors(h.copy(), a) }, i = calcSelectorLength(r.children) + 2; if (calcDeclarationsLength(m.eq) >= i) { const a = n.createItem({ type: "Rule", loc: null, prelude: r, block: { type: "Block", loc: null, children: (new List).fromArray(m.eq) }, pseudoSignature: e.pseudoSignature }); return o.children.fromArray(m.ne1), d.children.fromArray(m.ne2overrided), s ? n.insert(a, u) : n.insert(a, t), !0 } } } s && (s = !h.some((e => a.some((t => t.compareMarker === e.compareMarker))))), h.forEach((e => { i[e.compareMarker] = !0 })) })) } function restructRule(e) { walk$1(e, { visit: "Rule", reverse: !0, enter: processRule }) } function restructure(e, t) { const n = prepare(e, t); t.logger("prepare", e), rejoinAtrule(e, t), t.logger("mergeAtrule", e), initialMergeRule(e), t.logger("initialMergeRuleset", e), disjoinRule(e), t.logger("disjoinRuleset", e), restructBlock$1(e, n), t.logger("restructShorthand", e), restructBlock(e), t.logger("restructBlock", e), mergeRule(e), t.logger("mergeRuleset", e), restructRule(e), t.logger("restructRuleset", e) } function readChunk(e, t) { const n = new List; let r, a = !1; return e.nextUntil(e.head, ((e, o, i) => { if ("Comment" === e.type) return t && "!" === e.value.charAt(0) ? !(!a && !r) || (i.remove(o), void (r = e)) : void i.remove(o); "WhiteSpace" !== e.type && (a = !0), n.insert(i.remove(o)) })), { comment: r, stylesheet: { type: "StyleSheet", loc: null, children: n } } } function compressChunk(e, t, n, r) { r.logger(`Compress block #${n}`, null, !0); let a = 1; return "StyleSheet" === e.type && (e.firstAtrulesAllowed = t, e.id = a++), walk$1(e, { visit: "Atrule", enter(e) { null !== e.block && (e.block.id = a++) } }), r.logger("init", e), clean(e, r), r.logger("clean", e), replace(e), r.logger("replace", e), r.restructuring && restructure(e, r), e } function getCommentsOption(e) { let t = "comments" in e ? e.comments : "exclamation"; return "boolean" == typeof t ? t = !!t && "exclamation" : "exclamation" !== t && "first-exclamation" !== t && (t = !1), t } function getRestructureOption(e) { return "restructure" in e ? e.restructure : !("restructuring" in e) || e.restructuring } function wrapBlock(e) { return (new List).appendData({ type: "Rule", loc: null, prelude: { type: "SelectorList", loc: null, children: (new List).appendData({ type: "Selector", loc: null, children: (new List).appendData({ type: "TypeSelector", loc: null, name: "x" }) }) }, block: e }) } function compress$1(e, t) { e = e || { type: "StyleSheet", loc: null, children: new List }; const n = { logger: "function" == typeof (t = t || {}).logger ? t.logger : function () { }, restructuring: getRestructureOption(t), forceMediaMerge: Boolean(t.forceMediaMerge), usage: !!t.usage && buildIndex(t.usage) }, r = new List; let a, o, i, s = getCommentsOption(t), l = !0, c = 1; t.clone && (e = clone(e)), "StyleSheet" === e.type ? (a = e.children, e.children = r) : a = wrapBlock(e); do { if (o = readChunk(a, Boolean(s)), compressChunk(o.stylesheet, l, c++, n), i = o.stylesheet.children, o.comment && (r.isEmpty || r.insert(List.createItem({ type: "Raw", value: "\n" })), r.insert(List.createItem(o.comment)), i.isEmpty || r.insert(List.createItem({ type: "Raw", value: "\n" }))), l && !i.isEmpty) { const e = i.last; ("Atrule" !== e.type || "import" !== e.name && "charset" !== e.name) && (l = !1) } "exclamation" !== s && (s = !1), r.appendList(i) } while (!a.isEmpty); return { ast: e } } function encodeString(e) { const t = encode$1(e, !0), n = encode$1(e); return t.length < n.length ? t : n } const { lexer: lexer, tokenize: tokenize, parse: parse$1, generate: generate$1, walk: walk, find: find, findLast: findLast, findAll: findAll, fromPlainObject: fromPlainObject, toPlainObject: toPlainObject } = fork({ node: { String: { generate(e) { this.token(String$2, encodeString(e.value)) } }, Url: { generate(e) { const t = encode(e.value), n = encodeString(e.value); this.token(Url$2, t.length <= n.length + 5 ? t : "url(" + n + ")") } } } }); var syntax = Object.freeze({ __proto__: null, compress: compress$1, find: find, findAll: findAll, findLast: findLast, fromPlainObject: fromPlainObject, generate: generate$1, lexer: lexer, parse: parse$1, specificity: specificity, toPlainObject: toPlainObject, tokenize: tokenize, walk: walk }); const { parse: parse, generate: generate, compress: compress } = syntax; function debugOutput(e, t, n, r) { return t.debug && console.error(`## ${e} done in %d ms\n`, Date.now() - n), r } function createDefaultLogger(e) { let t; return function (n, r) { let a = n; if (r && (a = `[${((Date.now() - t) / 1e3).toFixed(3)}s] ${a}`), e > 1 && r) { let t = generate(r); 2 === e && t.length > 256 && (t = t.substr(0, 256) + "..."), a += `\n  ${t}\n` } console.error(a), t = Date.now() } } function buildCompressOptions(e) { return "function" != typeof (e = { ...e }).logger && e.debug && (e.logger = createDefaultLogger(e.debug)), e } function runHandler(e, t, n) { Array.isArray(n) || (n = [n]), n.forEach((n => n(e, t))) } function minify(e, t, n) { const r = (n = n || {}).filename || "<unknown>"; let a; const o = debugOutput("parsing", n, Date.now(), parse(t, { context: e, filename: r, positions: Boolean(n.sourceMap) })); n.beforeCompress && debugOutput("beforeCompress", n, Date.now(), runHandler(o, n, n.beforeCompress)); const i = debugOutput("compress", n, Date.now(), compress(o, buildCompressOptions(n))); return n.afterCompress && debugOutput("afterCompress", n, Date.now(), runHandler(i, n, n.afterCompress)), a = n.sourceMap ? debugOutput("generate(sourceMap: true)", n, Date.now(), (() => { const e = generate(i.ast, { sourceMap: !0 }); return e.map._file = r, e.map.setSourceContent(r, t), e })()) : debugOutput("generate", n, Date.now(), { css: generate(i.ast), map: null }), a } function minifyStylesheet(e, t) { return minify("stylesheet", e, t) } function minifyBlock(e, t) { return minify("declarationList", e, t) } const csstreeWalkSkip = walk$3.skip, parseRule = (e, t) => { const n = []; e.block.children.forEach((e => { "Declaration" === e.type && n.push({ name: e.property, value: generate$I(e.value), important: !0 === e.important }) })); const r = []; return walk$3(e.prelude, (e => { if ("Selector" === e.type) { const a = clone$1(e); let o = !1; walk$3(a, ((e, t, n) => { "PseudoClassSelector" === e.type && (o = !0, n.remove(t)) })), r.push({ specificity: specificity(e), dynamic: o || t, selector: generate$I(a), declarations: n }) } })), r }, parseStylesheet = (e, t) => { const n = [], r = parse$I(e, { parseValue: !1, parseAtrulePrelude: !1 }); return walk$3(r, (e => "Rule" === e.type ? (n.push(...parseRule(e, t || !1)), csstreeWalkSkip) : "Atrule" === e.type ? (["keyframes", "-webkit-keyframes", "-o-keyframes", "-moz-keyframes"].includes(e.name) || walk$3(e, (e => { if ("Rule" === e.type) return n.push(...parseRule(e, t || !0)), csstreeWalkSkip })), csstreeWalkSkip) : void 0)), n }, parseStyleDeclarations = e => { const t = [], n = parse$I(e, { context: "declarationList", parseValue: !1 }); return walk$3(n, (e => { "Declaration" === e.type && t.push({ name: e.property, value: generate$I(e.value), important: !0 === e.important }) })), t }, computeOwnStyle = (e, t, n) => { const r = {}, a = new Map; for (const [e, n] of Object.entries(t.attributes)) attrsGroups.presentation.has(e) && (r[e] = { type: "static", inherited: !1, value: n }, a.set(e, !1)); for (const { selector: o, declarations: i, dynamic: s } of e.rules) if (matches(t, o, n)) for (const { name: e, value: t, important: n } of i) { const o = r[e]; o && "dynamic" === o.type || (s ? r[e] = { type: "dynamic", inherited: !1 } : null != o && !0 !== n && !1 !== a.get(e) || (r[e] = { type: "static", inherited: !1, value: t }, a.set(e, n))) } const o = null == t.attributes.style ? [] : parseStyleDeclarations(t.attributes.style); for (const { name: e, value: t, important: n } of o) { const o = r[e]; o && "dynamic" === o.type || (null != o && !0 !== n && !1 !== a.get(e) || (r[e] = { type: "static", inherited: !1, value: t }, a.set(e, n))) } return r }, compareSpecificity = (e, t) => { for (let n = 0; n < 4; n += 1) { if (e[n] < t[n]) return -1; if (e[n] > t[n]) return 1 } return 0 }, collectStylesheet = e => { const t = [], n = new Map; return visit(e, { element: { enter: (e, r) => { if (n.set(e, r), "style" === e.name && (null == e.attributes.type || "" === e.attributes.type || "text/css" === e.attributes.type)) { const n = null != e.attributes.media && "all" !== e.attributes.media; for (const r of e.children) "text" !== r.type && "cdata" !== r.type || t.push(...parseStylesheet(r.value, n)) } } } }), t.sort(((e, t) => compareSpecificity(e.specificity, t.specificity))), { rules: t, parents: n } }, computeStyle = (e, t) => { const { parents: n } = e, r = computeOwnStyle(e, t, n); let a = n.get(t); for (; null != a && "root" !== a.type;) { const t = computeOwnStyle(e, a, n); for (const [e, n] of Object.entries(t)) null == r[e] && inheritableAttrs.has(e) && !presentationNonInheritableGroupAttrs.has(e) && (r[e] = { ...n, inherited: !0 }); a = n.get(a) } return r }, includesAttrSelector = (e, t, n = null, r = !1) => { const a = parse$1w("string" == typeof e ? e : generate$I(e.data)); for (const e of a) { if (e.some(((a, o) => { if (r) { if (o === e.length - 1) return !1; if (!isTraversal$1(e[o + 1])) return !1 } return "attribute" === a.type && a.name === t && (null == n || a.value === n) }))) return !0 } return !1 }, name$N = "removeDeprecatedAttrs", description$N = "removes deprecated attributes"; function extractAttributesInStylesheet(e) { const t = new Set; return e.rules.forEach((e => { parse$1w(e.selector).forEach((e => { e.forEach((e => { "attribute" === e.type && t.add(e.name) })) })) })), t } function processAttributes(e, t, n, r) { t && (t.safe && t.safe.forEach((t => { r.has(t) || delete e.attributes[t] })), n.removeUnsafe && t.unsafe && t.unsafe.forEach((t => { r.has(t) || delete e.attributes[t] }))) } function fn$N(e, t) { const n = extractAttributesInStylesheet(collectStylesheet(e)); return { element: { enter: e => { const r = elems[e.name]; r && (r.attrsGroups.has("core") && e.attributes["xml:lang"] && !n.has("xml:lang") && e.attributes.lang && delete e.attributes["xml:lang"], r.attrsGroups.forEach((r => { processAttributes(e, attrsGroupsDeprecated[r], t, n) })), processAttributes(e, r.deprecated, t, n)) } } } } var removeDeprecatedAttrs = Object.freeze({ __proto__: null, description: description$N, fn: fn$N, name: name$N }); const name$M = "removeMetadata", description$M = "removes <metadata>", fn$M = () => ({ element: { enter: (e, t) => { "metadata" === e.name && detachNodeFromParent(e, t) } } }); var removeMetadata = Object.freeze({ __proto__: null, description: description$M, fn: fn$M, name: name$M }); const name$L = "removeEditorsNSData", description$L = "removes editors namespaces, elements and attributes", fn$L = (e, t) => { let n = [...editorNamespaces]; Array.isArray(t.additionalNamespaces) && (n = [...editorNamespaces, ...t.additionalNamespaces]); const r = []; return { element: { enter: (e, t) => { if ("svg" === e.name) for (const [t, a] of Object.entries(e.attributes)) t.startsWith("xmlns:") && n.includes(a) && (r.push(t.slice(6)), delete e.attributes[t]); for (const t of Object.keys(e.attributes)) if (t.includes(":")) { const [n] = t.split(":"); r.includes(n) && delete e.attributes[t] } if (e.name.includes(":")) { const [n] = e.name.split(":"); r.includes(n) && detachNodeFromParent(e, t) } } } } }; var removeEditorsNSData = Object.freeze({ __proto__: null, description: description$L, fn: fn$L, name: name$L }); const name$K = "cleanupAttrs", description$K = "cleanups attributes from newlines, trailing and repeating spaces", regNewlinesNeedSpace = /(\S)\r?\n(\S)/g, regNewlines = /\r?\n/g, regSpaces = /\s{2,}/g, fn$K = (e, t) => { const { newlines: n = !0, trim: r = !0, spaces: a = !0 } = t; return { element: { enter: e => { for (const t of Object.keys(e.attributes)) n && (e.attributes[t] = e.attributes[t].replace(regNewlinesNeedSpace, ((e, t, n) => t + " " + n)), e.attributes[t] = e.attributes[t].replace(regNewlines, "")), r && (e.attributes[t] = e.attributes[t].trim()), a && (e.attributes[t] = e.attributes[t].replace(regSpaces, " ")) } } } }; var cleanupAttrs = Object.freeze({ __proto__: null, description: description$K, fn: fn$K, name: name$K }); const name$J = "mergeStyles", description$J = "merge multiple style elements into one", fn$J = () => { let e = null, t = "", n = "text"; return { element: { enter: (r, a) => { if ("foreignObject" === r.name) return visitSkip; if ("style" !== r.name) return; if (null != r.attributes.type && "" !== r.attributes.type && "text/css" !== r.attributes.type) return; let o = ""; for (const e of r.children) "text" === e.type && (o += e.value), "cdata" === e.type && (n = "cdata", o += e.value); if (0 !== o.trim().length) if (null == r.attributes.media ? t += o : (t += `@media ${r.attributes.media}{${o}}`, delete r.attributes.media), null == e) e = r; else { detachNodeFromParent(r, a); const o = { type: n, value: t }; e.children = [o] } else detachNodeFromParent(r, a) } } } }; var mergeStyles = Object.freeze({ __proto__: null, description: description$J, fn: fn$J, name: name$J }); const name$I = "inlineStyles", description$I = "inline styles (additional options)", preservedPseudos = [...pseudoClasses.functional, ...pseudoClasses.treeStructural], fn$I = (e, t) => { const { onlyMatchedOnce: n = !0, removeMatchedSelectors: r = !0, useMqs: a = ["", "screen"], usePseudos: o = [""] } = t, i = [], s = []; return { element: { enter: (e, t) => { if ("foreignObject" === e.name) return visitSkip; if ("style" !== e.name || 0 === e.children.length) return; if (null != e.attributes.type && "" !== e.attributes.type && "text/css" !== e.attributes.type) return; const n = e.children.filter((e => "text" === e.type || "cdata" === e.type)).map((e => e.value)).join(""); let r = null; try { r = parse$I(n, { parseValue: !1, parseCustomProperty: !1 }) } catch { return } "StyleSheet" === r.type && i.push({ node: e, parentNode: t, cssAst: r }), walk$3(r, { visit: "Rule", enter(e) { const t = this.atrule; let n = ""; null != t && (n = t.name, null != t.prelude && (n += ` ${generate$I(t.prelude)}`)), a.includes(n) && "SelectorList" === e.prelude.type && e.prelude.children.forEach(((t, n) => { if ("Selector" === t.type) { const r = []; t.children.forEach(((e, t, n) => { ("PseudoClassSelector" === e.type || "PseudoElementSelector" === e.type) && !preservedPseudos.includes(e.name) && r.push({ item: t, list: n }) })); const a = generate$I({ type: "Selector", children: (new List$1).fromArray(r.map((e => e.item.data))) }); if (o.includes(a)) for (const e of r) e.list.remove(e.item); s.push({ node: t, rule: e, item: n }) } })) } }) } }, root: { exit: () => { if (0 === i.length) return; const t = s.slice().sort(((e, t) => { const n = specificity(e.item.data), r = specificity(t.item.data); return compareSpecificity(n, r) })).reverse(); for (const a of t) { const t = generate$I(a.item.data), o = []; try { for (const n of querySelectorAll(e, t)) "element" === n.type && o.push(n) } catch { continue } if (0 !== o.length && !(n && o.length > 1)) { for (const e of o) { const t = parse$I(e.attributes.style ?? "", { context: "declarationList", parseValue: !1 }); if ("DeclarationList" !== t.type) continue; const n = new Map; let r; walk$3(t, { visit: "Declaration", enter(e, t) { null == r && (r = t), n.set(e.property.toLowerCase(), t) } }), walk$3(a.rule, { visit: "Declaration", enter(a) { const o = a.property; attrsGroups.presentation.has(o) && !s.some((e => includesAttrSelector(e.item, o))) && delete e.attributes[o]; const i = n.get(o), l = t.children.createItem(a); null == i ? t.children.insert(l, r) : !0 !== i.data.important && !0 === a.important && (t.children.replace(i, l), n.set(o, l)) } }); const o = generate$I(t); 0 !== o.length && (e.attributes.style = o) } r && 0 !== o.length && "SelectorList" === a.rule.prelude.type && a.rule.prelude.children.remove(a.item), a.matchedElements = o } } if (r) { for (const e of t) if (null != e.matchedElements && !(n && e.matchedElements.length > 1)) for (const t of e.matchedElements) { const n = new Set(null == t.attributes.class ? null : t.attributes.class.split(" ")); for (const t of e.node.children) "ClassSelector" !== t.type || s.some((e => includesAttrSelector(e.item, "class", t.name, !0))) || n.delete(t.name); 0 === n.size ? delete t.attributes.class : t.attributes.class = Array.from(n).join(" "); const r = e.node.children.first; "IdSelector" !== r?.type || t.attributes.id !== r.name || s.some((e => includesAttrSelector(e.item, "id", r.name, !0))) || delete t.attributes.id } for (const e of i) if (walk$3(e.cssAst, { visit: "Rule", enter: function (e, t, n) { "Rule" === e.type && "SelectorList" === e.prelude.type && e.prelude.children.isEmpty && n.remove(t) } }), e.cssAst.children.isEmpty) detachNodeFromParent(e.node, e.parentNode); else { const t = e.node.children[0]; "text" !== t.type && "cdata" !== t.type || (t.value = generate$I(e.cssAst)) } } } } } }; var inlineStyles = Object.freeze({ __proto__: null, description: description$I, fn: fn$I, name: name$I }); const regReferencesUrl = /\burl\((["'])?#(.+?)\1\)/g, regReferencesHref = /^#(.+?)$/, regReferencesBegin = /(\w+)\.[a-zA-Z]/, encodeSVGDatauri = (e, t) => { let n = "data:image/svg+xml"; return t && "base64" !== t ? "enc" === t ? e = n + "," + encodeURIComponent(e) : "unenc" === t && (e = n + "," + e) : (n += ";base64,", e = n + Buffer.from(e).toString("base64")), e }, cleanupOutData = (e, t, n) => { let r, a, o = ""; return e.forEach(((e, n) => { r = " ", 0 == n && (r = ""), t.noSpaceAfterFlags; const i = t.leadingZero ? removeLeadingZero(e) : e.toString(); t.negativeExtraSpace && "" != r && (e < 0 || "." === i.charAt(0) && a % 1 != 0) && (r = ""), a = e, o += r + i })), o }, removeLeadingZero = e => { const t = e.toString(); return 0 < e && e < 1 && t.startsWith("0") ? t.slice(1) : -1 < e && e < 0 && "0" === t[1] ? t[0] + t.slice(2) : t }, hasScripts = e => { if ("script" === e.name && 0 !== e.children.length) return !0; if ("a" === e.name) { if (Object.entries(e.attributes).some((([e, t]) => ("href" === e || e.endsWith(":href")) && null != t && t.trimStart().startsWith("javascript:")))) return !0 } return [...attrsGroups.animationEvent, ...attrsGroups.documentEvent, ...attrsGroups.documentElementEvent, ...attrsGroups.globalEvent, ...attrsGroups.graphicalEvent].some((t => null != e.attributes[t])) }, includesUrlReference = e => new RegExp(regReferencesUrl).test(e), findReferences = (e, t) => { const n = []; if (referencesProps.has(e)) { const e = t.matchAll(regReferencesUrl); for (const t of e) n.push(t[2]) } if ("href" === e || e.endsWith(":href")) { const e = regReferencesHref.exec(t); null != e && n.push(e[1]) } if ("begin" === e) { const e = regReferencesBegin.exec(t); null != e && n.push(e[1]) } return n.map((e => decodeURI(e))) }, toFixed = (e, t) => { const n = 10 ** t; return Math.round(e * n) / n }, name$H = "minifyStyles", description$H = "minifies styles and removes unused styles", fn$H = (e, { usage: t, ...n }) => { const r = new Map, a = [], o = new Set, i = new Set, s = new Set; let l = !0, c = !0, u = !0, d = !1; "boolean" == typeof t ? (l = t, c = t, u = t) : t && (l = null == t.tags || t.tags, c = null == t.ids || t.ids, u = null == t.classes || t.classes, d = null != t.force && t.force); let p = !1; return { element: { enter: (e, t) => { if (hasScripts(e) && (p = !0), o.add(e.name), null != e.attributes.id && i.add(e.attributes.id), null != e.attributes.class) for (const t of e.attributes.class.split(/\s+/)) s.add(t); "style" === e.name && 0 !== e.children.length ? r.set(e, t) : null != e.attributes.style && a.push(e) } }, root: { exit: () => { const e = {}; p && !d || (l && (e.tags = Array.from(o)), c && (e.ids = Array.from(i)), u && (e.classes = Array.from(s))); for (const [t, a] of r.entries()) if ("text" === t.children[0].type || "cdata" === t.children[0].type) { const r = t.children[0].value, o = minifyStylesheet(r, { ...n, usage: e }).css; if (0 === o.length) { detachNodeFromParent(t, a); continue } r.indexOf(">") >= 0 || r.indexOf("<") >= 0 ? (t.children[0].type = "cdata", t.children[0].value = o) : (t.children[0].type = "text", t.children[0].value = o) } for (const e of a) { const t = e.attributes.style; e.attributes.style = minifyBlock(t, { ...n }).css } } } } }; var minifyStyles = Object.freeze({ __proto__: null, description: description$H, fn: fn$H, name: name$H }); const name$G = "cleanupIds", description$G = "removes unused IDs and minifies used", generateIdChars = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], maxIdIndex = generateIdChars.length - 1, hasStringPrefix = (e, t) => { for (const n of t) if (e.startsWith(n)) return !0; return !1 }, generateId = e => { if (null == e) return [0]; e[e.length - 1] += 1; for (let t = e.length - 1; t > 0; t--)e[t] > maxIdIndex && (e[t] = 0, void 0 !== e[t - 1] && e[t - 1]++); return e[0] > maxIdIndex && (e[0] = 0, e.unshift(0)), e }, getIdString = e => e.map((e => generateIdChars[e])).join(""), fn$G = (e, t) => { const { remove: n = !0, minify: r = !0, preserve: a = [], preservePrefixes: o = [], force: i = !1 } = t, s = new Set(Array.isArray(a) ? a : a ? [a] : []), l = Array.isArray(o) ? o : o ? [o] : [], c = new Map, u = new Map; let d = !1; return { element: { enter: e => { if (!i) { if ("style" === e.name && 0 !== e.children.length || hasScripts(e)) return void (d = !0); if ("svg" === e.name) { let t = !0; for (const n of e.children) if ("element" !== n.type || "defs" !== n.name) { t = !1; break } if (t) return visitSkip } } for (const [t, n] of Object.entries(e.attributes)) if ("id" === t) { const t = n; c.has(t) ? delete e.attributes.id : c.set(t, e) } else { const r = findReferences(t, n); for (const n of r) { let r = u.get(n); null == r && (r = [], u.set(n, r)), r.push({ element: e, name: t }) } } } }, root: { exit: () => { if (d) return; const e = e => s.has(e) || hasStringPrefix(e, l); let t = null; for (const [n, a] of u) { const o = c.get(n); if (null != o) { if (r && !1 === e(n)) { let r; do { t = generateId(t), r = t.map((e => generateIdChars[e])).join("") } while (e(r) || u.has(r) && null == c.get(r)); o.attributes.id = r; for (const { element: e, name: t } of a) { const a = e.attributes[t]; a.includes("#") ? e.attributes[t] = a.replace(`#${encodeURI(n)}`, `#${r}`).replace(`#${n}`, `#${r}`) : e.attributes[t] = a.replace(`${n}.`, `${r}.`) } } c.delete(n) } } if (n) for (const [t, n] of c) !1 === e(t) && delete n.attributes.id } } } }; var cleanupIds = Object.freeze({ __proto__: null, description: description$G, fn: fn$G, name: name$G }); const name$F = "removeUselessDefs", description$F = "removes elements in <defs> without id", fn$F = () => ({ element: { enter: (e, t) => { if ("defs" === e.name || elemsGroups.nonRendering.has(e.name) && null == e.attributes.id) { const n = []; collectUsefulNodes(e, n), 0 === n.length && detachNodeFromParent(e, t), e.children = n } } } }), collectUsefulNodes = (e, t) => { for (const n of e.children) "element" === n.type && (null != n.attributes.id || "style" === n.name ? t.push(n) : collectUsefulNodes(n, t)) }; var removeUselessDefs = Object.freeze({ __proto__: null, description: description$F, fn: fn$F, name: name$F }); const name$E = "cleanupNumericValues", description$E = 'rounds numeric values to the fixed precision, removes default "px" units', regNumericValues$3 = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/, absoluteLengths$1 = { cm: 96 / 2.54, mm: 96 / 25.4, in: 96, pt: 4 / 3, pc: 16, px: 1 }, fn$E = (e, t) => { const { floatPrecision: n = 3, leadingZero: r = !0, defaultPx: a = !0, convertToPx: o = !0 } = t; return { element: { enter: e => { if (null != e.attributes.viewBox) { const t = e.attributes.viewBox.trim().split(/(?:\s,?|,)\s*/g); e.attributes.viewBox = t.map((e => { const t = Number(e); return Number.isNaN(t) ? e : Number(t.toFixed(n)) })).join(" ") } for (const [t, i] of Object.entries(e.attributes)) { if ("version" === t) continue; const s = regNumericValues$3.exec(i); if (s) { let i = Number(Number(s[1]).toFixed(n)); let l, c = s[3] || ""; if (o && "" !== c && c in absoluteLengths$1) { const e = Number((absoluteLengths$1[c] * Number(s[1])).toFixed(n)); e.toString().length < s[0].length && (i = e, c = "px") } l = r ? removeLeadingZero(i) : i.toString(), a && "px" === c && (c = ""), e.attributes[t] = l + c } } } } } }; var cleanupNumericValues = Object.freeze({ __proto__: null, description: description$E, fn: fn$E, name: name$E }); const name$D = "convertColors", description$D = "converts colors: rgb() to #rrggbb and #rrggbb to #rgb", rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)", rComma = "(?:\\s*,\\s*|\\s+)", regRGB = new RegExp("^rgb\\(\\s*" + rNumber + rComma + rNumber + rComma + rNumber + "\\s*\\)$"), regHEX = /^#(([a-fA-F0-9])\2){3}$/, convertRgbToHex = ([e, t, n]) => "#" + ((256 + e << 8 | t) << 8 | n).toString(16).slice(1).toUpperCase(), fn$D = (e, t) => { const { currentColor: n = !1, names2hex: r = !0, rgb2hex: a = !0, convertCase: o = "lower", shorthex: i = !0, shortname: s = !0 } = t; let l = 0; return { element: { enter: e => { "mask" === e.name && l++; for (const [t, c] of Object.entries(e.attributes)) if (colorsProps.has(t)) { let u = c; if (n && 0 === l) { let e; e = "string" == typeof n ? u === n : n instanceof RegExp ? null != n.exec(u) : "none" !== u, e && (u = "currentColor") } if (r) { const e = u.toLowerCase(); null != colorsNames[e] && (u = colorsNames[e]) } if (a) { const e = u.match(regRGB); if (null != e) { const t = e.slice(1, 4).map((e => { let t; return t = e.indexOf("%") > -1 ? Math.round(2.55 * parseFloat(e)) : Number(e), Math.max(0, Math.min(t, 255)) })); u = convertRgbToHex(t) } } if (o && !includesUrlReference(u) && "currentColor" !== u && ("lower" === o ? u = u.toLowerCase() : "upper" === o && (u = u.toUpperCase())), i) { const e = regHEX.exec(u); null != e && (u = "#" + e[0][1] + e[0][3] + e[0][5]) } if (s) { const e = u.toLowerCase(); null != colorsShortNames[e] && (u = colorsShortNames[e]) } e.attributes[t] = u } }, exit: e => { "mask" === e.name && l-- } } } }; var convertColors = Object.freeze({ __proto__: null, description: description$D, fn: fn$D, name: name$D }); const name$C = "removeUnknownsAndDefaults", description$C = "removes unknown elements content and attributes, removes attrs with default values", allowedChildrenPerElement = new Map, allowedAttributesPerElement = new Map, attributesDefaultsPerElement = new Map; for (const [e, t] of Object.entries(elems)) { const n = new Set; if (t.content) for (const e of t.content) n.add(e); if (t.contentGroups) for (const e of t.contentGroups) { const t = elemsGroups[e]; if (t) for (const e of t) n.add(e) } const r = new Set; if (t.attrs) for (const e of t.attrs) r.add(e); const a = new Map; if (t.defaults) for (const [e, n] of Object.entries(t.defaults)) a.set(e, n); for (const e of t.attrsGroups) { const t = attrsGroups[e]; if (t) for (const e of t) r.add(e); const n = attrsGroupsDefaults[e]; if (n) for (const [e, t] of Object.entries(n)) a.set(e, t) } allowedChildrenPerElement.set(e, n), allowedAttributesPerElement.set(e, r), attributesDefaultsPerElement.set(e, a) } const fn$C = (e, t) => { const { unknownContent: n = !0, unknownAttrs: r = !0, defaultAttrs: a = !0, defaultMarkupDeclarations: o = !0, uselessOverrides: i = !0, keepDataAttrs: s = !0, keepAriaAttrs: l = !0, keepRoleAttr: c = !1 } = t, u = collectStylesheet(e); return { instruction: { enter: e => { o && (e.value = e.value.replace(/\s*standalone\s*=\s*(["'])no\1/, "")) } }, element: { enter: (e, t) => { if (e.name.includes(":")) return; if ("foreignObject" === e.name) return visitSkip; if (n && "element" === t.type) { const n = allowedChildrenPerElement.get(t.name); if (null == n || 0 === n.size) { if (null == allowedChildrenPerElement.get(e.name)) return void detachNodeFromParent(e, t) } else if (!1 === n.has(e.name)) return void detachNodeFromParent(e, t) } const o = allowedAttributesPerElement.get(e.name), d = attributesDefaultsPerElement.get(e.name), p = "element" === t.type ? computeStyle(u, t) : null; for (const [t, n] of Object.entries(e.attributes)) if (!(s && t.startsWith("data-") || l && t.startsWith("aria-") || c && "role" === t || "xmlns" === t)) { if (t.includes(":")) { const [e] = t.split(":"); if ("xml" !== e && "xlink" !== e) continue } if (r && o && !1 === o.has(t) && delete e.attributes[t], a && null == e.attributes.id && d && d.get(t) === n && null == p?.[t] && delete e.attributes[t], i && null == e.attributes.id) { const r = p?.[t]; !1 === presentationNonInheritableGroupAttrs.has(t) && null != r && "static" === r.type && r.value === n && delete e.attributes[t] } } } } } }; var removeUnknownsAndDefaults = Object.freeze({ __proto__: null, description: description$C, fn: fn$C, name: name$C }); const name$B = "removeNonInheritableGroupAttrs", description$B = "removes non-inheritable group's presentational attributes", fn$B = () => ({ element: { enter: e => { if ("g" === e.name) for (const t of Object.keys(e.attributes)) !attrsGroups.presentation.has(t) || inheritableAttrs.has(t) || presentationNonInheritableGroupAttrs.has(t) || delete e.attributes[t] } } }); var removeNonInheritableGroupAttrs = Object.freeze({ __proto__: null, description: description$B, fn: fn$B, name: name$B }); const name$A = "removeUselessStrokeAndFill", description$A = "removes useless stroke and fill attributes", fn$A = (e, t) => { const { stroke: n = !0, fill: r = !0, removeNone: a = !1 } = t; let o = !1; if (visit(e, { element: { enter: e => { ("style" === e.name || hasScripts(e)) && (o = !0) } } }), o) return null; const i = collectStylesheet(e); return { element: { enter: (e, t) => { if (null != e.attributes.id) return visitSkip; if (!elemsGroups.shape.has(e.name)) return; const o = computeStyle(i, e), s = o.stroke, l = o["stroke-opacity"], c = o["stroke-width"], u = o["marker-end"], d = o.fill, p = o["fill-opacity"], h = "element" === t.type ? computeStyle(i, t) : null, m = null == h ? null : h.stroke; if (n && (null == s || "static" === s.type && "none" == s.value || null != l && "static" === l.type && "0" === l.value || null != c && "static" === c.type && "0" === c.value) && (null != c && "static" === c.type && "0" === c.value || null == u)) { for (const t of Object.keys(e.attributes)) t.startsWith("stroke") && delete e.attributes[t]; null != m && "static" === m.type && "none" !== m.value && (e.attributes.stroke = "none") } if (r && (null != d && "static" === d.type && "none" === d.value || null != p && "static" === p.type && "0" === p.value)) { for (const t of Object.keys(e.attributes)) t.startsWith("fill-") && delete e.attributes[t]; (null == d || "static" === d.type && "none" !== d.value) && (e.attributes.fill = "none") } a && (null != s && "none" !== e.attributes.stroke || (null == d || "static" !== d.type || "none" !== d.value) && "none" !== e.attributes.fill || detachNodeFromParent(e, t)) } } } }; var removeUselessStrokeAndFill = Object.freeze({ __proto__: null, description: description$A, fn: fn$A, name: name$A }); const name$z = "cleanupEnableBackground", description$z = "remove or cleanup enable-background attribute when possible", regEnableBackground = /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/, fn$z = e => { let t = !1; return visit(e, { element: { enter: e => { "filter" === e.name && (t = !0) } } }), { element: { enter: e => { let n = null, r = null; if (null != e.attributes.style && (n = parse$I(e.attributes.style, { context: "declarationList" }), "DeclarationList" === n.type)) { const e = []; walk$3(n, ((t, n) => { "Declaration" === t.type && "enable-background" === t.property && (e.push(n), r = n) })); for (let t = 0; t < e.length - 1; t++)n.children.remove(e[t]) } if (!t) return delete e.attributes["enable-background"], void ("DeclarationList" === n?.type && (r && n.children.remove(r), n.children.isEmpty ? delete e.attributes.style : e.attributes.style = generate$I(n))); const a = null != e.attributes.width && null != e.attributes.height; if (("svg" === e.name || "mask" === e.name || "pattern" === e.name) && a) { const t = e.attributes["enable-background"], a = cleanupValue(t, e.name, e.attributes.width, e.attributes.height); if (a ? e.attributes["enable-background"] = a : delete e.attributes["enable-background"], "DeclarationList" === n?.type && r) { const t = generate$I(r.data.value), a = cleanupValue(t, e.name, e.attributes.width, e.attributes.height); a ? r.data.value = { type: "Raw", value: a } : n.children.remove(r) } } "DeclarationList" === n?.type && (n.children.isEmpty ? delete e.attributes.style : e.attributes.style = generate$I(n)) } } } }, cleanupValue = (e, t, n, r) => { const a = regEnableBackground.exec(e); return null != a && n === a[1] && r === a[3] ? "svg" === t ? void 0 : "new" : e }; var cleanupEnableBackground = Object.freeze({ __proto__: null, description: description$z, fn: fn$z, name: name$z }); const argsCountPerCommand = { M: 2, m: 2, Z: 0, z: 0, L: 2, l: 2, H: 1, h: 1, V: 1, v: 1, C: 6, c: 6, S: 4, s: 4, Q: 4, q: 4, T: 2, t: 2, A: 7, a: 7 }, isCommand = e => e in argsCountPerCommand, isWhiteSpace = e => " " === e || "\t" === e || "\r" === e || "\n" === e, isDigit = e => { const t = e.codePointAt(0); return null != t && (48 <= t && t <= 57) }, readNumber = (e, t) => { let n = t, r = "", a = "none"; for (; n < e.length; n += 1) { const t = e[n]; if ("+" === t || "-" === t) { if ("none" === a) { a = "sign", r += t; continue } if ("e" === a) { a = "exponent_sign", r += t; continue } } if (isDigit(t)) { if ("none" === a || "sign" === a || "whole" === a) { a = "whole", r += t; continue } if ("decimal_point" === a || "decimal" === a) { a = "decimal", r += t; continue } if ("e" === a || "exponent_sign" === a || "exponent" === a) { a = "exponent", r += t; continue } } if ("." !== t || "none" !== a && "sign" !== a && "whole" !== a) { if ("E" !== t && "e" != t || "whole" !== a && "decimal_point" !== a && "decimal" !== a) break; a = "e", r += t } else a = "decimal_point", r += t } const o = Number.parseFloat(r); return Number.isNaN(o) ? [t, null] : [n - 1, o] }, parsePathData = e => { const t = []; let n = null, r = [], a = 0, o = !1, i = !1; for (let s = 0; s < e.length; s += 1) { const l = e.charAt(s); if (isWhiteSpace(l)) continue; if (o && "," === l) { if (i) break; i = !0; continue } if (isCommand(l)) { if (i) return t; if (null == n) { if ("M" !== l && "m" !== l) return t } else if (0 !== r.length) return t; n = l, r = [], a = argsCountPerCommand[n], o = !1, 0 === a && t.push({ command: n, args: r }); continue } if (null == n) return t; let c = s, u = null; if ("A" === n || "a" === n) { const t = r.length; 0 !== t && 1 !== t || "+" !== l && "-" !== l && ([c, u] = readNumber(e, s)), 2 !== t && 5 !== t && 6 !== t || ([c, u] = readNumber(e, s)), 3 !== t && 4 !== t || ("0" === l && (u = 0), "1" === l && (u = 1)) } else[c, u] = readNumber(e, s); if (null == u) return t; r.push(u), o = !0, i = !1, s = c, r.length === a && (t.push({ command: n, args: r }), "M" === n && (n = "L"), "m" === n && (n = "l"), r = []) } return t }, roundAndStringify = (e, t) => (null != t && (e = toFixed(e, t)), { roundedStr: removeLeadingZero(e), rounded: e }), stringifyArgs = (e, t, n, r) => { let a, o = ""; for (let i = 0; i < t.length; i++) { const { roundedStr: s, rounded: l } = roundAndStringify(t[i], n); !r || "A" !== e && "a" !== e || i % 7 != 4 && i % 7 != 5 ? 0 === i || l < 0 ? o += s : Number.isInteger(a) || isDigit(s[0]) ? o += ` ${s}` : o += s : o += s, a = l } return o }, stringifyPathData = ({ pathData: e, precision: t, disableSpaceAfterFlags: n }) => { if (1 === e.length) { const { command: r, args: a } = e[0]; return r + stringifyArgs(r, a, t, n) } let r = "", a = { ...e[0] }; "L" === e[1].command ? a.command = "M" : "l" === e[1].command && (a.command = "m"); for (let o = 1; o < e.length; o++) { const { command: i, args: s } = e[o]; a.command === i && "M" !== a.command && "m" !== a.command || "M" === a.command && "L" === i || "m" === a.command && "l" === i ? (a.args = [...a.args, ...s], o === e.length - 1 && (r += a.command + stringifyArgs(a.command, a.args, t, n))) : (r += a.command + stringifyArgs(a.command, a.args, t, n), o === e.length - 1 ? r += i + stringifyArgs(i, s, t, n) : a = { command: i, args: s }) } return r }, nonRendering = elemsGroups.nonRendering, name$y = "removeHiddenElems", description$y = "removes hidden elements (zero sized, with absent attributes)", fn$y = (e, t) => { const { isHidden: n = !0, displayNone: r = !0, opacity0: a = !0, circleR0: o = !0, ellipseRX0: i = !0, ellipseRY0: s = !0, rectWidth0: l = !0, rectHeight0: c = !0, patternWidth0: u = !0, patternHeight0: d = !0, imageWidth0: p = !0, imageHeight0: h = !0, pathEmptyD: m = !0, polylineEmptyPoints: f = !0, polygonEmptyPoints: g = !0 } = t, b = collectStylesheet(e), y = new Map, $ = new Set, k = new Map, S = new Set, v = new Map; let w = !1; function x(e) { if (S.has(e.attributes.id)) return !1; for (const t of e.children) if ("element" === t.type && !x(t)) return !1; return !0 } function C(e, t) { "element" === e.type && null != e.attributes.id && "element" === t.type && "defs" === t.name && $.add(e.attributes.id), detachNodeFromParent(e, t) } return visit(e, { element: { enter: (e, t) => { if (nonRendering.has(e.name)) return y.set(e, t), visitSkip; const n = computeStyle(b, e); if (a && n.opacity && "static" === n.opacity.type && "0" === n.opacity.value) { if ("path" === e.name) return y.set(e, t), visitSkip; C(e, t) } } } }), { element: { enter: (e, t) => { if ("style" === e.name && 0 !== e.children.length || hasScripts(e)) return void (w = !0); if ("defs" === e.name && k.set(e, t), "use" === e.name) for (const n of Object.keys(e.attributes)) { if ("href" !== n && !n.endsWith(":href")) continue; const r = e.attributes[n].slice(1); let a = v.get(r); a || (a = [], v.set(r, a)), a.push({ node: e, parentNode: t }) } const a = computeStyle(b, e); if (n && a.visibility && "static" === a.visibility.type && "hidden" === a.visibility.value && null == querySelector(e, "[visibility=visible]")) C(e, t); else if (r && a.display && "static" === a.display.type && "none" === a.display.value && "marker" !== e.name) C(e, t); else if (o && "circle" === e.name && 0 === e.children.length && "0" === e.attributes.r) C(e, t); else if (i && "ellipse" === e.name && 0 === e.children.length && "0" === e.attributes.rx) C(e, t); else if (s && "ellipse" === e.name && 0 === e.children.length && "0" === e.attributes.ry) C(e, t); else if (l && "rect" === e.name && 0 === e.children.length && "0" === e.attributes.width) C(e, t); else if (c && l && "rect" === e.name && 0 === e.children.length && "0" === e.attributes.height) C(e, t); else if (u && "pattern" === e.name && "0" === e.attributes.width) C(e, t); else if (d && "pattern" === e.name && "0" === e.attributes.height) C(e, t); else if (p && "image" === e.name && "0" === e.attributes.width) C(e, t); else if (h && "image" === e.name && "0" === e.attributes.height) C(e, t); else { if (m && "path" === e.name) { if (null == e.attributes.d) return void C(e, t); const n = parsePathData(e.attributes.d); if (0 === n.length) return void C(e, t); if (1 === n.length && null == a["marker-start"] && null == a["marker-end"]) return void C(e, t) } if (f && "polyline" === e.name && null == e.attributes.points) C(e, t); else if (g && "polygon" === e.name && null == e.attributes.points) C(e, t); else for (const [t, n] of Object.entries(e.attributes)) { const e = findReferences(t, n); for (const t of e) S.add(t) } } } }, root: { exit: () => { for (const e of $) { const t = v.get(e); if (t) for (const { node: e, parentNode: n } of t) detachNodeFromParent(e, n) } if (!w) for (const [e, t] of y.entries()) x(e) && detachNodeFromParent(e, t); for (const [e, t] of k.entries()) 0 === e.children.length && detachNodeFromParent(e, t) } } } }; var removeHiddenElems = Object.freeze({ __proto__: null, description: description$y, fn: fn$y, name: name$y }); const name$x = "removeEmptyText", description$x = "removes empty <text> elements", fn$x = (e, t) => { const { text: n = !0, tspan: r = !0, tref: a = !0 } = t; return { element: { enter: (e, t) => { n && "text" === e.name && 0 === e.children.length && detachNodeFromParent(e, t), r && "tspan" === e.name && 0 === e.children.length && detachNodeFromParent(e, t), a && "tref" === e.name && null == e.attributes["xlink:href"] && detachNodeFromParent(e, t) } } } }; var removeEmptyText = Object.freeze({ __proto__: null, description: description$x, fn: fn$x, name: name$x }); const name$w = "convertShapeToPath", description$w = "converts basic shapes to more compact path form", regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g, fn$w = (e, t) => { const { convertArcs: n = !1, floatPrecision: r } = t; return { element: { enter: (e, t) => { if ("rect" === e.name && null != e.attributes.width && null != e.attributes.height && null == e.attributes.rx && null == e.attributes.ry) { const t = Number(e.attributes.x || "0"), n = Number(e.attributes.y || "0"), a = Number(e.attributes.width), o = Number(e.attributes.height); if (Number.isNaN(t - n + a - o)) return; const i = [{ command: "M", args: [t, n] }, { command: "H", args: [t + a] }, { command: "V", args: [n + o] }, { command: "H", args: [t] }, { command: "z", args: [] }]; e.name = "path", e.attributes.d = stringifyPathData({ pathData: i, precision: r }), delete e.attributes.x, delete e.attributes.y, delete e.attributes.width, delete e.attributes.height } if ("line" === e.name) { const t = Number(e.attributes.x1 || "0"), n = Number(e.attributes.y1 || "0"), a = Number(e.attributes.x2 || "0"), o = Number(e.attributes.y2 || "0"); if (Number.isNaN(t - n + a - o)) return; const i = [{ command: "M", args: [t, n] }, { command: "L", args: [a, o] }]; e.name = "path", e.attributes.d = stringifyPathData({ pathData: i, precision: r }), delete e.attributes.x1, delete e.attributes.y1, delete e.attributes.x2, delete e.attributes.y2 } if (("polyline" === e.name || "polygon" === e.name) && null != e.attributes.points) { const n = (e.attributes.points.match(regNumber) || []).map(Number); if (n.length < 4) return void detachNodeFromParent(e, t); const a = []; for (let e = 0; e < n.length; e += 2)a.push({ command: 0 === e ? "M" : "L", args: n.slice(e, e + 2) }); "polygon" === e.name && a.push({ command: "z", args: [] }), e.name = "path", e.attributes.d = stringifyPathData({ pathData: a, precision: r }), delete e.attributes.points } if ("circle" === e.name && n) { const t = Number(e.attributes.cx || "0"), n = Number(e.attributes.cy || "0"), a = Number(e.attributes.r || "0"); if (Number.isNaN(t - n + a)) return; const o = [{ command: "M", args: [t, n - a] }, { command: "A", args: [a, a, 0, 1, 0, t, n + a] }, { command: "A", args: [a, a, 0, 1, 0, t, n - a] }, { command: "z", args: [] }]; e.name = "path", e.attributes.d = stringifyPathData({ pathData: o, precision: r }), delete e.attributes.cx, delete e.attributes.cy, delete e.attributes.r } if ("ellipse" === e.name && n) { const t = Number(e.attributes.cx || "0"), n = Number(e.attributes.cy || "0"), a = Number(e.attributes.rx || "0"), o = Number(e.attributes.ry || "0"); if (Number.isNaN(t - n + a - o)) return; const i = [{ command: "M", args: [t, n - o] }, { command: "A", args: [a, o, 0, 1, 0, t, n + o] }, { command: "A", args: [a, o, 0, 1, 0, t, n - o] }, { command: "z", args: [] }]; e.name = "path", e.attributes.d = stringifyPathData({ pathData: i, precision: r }), delete e.attributes.cx, delete e.attributes.cy, delete e.attributes.rx, delete e.attributes.ry } } } } }; var convertShapeToPath = Object.freeze({ __proto__: null, description: description$w, fn: fn$w, name: name$w }); const name$v = "convertEllipseToCircle", description$v = "converts non-eccentric <ellipse>s to <circle>s", fn$v = () => ({ element: { enter: e => { if ("ellipse" === e.name) { const t = e.attributes.rx || "0", n = e.attributes.ry || "0"; if (t === n || "auto" === t || "auto" === n) { e.name = "circle"; const r = "auto" === t ? n : t; delete e.attributes.rx, delete e.attributes.ry, e.attributes.r = r } } } } }); var convertEllipseToCircle = Object.freeze({ __proto__: null, description: description$v, fn: fn$v, name: name$v }); const name$u = "moveElemsAttrsToGroup", description$u = "Move common attributes of group children to the group", fn$u = e => { let t = !1; return visit(e, { element: { enter: e => { "style" === e.name && (t = !0) } } }), { element: { exit: e => { if ("g" !== e.name || e.children.length <= 1) return; if (t) return; const n = new Map; let r = !0, a = !0; for (const t of e.children) if ("element" === t.type) if (pathElems.has(t.name) || (a = !1), r) { r = !1; for (const [e, r] of Object.entries(t.attributes)) inheritableAttrs.has(e) && n.set(e, r) } else for (const [e, r] of n) t.attributes[e] !== r && n.delete(e); null == e.attributes.filter && null == e.attributes["clip-path"] && null == e.attributes.mask || n.delete("transform"), a && n.delete("transform"); for (const [t, r] of n) "transform" === t ? null != e.attributes.transform ? e.attributes.transform = `${e.attributes.transform} ${r}` : e.attributes.transform = r : e.attributes[t] = r; for (const t of e.children) if ("element" === t.type) for (const [e] of n) delete t.attributes[e] } } } }; var moveElemsAttrsToGroup = Object.freeze({ __proto__: null, description: description$u, fn: fn$u, name: name$u }); const name$t = "moveGroupAttrsToElems", description$t = "moves some group attributes to the content elements", pathElemsWithGroupsAndText = [...pathElems, "g", "text"], fn$t = () => ({ element: { enter: e => { if ("g" === e.name && 0 !== e.children.length && null != e.attributes.transform && !1 === Object.entries(e.attributes).some((([e, t]) => referencesProps.has(e) && includesUrlReference(t))) && e.children.every((e => "element" === e.type && pathElemsWithGroupsAndText.includes(e.name) && null == e.attributes.id))) { for (const t of e.children) { const n = e.attributes.transform; "element" === t.type && (null != t.attributes.transform ? t.attributes.transform = `${n} ${t.attributes.transform}` : t.attributes.transform = n) } delete e.attributes.transform } } } }); var moveGroupAttrsToElems = Object.freeze({ __proto__: null, description: description$t, fn: fn$t, name: name$t }); const name$s = "collapseGroups", description$s = "collapses useless groups", hasAnimatedAttr = (e, t) => { if ("element" === e.type) { if (elemsGroups.animation.has(e.name) && e.attributes.attributeName === t) return !0; for (const n of e.children) if (hasAnimatedAttr(n, t)) return !0 } return !1 }, fn$s = e => { const t = collectStylesheet(e); return { element: { exit: (e, n) => { if ("root" !== n.type && "switch" !== n.name && "g" === e.name && 0 !== e.children.length) { if (0 !== Object.keys(e.attributes).length && 1 === e.children.length) { const n = e.children[0], r = !(!e.attributes.filter && !computeStyle(t, e).filter); if ("element" === n.type && null == n.attributes.id && !r && (null == e.attributes.class || null == n.attributes.class) && (null == e.attributes["clip-path"] && null == e.attributes.mask || "g" === n.name && null == e.attributes.transform && null == n.attributes.transform)) { const t = { ...n.attributes }; for (const [r, a] of Object.entries(e.attributes)) { if (hasAnimatedAttr(n, r)) return; if (null == t[r]) t[r] = a; else if ("transform" === r) t[r] = a + " " + t[r]; else if ("inherit" === t[r]) t[r] = a; else if (!inheritableAttrs.has(r) && t[r] !== a) return } e.attributes = {}, n.attributes = t } } if (0 === Object.keys(e.attributes).length) { for (const t of e.children) if ("element" === t.type && elemsGroups.animation.has(t.name)) return; const t = n.children.indexOf(e); n.children.splice(t, 1, ...e.children) } } } } } }; var collapseGroups = Object.freeze({ __proto__: null, description: description$s, fn: fn$s, name: name$s }); let prevCtrlPoint; const path2js = e => { if (e.pathJS) return e.pathJS; const t = [], n = parsePathData(e.attributes.d); for (const { command: e, args: r } of n) t.push({ command: e, args: r }); return t.length && "m" == t[0].command && (t[0].command = "M"), e.pathJS = t, t }, convertRelativeToAbsolute = e => { const t = [], n = [0, 0], r = [0, 0]; for (let { command: a, args: o } of e) o = o.slice(), "m" === a && (o[0] += r[0], o[1] += r[1], a = "M"), "M" === a && (r[0] = o[0], r[1] = o[1], n[0] = r[0], n[1] = r[1]), "h" === a && (o[0] += r[0], a = "H"), "H" === a && (r[0] = o[0]), "v" === a && (o[0] += r[1], a = "V"), "V" === a && (r[1] = o[0]), "l" === a && (o[0] += r[0], o[1] += r[1], a = "L"), "L" === a && (r[0] = o[0], r[1] = o[1]), "c" === a && (o[0] += r[0], o[1] += r[1], o[2] += r[0], o[3] += r[1], o[4] += r[0], o[5] += r[1], a = "C"), "C" === a && (r[0] = o[4], r[1] = o[5]), "s" === a && (o[0] += r[0], o[1] += r[1], o[2] += r[0], o[3] += r[1], a = "S"), "S" === a && (r[0] = o[2], r[1] = o[3]), "q" === a && (o[0] += r[0], o[1] += r[1], o[2] += r[0], o[3] += r[1], a = "Q"), "Q" === a && (r[0] = o[2], r[1] = o[3]), "t" === a && (o[0] += r[0], o[1] += r[1], a = "T"), "T" === a && (r[0] = o[0], r[1] = o[1]), "a" === a && (o[5] += r[0], o[6] += r[1], a = "A"), "A" === a && (r[0] = o[5], r[1] = o[6]), "z" !== a && "Z" !== a || (r[0] = n[0], r[1] = n[1], a = "z"), t.push({ command: a, args: o }); return t }, js2path = function (e, t, n) { e.pathJS = t; const r = []; for (const e of t) { if (0 !== r.length && ("M" === e.command || "m" === e.command)) { const e = r[r.length - 1]; "M" !== e.command && "m" !== e.command || r.pop() } r.push({ command: e.command, args: e.args }) } e.attributes.d = stringifyPathData({ pathData: r, precision: n.floatPrecision, disableSpaceAfterFlags: n.noSpaceAfterFlags }) }; function set(e, t) { return e[0] = t[t.length - 2], e[1] = t[t.length - 1], e } const intersects = function (e, t) { const n = gatherPoints(convertRelativeToAbsolute(e)), r = gatherPoints(convertRelativeToAbsolute(t)); if (n.maxX <= r.minX || r.maxX <= n.minX || n.maxY <= r.minY || r.maxY <= n.minY || n.list.every((e => r.list.every((t => e.list[e.maxX][0] <= t.list[t.minX][0] || t.list[t.maxX][0] <= e.list[e.minX][0] || e.list[e.maxY][1] <= t.list[t.minY][1] || t.list[t.maxY][1] <= e.list[e.minY][1]))))) return !1; const a = n.list.map(convexHull), o = r.list.map(convexHull); return a.some((function (e) { return !(e.list.length < 3) && o.some((function (t) { if (t.list.length < 3) return !1; const n = [i(e, t, [1, 0])], r = minus(n[0]); let a = 1e4; for (; ;) { if (0 == a--) return console.error("Error: infinite loop while processing mergePaths plugin."), !0; if (n.push(i(e, t, r)), dot(r, n[n.length - 1]) <= 0) return !1; if (processSimplex(n, r)) return !0 } })) })); function i(e, t, n) { return sub(s(e, n), s(t, minus(n))) } function s(e, t) { let n, r = t[1] >= 0 ? t[0] < 0 ? e.maxY : e.maxX : t[0] < 0 ? e.minX : e.minY, a = -1 / 0; for (; (n = dot(e.list[r], t)) > a;)a = n, r = ++r % e.list.length; return e.list[(r || e.list.length) - 1] } }; function processSimplex(e, t) { if (2 == e.length) { const n = e[1], r = e[0], a = minus(e[1]), o = sub(r, n); dot(a, o) > 0 ? set(t, orth(o, n)) : (set(t, a), e.shift()) } else { const n = e[2], r = e[1], a = e[0], o = sub(r, n), i = sub(a, n), s = minus(n), l = orth(o, i), c = orth(i, o); if (dot(l, s) > 0) dot(o, s) > 0 ? (set(t, l), e.shift()) : (set(t, s), e.splice(0, 2)); else { if (!(dot(c, s) > 0)) return !0; dot(i, s) > 0 ? (set(t, c), e.splice(1, 1)) : (set(t, s), e.splice(0, 2)) } } return !1 } function minus(e) { return [-e[0], -e[1]] } function sub(e, t) { return [e[0] - t[0], e[1] - t[1]] } function dot(e, t) { return e[0] * t[0] + e[1] * t[1] } function orth(e, t) { const n = [-e[1], e[0]]; return dot(n, minus(t)) < 0 ? minus(n) : n } function gatherPoints(e) { const t = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }, n = (e, n) => { (!e.list.length || n[1] > e.list[e.maxY][1]) && (e.maxY = e.list.length, t.maxY = t.list.length ? Math.max(n[1], t.maxY) : n[1]), (!e.list.length || n[0] > e.list[e.maxX][0]) && (e.maxX = e.list.length, t.maxX = t.list.length ? Math.max(n[0], t.maxX) : n[0]), (!e.list.length || n[1] < e.list[e.minY][1]) && (e.minY = e.list.length, t.minY = t.list.length ? Math.min(n[1], t.minY) : n[1]), (!e.list.length || n[0] < e.list[e.minX][0]) && (e.minX = e.list.length, t.minX = t.list.length ? Math.min(n[0], t.minX) : n[0]), e.list.push(n) }; for (let a = 0; a < e.length; a += 1) { const o = e[a]; let i = 0 === t.list.length ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 } : t.list[t.list.length - 1]; const s = 0 === a ? null : e[a - 1]; let l = 0 === i.list.length ? null : i.list[i.list.length - 1]; const c = o.args; let u = l; const d = (e, t) => e + (null == l ? 0 : l[t % 2]); switch (o.command) { case "M": i = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }, t.list.push(i); break; case "H": null != l && n(i, [c[0], l[1]]); break; case "V": null != l && n(i, [l[0], c[0]]); break; case "Q": n(i, c.slice(0, 2)), prevCtrlPoint = [c[2] - c[0], c[3] - c[1]]; break; case "T": null == l || null == s || "Q" != s.command && "T" != s.command || (u = [l[0] + prevCtrlPoint[0], l[1] + prevCtrlPoint[1]], n(i, u), prevCtrlPoint = [c[0] - u[0], c[1] - u[1]]); break; case "C": null != l && n(i, [.5 * (l[0] + c[0]), .5 * (l[1] + c[1])]), n(i, [.5 * (c[0] + c[2]), .5 * (c[1] + c[3])]), n(i, [.5 * (c[2] + c[4]), .5 * (c[3] + c[5])]), prevCtrlPoint = [c[4] - c[2], c[5] - c[3]]; break; case "S": null == l || null == s || "C" != s.command && "S" != s.command || (n(i, [l[0] + .5 * prevCtrlPoint[0], l[1] + .5 * prevCtrlPoint[1]]), u = [l[0] + prevCtrlPoint[0], l[1] + prevCtrlPoint[1]]), null != u && n(i, [.5 * (u[0] + c[0]), .5 * (u[1] + c[1])]), n(i, [.5 * (c[0] + c[2]), .5 * (c[1] + c[3])]), prevCtrlPoint = [c[2] - c[0], c[3] - c[1]]; break; case "A": if (null != l) { const e = a2c.apply(0, l.concat(c)); for (var r; (r = e.splice(0, 6).map(d)).length;)null != l && n(i, [.5 * (l[0] + r[0]), .5 * (l[1] + r[1])]), n(i, [.5 * (r[0] + r[2]), .5 * (r[1] + r[3])]), n(i, [.5 * (r[2] + r[4]), .5 * (r[3] + r[5])]), e.length && n(i, l = r.slice(-2)) } }c.length >= 2 && n(i, c.slice(-2)) } return t } function convexHull(e) { e.list.sort((function (e, t) { return e[0] == t[0] ? e[1] - t[1] : e[0] - t[0] })); const t = []; let n = 0, r = 0; for (let a = 0; a < e.list.length; a++) { for (; t.length >= 2 && cross(t[t.length - 2], t[t.length - 1], e.list[a]) <= 0;)t.pop(); e.list[a][1] < e.list[n][1] && (n = a, r = t.length), t.push(e.list[a]) } const a = []; let o = e.list.length - 1, i = 0; for (let t = e.list.length; t--;) { for (; a.length >= 2 && cross(a[a.length - 2], a[a.length - 1], e.list[t]) <= 0;)a.pop(); e.list[t][1] > e.list[o][1] && (o = t, i = a.length), a.push(e.list[t]) } a.pop(), t.pop(); const s = t.concat(a); return { list: s, minX: 0, maxX: t.length, minY: r, maxY: (t.length + i) % s.length } } function cross(e, t, n) { return (t[0] - e[0]) * (n[1] - e[1]) - (t[1] - e[1]) * (n[0] - e[0]) } const a2c = (e, t, n, r, a, o, i, s, l, c) => { const u = 120 * Math.PI / 180, d = Math.PI / 180 * (+a || 0); let p = []; const h = (e, t, n) => e * Math.cos(n) - t * Math.sin(n), m = (e, t, n) => e * Math.sin(n) + t * Math.cos(n); if (c) b = c[0], y = c[1], f = c[2], g = c[3]; else { t = m(e = h(e, t, -d), t, -d); const a = (e - (s = h(s, l, -d))) / 2, c = (t - (l = m(s, l, -d))) / 2; let u = a * a / (n * n) + c * c / (r * r); u > 1 && (u = Math.sqrt(u), n *= u, r *= u); const p = n * n, $ = r * r, k = (o == i ? -1 : 1) * Math.sqrt(Math.abs((p * $ - p * c * c - $ * a * a) / (p * c * c + $ * a * a))); var f = k * n * c / r + (e + s) / 2, g = k * -r * a / n + (t + l) / 2, b = Math.asin(Number(((t - g) / r).toFixed(9))), y = Math.asin(Number(((l - g) / r).toFixed(9))); b = e < f ? Math.PI - b : b, y = s < f ? Math.PI - y : y, b < 0 && (b = 2 * Math.PI + b), y < 0 && (y = 2 * Math.PI + y), i && b > y && (b -= 2 * Math.PI), !i && y > b && (y -= 2 * Math.PI) } let $ = y - b; if (Math.abs($) > u) { const e = y, t = s, o = l; y = b + u * (i && y > b ? 1 : -1), s = f + n * Math.cos(y), l = g + r * Math.sin(y), p = a2c(s, l, n, r, a, 0, i, t, o, [y, e, f, g]) } $ = y - b; const k = Math.cos(b), S = Math.sin(b), v = Math.cos(y), w = Math.sin(y), x = Math.tan($ / 4), C = 4 / 3 * n * x, A = 4 / 3 * r * x, T = [-C * S, A * k, s + C * w - e, l - A * v - t, s - e, l - t]; if (c) return T.concat(p); { p = T.concat(p); const e = []; for (let t = 0, n = p.length; t < n; t++)e[t] = t % 2 ? m(p[t - 1], p[t], d) : h(p[t], p[t + 1], d); return e } }, transformTypes = new Set(["matrix", "rotate", "scale", "skewX", "skewY", "translate"]), regTransformSplit = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/, regNumericValues$2 = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g, transform2js = e => { const t = []; let n = null; for (const r of e.split(regTransformSplit)) if (r) if (transformTypes.has(r)) n = { name: r, data: [] }, t.push(n); else { let e; for (; e = regNumericValues$2.exec(r);)e = Number(e), null != n && n.data.push(e) } return null == n || 0 == n.data.length ? [] : t }, transformsMultiply = e => { const t = e.map((e => "matrix" === e.name ? e.data : transformToMatrix(e))); return { name: "matrix", data: t.length > 0 ? t.reduce(multiplyTransformMatrices) : [] } }, mth = { rad: e => e * Math.PI / 180, deg: e => 180 * e / Math.PI, cos: e => Math.cos(mth.rad(e)), acos: (e, t) => toFixed(mth.deg(Math.acos(e)), t), sin: e => Math.sin(mth.rad(e)), asin: (e, t) => toFixed(mth.deg(Math.asin(e)), t), tan: e => Math.tan(mth.rad(e)), atan: (e, t) => toFixed(mth.deg(Math.atan(e)), t) }, getDecompositions = e => { const t = [], n = decomposeQRAB(e), r = decomposeQRCD(e); return n && t.push(n), r && t.push(r), t }, decomposeQRAB = e => { const t = e.data, [n, r, a, o, i, s] = t, l = n * o - r * a; if (0 === l) return; const c = Math.hypot(n, r); if (0 === c) return; const u = [], d = n / c; if ((i || s) && u.push({ name: "translate", data: [i, s] }), 1 !== d) { const e = Math.acos(d); u.push({ name: "rotate", data: [mth.deg(r < 0 ? -e : e), 0, 0] }) } const p = c, h = l / p; 1 === p && 1 === h || u.push({ name: "scale", data: [p, h] }); const m = n * a + r * o; return m && u.push({ name: "skewX", data: [mth.deg(Math.atan(m / (n * n + r * r)))] }), u }, decomposeQRCD = e => { const t = e.data, [n, r, a, o, i, s] = t, l = n * o - r * a; if (0 === l) return; const c = Math.hypot(a, o); if (0 === c) return; const u = []; (i || s) && u.push({ name: "translate", data: [i, s] }); const d = Math.PI / 2 - (o < 0 ? -1 : 1) * Math.acos(-a / c); u.push({ name: "rotate", data: [mth.deg(d), 0, 0] }); const p = l / c, h = c; 1 === p && 1 === h || u.push({ name: "scale", data: [p, h] }); const m = n * a + r * o; return m && u.push({ name: "skewY", data: [mth.deg(Math.atan(m / (a * a + o * o)))] }), u }, mergeTranslateAndRotate = (e, t, n) => { const r = mth.rad(n), a = 1 - Math.cos(r), o = Math.sin(r), i = (a * t + o * e) / (a * a + o * o); return { name: "rotate", data: [n, (e - o * i) / a, i] } }, isIdentityTransform = e => { switch (e.name) { case "rotate": case "skewX": case "skewY": return 0 === e.data[0]; case "scale": return 1 === e.data[0] && 1 === e.data[1]; case "translate": return 0 === e.data[0] && 0 === e.data[1] }return !1 }, optimize$1 = (e, t) => { const n = []; for (let r = 0; r < e.length; r++) { const a = e[r]; if (isIdentityTransform(a)) continue; const o = a.data; switch (a.name) { case "rotate": switch (o[0]) { case 180: case -180: { const t = e[r + 1]; t && "scale" === t.name ? (n.push(createScaleTransform(t.data.map((e => -e)))), r++) : n.push({ name: "scale", data: [-1] }) } continue }n.push({ name: "rotate", data: o.slice(0, o[1] || o[2] ? 3 : 1) }); break; case "scale": n.push(createScaleTransform(o)); break; case "skewX": case "skewY": n.push({ name: a.name, data: [o[0]] }); break; case "translate": { const a = e[r + 1]; if (a && "rotate" === a.name && 180 !== a.data[0] && -180 !== a.data[0] && 0 !== a.data[0] && 0 === a.data[1] && 0 === a.data[2]) { const e = t[r].data; n.push(mergeTranslateAndRotate(e[0], e[1], t[r + 1].data[0])), r++; continue } } n.push({ name: "translate", data: o.slice(0, o[1] ? 2 : 1) }) } } return n.length ? n : [{ name: "scale", data: [1] }] }, createScaleTransform = e => ({ name: "scale", data: e.slice(0, e[0] === e[1] ? 1 : 2) }), matrixToTransform = (e, t) => { const n = getDecompositions(e); let r, a = Number.MAX_VALUE; for (const e of n) { const n = e.map((e => { const n = { name: e.name, data: [...e.data] }; return roundTransform(n, t) })), o = optimize$1(n, e), i = js2transform(o, t).length; i < a && (r = o, a = i) } return r ?? [e] }, transformToMatrix = e => { if ("matrix" === e.name) return e.data; switch (e.name) { case "translate": return [1, 0, 0, 1, e.data[0], e.data[1] || 0]; case "scale": return [e.data[0], 0, 0, e.data[1] ?? e.data[0], 0, 0]; case "rotate": var t = mth.cos(e.data[0]), n = mth.sin(e.data[0]), r = e.data[1] || 0, a = e.data[2] || 0; return [t, n, -n, t, (1 - t) * r + n * a, (1 - t) * a - n * r]; case "skewX": return [1, 0, mth.tan(e.data[0]), 1, 0, 0]; case "skewY": return [1, mth.tan(e.data[0]), 0, 1, 0, 0]; default: throw Error(`Unknown transform ${e.name}`) } }, transformArc = (e, t, n) => { const r = t[5] - e[0], a = t[6] - e[1]; let o = t[0], i = t[1]; const s = t[2] * Math.PI / 180, l = Math.cos(s), c = Math.sin(s); if (o > 0 && i > 0) { let e = Math.pow(r * l + a * c, 2) / (4 * o * o) + Math.pow(a * l - r * c, 2) / (4 * i * i); e > 1 && (e = Math.sqrt(e), o *= e, i *= e) } const u = multiplyTransformMatrices(n, [o * l, o * c, -i * c, i * l, 0, 0]), d = u[2] * u[2] + u[3] * u[3], p = u[0] * u[0] + u[1] * u[1] + d, h = Math.hypot(u[0] - u[3], u[1] + u[2]) * Math.hypot(u[0] + u[3], u[1] - u[2]); if (h) { const e = (p + h) / 2, n = (p - h) / 2, r = Math.abs(e - d) > 1e-6, a = (r ? e : n) - d, o = u[0] * u[2] + u[1] * u[3], i = u[0] * a + u[2] * o, s = u[1] * a + u[3] * o; t[0] = Math.sqrt(e), t[1] = Math.sqrt(n), t[2] = ((r ? s < 0 : i > 0) ? -1 : 1) * Math.acos((r ? i : s) / Math.hypot(i, s)) * 180 / Math.PI } else t[0] = t[1] = Math.sqrt(p / 2), t[2] = 0; return n[0] < 0 != n[3] < 0 && (t[4] = 1 - t[4]), t }, multiplyTransformMatrices = (e, t) => [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]], roundTransform = (e, t) => { switch (e.name) { case "translate": e.data = floatRound(e.data, t); break; case "rotate": e.data = [...degRound(e.data.slice(0, 1), t), ...floatRound(e.data.slice(1), t)]; break; case "skewX": case "skewY": e.data = degRound(e.data, t); break; case "scale": e.data = transformRound(e.data, t); break; case "matrix": e.data = [...transformRound(e.data.slice(0, 4), t), ...floatRound(e.data.slice(4), t)] }return e }, degRound = (e, t) => null != t.degPrecision && t.degPrecision >= 1 && t.floatPrecision < 20 ? smartRound(t.degPrecision, e) : round$1(e), floatRound = (e, t) => t.floatPrecision >= 1 && t.floatPrecision < 20 ? smartRound(t.floatPrecision, e) : round$1(e), transformRound = (e, t) => t.transformPrecision >= 1 && t.floatPrecision < 20 ? smartRound(t.transformPrecision, e) : round$1(e), round$1 = e => e.map(Math.round), smartRound = (e, t) => { for (let n = t.length, r = +Math.pow(.1, e).toFixed(e); n--;)if (toFixed(t[n], e) !== t[n]) { const a = +t[n].toFixed(e - 1); t[n] = +Math.abs(a - t[n]).toFixed(e + 1) >= r ? +t[n].toFixed(e) : a } return t }, js2transform = (e, t) => e.map((e => (roundTransform(e, t), `${e.name}(${cleanupOutData(e.data, t)})`))).join(""), regNumericValues$1 = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g, applyTransforms = (e, t) => { const n = collectStylesheet(e); return { element: { enter: e => { if (null == e.attributes.d) return; if (null != e.attributes.id) return; if (null == e.attributes.transform || "" === e.attributes.transform || null != e.attributes.style || Object.entries(e.attributes).some((([e, t]) => referencesProps.has(e) && includesUrlReference(t)))) return; const r = computeStyle(n, e), a = r.transform; if ("static" === a.type && a.value !== e.attributes.transform) return; const o = transformsMultiply(transform2js(e.attributes.transform)), i = "static" === r.stroke?.type ? r.stroke.value : null, s = "static" === r["stroke-width"]?.type ? r["stroke-width"].value : null, l = t.transformPrecision; if ("dynamic" === r.stroke?.type || "dynamic" === r["stroke-width"]?.type) return; const c = Number(Math.hypot(o.data[0], o.data[1]).toFixed(l)); if (i && "none" != i) { if (!t.applyTransformsStroked) return; if (!(o.data[0] === o.data[3] && o.data[1] === -o.data[2] || o.data[0] === -o.data[3] && o.data[1] === o.data[2])) return; 1 !== c && "non-scaling-stroke" !== e.attributes["vector-effect"] && (e.attributes["stroke-width"] = (s || attrsGroupsDefaults.presentation["stroke-width"]).trim().replace(regNumericValues$1, (e => removeLeadingZero(Number(e) * c))), null != e.attributes["stroke-dashoffset"] && (e.attributes["stroke-dashoffset"] = e.attributes["stroke-dashoffset"].trim().replace(regNumericValues$1, (e => removeLeadingZero(Number(e) * c)))), null != e.attributes["stroke-dasharray"] && (e.attributes["stroke-dasharray"] = e.attributes["stroke-dasharray"].trim().replace(regNumericValues$1, (e => removeLeadingZero(Number(e) * c))))) } const u = path2js(e); applyMatrixToPathData(u, o.data), delete e.attributes.transform } } } }, transformAbsolutePoint = (e, t, n) => [e[0] * t + e[2] * n + e[4], e[1] * t + e[3] * n + e[5]], transformRelativePoint = (e, t, n) => [e[0] * t + e[2] * n, e[1] * t + e[3] * n], applyMatrixToPathData = (e, t) => { const n = [0, 0], r = [0, 0]; for (const a of e) { let { command: e, args: o } = a; if ("M" === e) { r[0] = o[0], r[1] = o[1], n[0] = r[0], n[1] = r[1]; const [e, a] = transformAbsolutePoint(t, o[0], o[1]); o[0] = e, o[1] = a } if ("m" === e) { r[0] += o[0], r[1] += o[1], n[0] = r[0], n[1] = r[1]; const [e, a] = transformRelativePoint(t, o[0], o[1]); o[0] = e, o[1] = a } if ("H" === e && (e = "L", o = [o[0], r[1]]), "h" === e && (e = "l", o = [o[0], 0]), "V" === e && (e = "L", o = [r[0], o[0]]), "v" === e && (e = "l", o = [0, o[0]]), "L" === e) { r[0] = o[0], r[1] = o[1]; const [e, n] = transformAbsolutePoint(t, o[0], o[1]); o[0] = e, o[1] = n } if ("l" === e) { r[0] += o[0], r[1] += o[1]; const [e, n] = transformRelativePoint(t, o[0], o[1]); o[0] = e, o[1] = n } if ("C" === e) { r[0] = o[4], r[1] = o[5]; const [e, n] = transformAbsolutePoint(t, o[0], o[1]), [a, i] = transformAbsolutePoint(t, o[2], o[3]), [s, l] = transformAbsolutePoint(t, o[4], o[5]); o[0] = e, o[1] = n, o[2] = a, o[3] = i, o[4] = s, o[5] = l } if ("c" === e) { r[0] += o[4], r[1] += o[5]; const [e, n] = transformRelativePoint(t, o[0], o[1]), [a, i] = transformRelativePoint(t, o[2], o[3]), [s, l] = transformRelativePoint(t, o[4], o[5]); o[0] = e, o[1] = n, o[2] = a, o[3] = i, o[4] = s, o[5] = l } if ("S" === e) { r[0] = o[2], r[1] = o[3]; const [e, n] = transformAbsolutePoint(t, o[0], o[1]), [a, i] = transformAbsolutePoint(t, o[2], o[3]); o[0] = e, o[1] = n, o[2] = a, o[3] = i } if ("s" === e) { r[0] += o[2], r[1] += o[3]; const [e, n] = transformRelativePoint(t, o[0], o[1]), [a, i] = transformRelativePoint(t, o[2], o[3]); o[0] = e, o[1] = n, o[2] = a, o[3] = i } if ("Q" === e) { r[0] = o[2], r[1] = o[3]; const [e, n] = transformAbsolutePoint(t, o[0], o[1]), [a, i] = transformAbsolutePoint(t, o[2], o[3]); o[0] = e, o[1] = n, o[2] = a, o[3] = i } if ("q" === e) { r[0] += o[2], r[1] += o[3]; const [e, n] = transformRelativePoint(t, o[0], o[1]), [a, i] = transformRelativePoint(t, o[2], o[3]); o[0] = e, o[1] = n, o[2] = a, o[3] = i } if ("T" === e) { r[0] = o[0], r[1] = o[1]; const [e, n] = transformAbsolutePoint(t, o[0], o[1]); o[0] = e, o[1] = n } if ("t" === e) { r[0] += o[0], r[1] += o[1]; const [e, n] = transformRelativePoint(t, o[0], o[1]); o[0] = e, o[1] = n } if ("A" === e) { if (transformArc(r, o, t), r[0] = o[5], r[1] = o[6], Math.abs(o[2]) > 80) { const e = o[0], t = o[2]; o[0] = o[1], o[1] = e, o[2] = t + (t > 0 ? -90 : 90) } const [e, n] = transformAbsolutePoint(t, o[5], o[6]); o[5] = e, o[6] = n } if ("a" === e) { if (transformArc([0, 0], o, t), r[0] += o[5], r[1] += o[6], Math.abs(o[2]) > 80) { const e = o[0], t = o[2]; o[0] = o[1], o[1] = e, o[2] = t + (t > 0 ? -90 : 90) } const [e, n] = transformRelativePoint(t, o[5], o[6]); o[5] = e, o[6] = n } "z" !== e && "Z" !== e || (r[0] = n[0], r[1] = n[1]), a.command = e, a.args = o } }, name$r = "convertPathData", description$r = "optimizes path data: writes in shorter form, applies transformations"; let roundData, precision, error, arcThreshold, arcTolerance; const fn$r = (e, t) => { const { applyTransforms: n = !0, applyTransformsStroked: r = !0, makeArcs: a = { threshold: 2.5, tolerance: .5 }, straightCurves: o = !0, convertToQ: i = !0, lineShorthands: s = !0, convertToZ: l = !0, curveSmoothShorthands: c = !0, floatPrecision: u = 3, transformPrecision: d = 5, smartArcRounding: p = !0, removeUseless: h = !0, collapseRepeated: m = !0, utilizeAbsolute: f = !0, leadingZero: g = !0, negativeExtraSpace: b = !0, noSpaceAfterFlags: y = !1, forceAbsolutePath: $ = !1 } = t, k = { applyTransforms: n, applyTransformsStroked: r, makeArcs: a, straightCurves: o, convertToQ: i, lineShorthands: s, convertToZ: l, curveSmoothShorthands: c, floatPrecision: u, transformPrecision: d, smartArcRounding: p, removeUseless: h, collapseRepeated: m, utilizeAbsolute: f, leadingZero: g, negativeExtraSpace: b, noSpaceAfterFlags: y, forceAbsolutePath: $ }; n && visit(e, applyTransforms(e, { transformPrecision: d, applyTransformsStroked: r })); const S = collectStylesheet(e); return { element: { enter: e => { if (pathElems.has(e.name) && null != e.attributes.d) { const t = computeStyle(S, e); precision = u, error = !1 !== precision ? +Math.pow(.1, precision).toFixed(precision) : .01, roundData = precision && precision > 0 && precision < 20 ? strongRound : round, a && (arcThreshold = a.threshold, arcTolerance = a.tolerance); const n = null != t["marker-mid"], r = t.stroke && ("dynamic" === t.stroke.type || "none" !== t.stroke.value), o = t["stroke-linecap"] && ("dynamic" === t["stroke-linecap"].type || "butt" !== t["stroke-linecap"].value), i = r && o, s = !r || "static" === t["stroke-linecap"]?.type && "round" === t["stroke-linecap"].value && "static" === t["stroke-linejoin"]?.type && "round" === t["stroke-linejoin"].value; let l = path2js(e); if (l.length) { const t = l.some((e => "m" !== e.command && "M" !== e.command)); convertToRelative(l), l = filters(l, k, { isSafeToUseZ: s, maybeHasStrokeAndLinecap: i, hasMarkerMid: n }), f && (l = convertToMixed(l, k)); (null != e.attributes["marker-start"] || null != e.attributes["marker-end"]) && t && l.every((e => "m" === e.command || "M" === e.command)) && l.push({ command: "z", args: [] }), js2path(e, l, k) } } } } } }, convertToRelative = e => { const t = [0, 0], n = [0, 0]; let r = [0, 0]; for (let a = 0; a < e.length; a += 1) { const o = e[a]; let { command: i, args: s } = o; "m" === i && (n[0] += s[0], n[1] += s[1], t[0] = n[0], t[1] = n[1]), "M" === i && (0 !== a && (i = "m"), s[0] -= n[0], s[1] -= n[1], n[0] += s[0], n[1] += s[1], t[0] = n[0], t[1] = n[1]), "l" === i && (n[0] += s[0], n[1] += s[1]), "L" === i && (i = "l", s[0] -= n[0], s[1] -= n[1], n[0] += s[0], n[1] += s[1]), "h" === i && (n[0] += s[0]), "H" === i && (i = "h", s[0] -= n[0], n[0] += s[0]), "v" === i && (n[1] += s[0]), "V" === i && (i = "v", s[0] -= n[1], n[1] += s[0]), "c" === i && (n[0] += s[4], n[1] += s[5]), "C" === i && (i = "c", s[0] -= n[0], s[1] -= n[1], s[2] -= n[0], s[3] -= n[1], s[4] -= n[0], s[5] -= n[1], n[0] += s[4], n[1] += s[5]), "s" === i && (n[0] += s[2], n[1] += s[3]), "S" === i && (i = "s", s[0] -= n[0], s[1] -= n[1], s[2] -= n[0], s[3] -= n[1], n[0] += s[2], n[1] += s[3]), "q" === i && (n[0] += s[2], n[1] += s[3]), "Q" === i && (i = "q", s[0] -= n[0], s[1] -= n[1], s[2] -= n[0], s[3] -= n[1], n[0] += s[2], n[1] += s[3]), "t" === i && (n[0] += s[0], n[1] += s[1]), "T" === i && (i = "t", s[0] -= n[0], s[1] -= n[1], n[0] += s[0], n[1] += s[1]), "a" === i && (n[0] += s[5], n[1] += s[6]), "A" === i && (i = "a", s[5] -= n[0], s[6] -= n[1], n[0] += s[5], n[1] += s[6]), "Z" !== i && "z" !== i || (n[0] = t[0], n[1] = t[1]), o.command = i, o.args = s, o.base = r, o.coords = [n[0], n[1]], r = o.coords } return e }; function filters(e, t, { isSafeToUseZ: n, maybeHasStrokeAndLinecap: r, hasMarkerMid: a }) { const o = data2Path.bind(null, t), i = [0, 0], s = [0, 0]; let l, c = {}; return e = e.filter((function (e, u, d) { const p = l; let h = e.command, m = e.args, f = d[u + 1]; if ("Z" !== h && "z" !== h) { let l, b = m; if ("s" === h) { b = [0, 0].concat(m); const e = c.args, t = e.length; b[0] = e[t - 2] - e[t - 4], b[1] = e[t - 1] - e[t - 3] } if (t.makeArcs && ("c" == h || "s" == h) && isConvex(b) && (l = findCircle(b))) { const t = roundData([l.radius])[0]; let n = findArcAngle(b, l); const r = b[5] * b[0] - b[4] * b[1] > 0 ? 1 : 0; let a = { command: "a", args: [t, t, 0, 0, r, b[4], b[5]], coords: e.coords.slice(), base: e.base }; const s = [a], p = [l.center[0] - b[4], l.center[1] - b[5]], y = { center: p, radius: l.radius }, $ = [e]; let k, S = 0, v = ""; if ("c" == c.command && isConvex(c.args) && isArcPrev(c.args, l) || "a" == c.command && c.sdata && isArcPrev(c.sdata, l)) { $.unshift(c), a.base = c.base, a.args[5] = a.coords[0] - a.base[0], a.args[6] = a.coords[1] - a.base[1]; const e = "a" == c.command ? c.sdata : c.args; n += findArcAngle(e, { center: [e[4] + l.center[0], e[5] + l.center[1]], radius: l.radius }), n > Math.PI && (a.args[3] = 1), S = 1 } for (var g = u; (f = d[++g]) && ("c" === f.command || "s" === f.command);) { let e = f.args; if ("s" == f.command && (k = makeLonghand({ command: "s", args: f.args.slice() }, d[g - 1].args), e = k.args, k.args = e.slice(0, 2), v = o([k])), !isConvex(e) || !isArc(e, y)) break; if (n += findArcAngle(e, y), n - 2 * Math.PI > .001) break; if (n > Math.PI && (a.args[3] = 1), $.push(f), !(2 * Math.PI - n > .001)) { a.args[5] = 2 * (y.center[0] - e[4]), a.args[6] = 2 * (y.center[1] - e[5]), a.coords = [a.base[0] + a.args[5], a.base[1] + a.args[6]], a = { command: "a", args: [t, t, 0, 0, r, f.coords[0] - a.coords[0], f.coords[1] - a.coords[1]], coords: f.coords, base: a.coords }, s.push(a), g++; break } a.coords = f.coords, a.args[5] = a.coords[0] - a.base[0], a.args[6] = a.coords[1] - a.base[1], p[0] -= e[4], p[1] -= e[5] } if ((o(s) + v).length < o($).length) { if (d[g] && "s" == d[g].command && makeLonghand(d[g], d[g - 1].args), S) { const t = s.shift(); roundData(t.args), i[0] += t.args[5] - c.args[c.args.length - 2], i[1] += t.args[6] - c.args[c.args.length - 1], c.command = "a", c.args = t.args, e.base = c.coords = t.coords } if (a = s.shift(), 1 == $.length ? e.sdata = b.slice() : $.length - 1 - S > 0 && d.splice(u + 1, $.length - 1 - S, ...s), !a) return !1; h = "a", m = a.args, e.coords = a.coords } } if (!1 !== precision) { if ("m" === h || "l" === h || "t" === h || "q" === h || "s" === h || "c" === h) for (let t = m.length; t--;)m[t] += e.base[t % 2] - i[t % 2]; else "h" == h ? m[0] += e.base[0] - i[0] : "v" == h ? m[0] += e.base[1] - i[1] : "a" == h && (m[5] += e.base[0] - i[0], m[6] += e.base[1] - i[1]); roundData(m), "h" == h ? i[0] += m[0] : "v" == h ? i[1] += m[0] : (i[0] += m[m.length - 2], i[1] += m[m.length - 1]), roundData(i), "M" !== h && "m" !== h || (s[0] = i[0], s[1] = i[1]) } const y = "a" === h ? calculateSagitta(m) : void 0; if (t.smartArcRounding && void 0 !== y && precision) for (let e = precision; e >= 0; e--) { const t = toFixed(m[0], e), n = calculateSagitta([t, t, ...m.slice(2)]); if (!(Math.abs(y - n) < error)) break; m[0] = t, m[1] = t } if (t.straightCurves && ("c" === h && isCurveStraightLine(m) || "s" === h && isCurveStraightLine(b) ? (f && "s" == f.command && makeLonghand(f, m), h = "l", m = m.slice(-2)) : "q" === h && isCurveStraightLine(m) ? (f && "t" == f.command && makeLonghand(f, m), h = "l", m = m.slice(-2)) : ("t" === h && "q" !== c.command && "t" !== c.command || "a" === h && (0 === m[0] || 0 === m[1] || void 0 !== y && y < error)) && (h = "l", m = m.slice(-2))), t.convertToQ && "c" == h) { const n = .75 * (e.base[0] + m[0]) - .25 * e.base[0], r = .75 * (e.base[0] + m[2]) - .25 * (e.base[0] + m[4]); if (Math.abs(n - r) < 2 * error) { const a = .75 * (e.base[1] + m[1]) - .25 * e.base[1], o = .75 * (e.base[1] + m[3]) - .25 * (e.base[1] + m[5]); if (Math.abs(a - o) < 2 * error) { const i = m.slice(); i.splice(0, 4, n + r - e.base[0], a + o - e.base[1]), roundData(i); const s = cleanupOutData(m, t).length; cleanupOutData(i, t).length < s && (h = "q", m = i, f && "s" == f.command && makeLonghand(f, m)) } } } if (t.lineShorthands && "l" === h && (0 === m[1] ? (h = "h", m.pop()) : 0 === m[0] && (h = "v", m.shift())), t.collapseRepeated && !1 === a && ("m" === h || "h" === h || "v" === h) && c.command && h == c.command.toLowerCase() && ("h" != h && "v" != h || c.args[0] >= 0 == m[0] >= 0)) return c.args[0] += m[0], "h" != h && "v" != h && (c.args[1] += m[1]), c.coords = e.coords, d[u] = c, !1; if (t.curveSmoothShorthands && c.command) if ("c" === h) ("c" === c.command && Math.abs(m[0] - -(c.args[2] - c.args[4])) < error && Math.abs(m[1] - -(c.args[3] - c.args[5])) < error || "s" === c.command && Math.abs(m[0] - -(c.args[0] - c.args[2])) < error && Math.abs(m[1] - -(c.args[1] - c.args[3])) < error || "c" !== c.command && "s" !== c.command && Math.abs(m[0]) < error && Math.abs(m[1]) < error) && (h = "s", m = m.slice(2)); else if ("q" === h) if ("q" === c.command && Math.abs(m[0] - (c.args[2] - c.args[0])) < error && Math.abs(m[1] - (c.args[3] - c.args[1])) < error) h = "t", m = m.slice(2); else if ("t" === c.command) { const t = reflectPoint(p, e.base), n = [m[0] + e.base[0], m[1] + e.base[1]]; Math.abs(t[0] - n[0]) < error && Math.abs(t[1] - n[1]) < error && (h = "t", m = m.slice(2)) } if (t.removeUseless && !r) { if (("l" === h || "h" === h || "v" === h || "q" === h || "t" === h || "c" === h || "s" === h) && m.every((function (e) { return 0 === e }))) return d[u] = c, !1; if ("a" === h && 0 === m[5] && 0 === m[6]) return d[u] = c, !1 } t.convertToZ && (n || "Z" === f?.command || "z" === f?.command) && ("l" === h || "h" === h || "v" === h) && Math.abs(s[0] - e.coords[0]) < error && Math.abs(s[1] - e.coords[1]) < error && (h = "z", m = []), e.command = h, e.args = m } else if (i[0] = s[0], i[1] = s[1], "Z" === c.command || "z" === c.command) return !1; return !(("Z" === h || "z" === h) && t.removeUseless && n && Math.abs(e.base[0] - e.coords[0]) < error / 10 && Math.abs(e.base[1] - e.coords[1]) < error / 10) && (l = "q" === h ? [m[0] + e.base[0], m[1] + e.base[1]] : "t" === h ? p ? reflectPoint(p, e.base) : e.coords : void 0, c = e, !0) })), e } function convertToMixed(e, t) { let n = e[0]; return e = e.filter((function (e, r) { if (0 == r) return !0; if ("Z" === e.command || "z" === e.command) return n = e, !0; const a = e.command, o = e.args, i = o.slice(), s = o.slice(); if ("m" === a || "l" === a || "t" === a || "q" === a || "s" === a || "c" === a) for (let t = i.length; t--;)i[t] += e.base[t % 2]; else "h" == a ? i[0] += e.base[0] : "v" == a ? i[0] += e.base[1] : "a" == a && (i[5] += e.base[0], i[6] += e.base[1]); roundData(i), roundData(s); const l = cleanupOutData(i, t), c = cleanupOutData(s, t); return (t.forceAbsolutePath || l.length < c.length && !(t.negativeExtraSpace && a == n.command && n.command.charCodeAt(0) > 96 && l.length == c.length - 1 && (o[0] < 0 || 0 === Math.floor(o[0]) && !Number.isInteger(o[0]) && n.args[n.args.length - 1] % 1))) && (e.command = a.toUpperCase(), e.args = i), n = e, !0 })) } function isConvex(e) { const t = getIntersection([0, 0, e[2], e[3], e[0], e[1], e[4], e[5]]); return null != t && e[2] < t[0] == t[0] < 0 && e[3] < t[1] == t[1] < 0 && e[4] < t[0] == t[0] < e[0] && e[5] < t[1] == t[1] < e[1] } function getIntersection(e) { const t = e[1] - e[3], n = e[2] - e[0], r = e[0] * e[3] - e[2] * e[1], a = e[5] - e[7], o = e[6] - e[4], i = e[4] * e[7] - e[5] * e[6], s = t * o - a * n; if (!s) return; const l = [(n * i - o * r) / s, (t * i - a * r) / -s]; return !isNaN(l[0]) && !isNaN(l[1]) && isFinite(l[0]) && isFinite(l[1]) ? l : void 0 } function strongRound(e) { const t = precision || 0; for (let n = e.length; n-- > 0;) { const r = toFixed(e[n], t); if (r !== e[n]) { const a = toFixed(e[n], t - 1); e[n] = toFixed(Math.abs(a - e[n]), t + 1) >= error ? r : a } } return e } function round(e) { for (let t = e.length; t-- > 0;)e[t] = Math.round(e[t]); return e } function isCurveStraightLine(e) { let t = e.length - 2; const n = -e[t + 1], r = e[t], a = 1 / (n * n + r * r); if (t <= 1 || !isFinite(a)) return !1; for (; (t -= 2) >= 0;)if (Math.sqrt(Math.pow(n * e[t] + r * e[t + 1], 2) * a) > error) return !1; return !0 } function calculateSagitta(e) { if (1 === e[3]) return; const [t, n] = e; if (Math.abs(t - n) > error) return; const r = Math.hypot(e[5], e[6]); return r > 2 * t ? void 0 : t - Math.sqrt(t ** 2 - .25 * r ** 2) } function makeLonghand(e, t) { switch (e.command) { case "s": e.command = "c"; break; case "t": e.command = "q" }return e.args.unshift(t[t.length - 2] - t[t.length - 4], t[t.length - 1] - t[t.length - 3]), e } function getDistance(e, t) { return Math.hypot(e[0] - t[0], e[1] - t[1]) } function reflectPoint(e, t) { return [2 * t[0] - e[0], 2 * t[1] - e[1]] } function getCubicBezierPoint(e, t) { const n = t * t, r = n * t, a = 1 - t, o = a * a; return [3 * o * t * e[0] + 3 * a * n * e[2] + r * e[4], 3 * o * t * e[1] + 3 * a * n * e[3] + r * e[5]] } function findCircle(e) { const t = getCubicBezierPoint(e, .5), n = [t[0] / 2, t[1] / 2], r = [(t[0] + e[4]) / 2, (t[1] + e[5]) / 2], a = getIntersection([n[0], n[1], n[0] + n[1], n[1] - n[0], r[0], r[1], r[0] + (r[1] - t[1]), r[1] - (r[0] - t[0])]), o = a && getDistance([0, 0], a), i = Math.min(arcThreshold * error, arcTolerance * o / 100); if (a && o < 1e15 && [1 / 4, 3 / 4].every((function (t) { return Math.abs(getDistance(getCubicBezierPoint(e, t), a) - o) <= i }))) return { center: a, radius: o } } function isArc(e, t) { const n = Math.min(arcThreshold * error, arcTolerance * t.radius / 100); return [0, 1 / 4, .5, 3 / 4, 1].every((function (r) { return Math.abs(getDistance(getCubicBezierPoint(e, r), t.center) - t.radius) <= n })) } function isArcPrev(e, t) { return isArc(e, { center: [t.center[0] + e[4], t.center[1] + e[5]], radius: t.radius }) } function findArcAngle(e, t) { const n = -t.center[0], r = -t.center[1], a = e[4] - t.center[0], o = e[5] - t.center[1]; return Math.acos((n * a + r * o) / Math.sqrt((n * n + r * r) * (a * a + o * o))) } function data2Path(e, t) { return t.reduce((function (t, n) { let r = ""; return n.args && (r = cleanupOutData(roundData(n.args.slice()), e)), t + n.command + r }), "") } var convertPathData = Object.freeze({ __proto__: null, description: description$r, fn: fn$r, name: name$r }); const name$q = "convertTransform", description$q = "collapses multiple transformations and optimizes it", fn$q = (e, t) => { const { convertToShorts: n = !0, degPrecision: r, floatPrecision: a = 3, transformPrecision: o = 5, matrixToTransform: i = !0, shortTranslate: s = !0, shortScale: l = !0, shortRotate: c = !0, removeUseless: u = !0, collapseIntoOne: d = !0, leadingZero: p = !0, negativeExtraSpace: h = !1 } = t, m = { convertToShorts: n, degPrecision: r, floatPrecision: a, transformPrecision: o, matrixToTransform: i, shortTranslate: s, shortScale: l, shortRotate: c, removeUseless: u, collapseIntoOne: d, leadingZero: p, negativeExtraSpace: h }; return { element: { enter: e => { null != e.attributes.transform && convertTransform(e, "transform", m), null != e.attributes.gradientTransform && convertTransform(e, "gradientTransform", m), null != e.attributes.patternTransform && convertTransform(e, "patternTransform", m) } } } }, convertTransform = (e, t, n) => { let r = transform2js(e.attributes[t]); (n = definePrecision(r, n)).collapseIntoOne && r.length > 1 && (r = [transformsMultiply(r)]), n.convertToShorts ? r = convertToShorts(r, n) : r.forEach((e => roundTransform(e, n))), n.removeUseless && (r = removeUseless(r)), r.length ? e.attributes[t] = js2transform(r, n) : delete e.attributes[t] }, definePrecision = (e, { ...t }) => { const n = []; for (const t of e) "matrix" == t.name && n.push(...t.data.slice(0, 4)); let r = t.transformPrecision; return n.length && (t.transformPrecision = Math.min(t.transformPrecision, Math.max.apply(Math, n.map(floatDigits)) || t.transformPrecision), r = Math.max.apply(Math, n.map((e => e.toString().replace(/\D+/g, "").length)))), null == t.degPrecision && (t.degPrecision = Math.max(0, Math.min(t.floatPrecision, r - 2))), t }, floatDigits = e => { const t = e.toString(); return t.slice(t.indexOf(".")).length - 1 }, convertToShorts = (e, t) => { for (let n = 0; n < e.length; n++) { let r = e[n]; if (t.matrixToTransform && "matrix" === r.name) { const a = matrixToTransform(r, t); js2transform(a, t).length <= js2transform([r], t).length && e.splice(n, 1, ...a), r = e[n] } roundTransform(r, t), t.shortTranslate && "translate" === r.name && 2 === r.data.length && !r.data[1] && r.data.pop(), t.shortScale && "scale" === r.name && 2 === r.data.length && r.data[0] === r.data[1] && r.data.pop(), t.shortRotate && "translate" === e[n - 2]?.name && "rotate" === e[n - 1].name && "translate" === e[n].name && e[n - 2].data[0] === -e[n].data[0] && e[n - 2].data[1] === -e[n].data[1] && (e.splice(n - 2, 3, { name: "rotate", data: [e[n - 1].data[0], e[n - 2].data[0], e[n - 2].data[1]] }), n -= 2) } return e }, removeUseless = e => e.filter((e => !(["translate", "rotate", "skewX", "skewY"].indexOf(e.name) > -1 && (1 == e.data.length || "rotate" == e.name) && !e.data[0] || "translate" == e.name && !e.data[0] && !e.data[1] || "scale" == e.name && 1 == e.data[0] && (e.data.length < 2 || 1 == e.data[1]) || "matrix" == e.name && 1 == e.data[0] && 1 == e.data[3] && !(e.data[1] || e.data[2] || e.data[4] || e.data[5])))); var convertTransform$1 = Object.freeze({ __proto__: null, description: description$q, fn: fn$q, name: name$q }); const name$p = "removeEmptyAttrs", description$p = "removes empty attributes", fn$p = () => ({ element: { enter: e => { for (const [t, n] of Object.entries(e.attributes)) "" !== n || attrsGroups.conditionalProcessing.has(t) || delete e.attributes[t] } } }); var removeEmptyAttrs = Object.freeze({ __proto__: null, description: description$p, fn: fn$p, name: name$p }); const name$o = "removeEmptyContainers", description$o = "removes empty container elements", fn$o = e => { const t = collectStylesheet(e); return { element: { exit: (e, n) => { "svg" !== e.name && elemsGroups.container.has(e.name) && 0 === e.children.length && ("pattern" === e.name && 0 !== Object.keys(e.attributes).length || "mask" === e.name && null != e.attributes.id || "element" === n.type && "switch" === n.name || ("g" !== e.name || null == e.attributes.filter && !computeStyle(t, e).filter) && detachNodeFromParent(e, n)) } } } }; var removeEmptyContainers = Object.freeze({ __proto__: null, description: description$o, fn: fn$o, name: name$o }); const name$n = "mergePaths", description$n = "merges multiple paths in one if possible"; function elementHasUrl(e, t) { const n = e[t]; return "static" === n?.type && includesUrlReference(n.value) } const fn$n = (e, t) => { const { force: n = !1, floatPrecision: r = 3, noSpaceAfterFlags: a = !1 } = t, o = collectStylesheet(e); return { element: { enter: e => { if (e.children.length <= 1) return; const t = []; let i = e.children[0], s = null; const l = (e, t) => { js2path(e, t, { floatPrecision: r, noSpaceAfterFlags: a }), s = null }; for (let r = 1; r < e.children.length; r++) { const a = e.children[r]; if ("element" !== i.type || "path" !== i.name || 0 !== i.children.length || null == i.attributes.d) { s && "element" === i.type && l(i, s), i = a; continue } if ("element" !== a.type || "path" !== a.name || 0 !== a.children.length || null == a.attributes.d) { s && l(i, s), i = a; continue } const c = computeStyle(o, a); if (c["marker-start"] || c["marker-mid"] || c["marker-end"] || c["clip-path"] || c.mask || c["mask-image"] || ["fill", "filter", "stroke"].some((e => elementHasUrl(c, e)))) { s && l(i, s), i = a; continue } const u = Object.keys(a.attributes); if (u.length !== Object.keys(i.attributes).length) { s && l(i, s), i = a; continue } if (u.some((e => "d" !== e && "element" === i.type && i.attributes[e] !== a.attributes[e]))) { s && l(i, s), i = a; continue } const d = null != s, p = path2js(a); s = s ?? path2js(i), !n && intersects(s, p) ? (d && l(i, s), i = a, s = null) : (s.push(...p), t.push(a)) } s && "element" === i.type && l(i, s), e.children = e.children.filter((e => !t.includes(e))) } } } }; var mergePaths = Object.freeze({ __proto__: null, description: description$n, fn: fn$n, name: name$n }); const name$m = "removeUnusedNS", description$m = "removes unused namespaces declaration", fn$m = () => { const e = new Set; return { element: { enter: (t, n) => { if ("svg" === t.name && "root" === n.type) for (const n of Object.keys(t.attributes)) if (n.startsWith("xmlns:")) { const t = n.slice(6); e.add(t) } if (0 !== e.size) { if (t.name.includes(":")) { const [n] = t.name.split(":"); e.has(n) && e.delete(n) } for (const n of Object.keys(t.attributes)) if (n.includes(":")) { const [t] = n.split(":"); e.delete(t) } } }, exit: (t, n) => { if ("svg" === t.name && "root" === n.type) for (const n of e) delete t.attributes[`xmlns:${n}`] } } } }; var removeUnusedNS = Object.freeze({ __proto__: null, description: description$m, fn: fn$m, name: name$m }); const name$l = "sortAttrs", description$l = "Sort element attributes for better compression", fn$l = (e, t) => { const { order: n = ["id", "width", "height", "x", "x1", "x2", "y", "y1", "y2", "cx", "cy", "r", "fill", "stroke", "marker", "d", "points"], xmlnsOrder: r = "front" } = t, a = e => { if ("front" === r) { if ("xmlns" === e) return 3; if (e.startsWith("xmlns:")) return 2 } return e.includes(":") ? 1 : 0 }, o = ([e], [t]) => { const r = a(e), o = a(t) - r; if (0 !== o) return o; const [i] = e.split("-"), [s] = t.split("-"); if (i !== s) { const e = n.includes(i) ? 1 : 0, t = n.includes(s) ? 1 : 0; if (1 === e && 1 === t) return n.indexOf(i) - n.indexOf(s); const r = t - e; if (0 !== r) return r } return e < t ? -1 : 1 }; return { element: { enter: e => { const t = Object.entries(e.attributes); t.sort(o); const n = {}; for (const [e, r] of t) n[e] = r; e.attributes = n } } } }; var sortAttrs = Object.freeze({ __proto__: null, description: description$l, fn: fn$l, name: name$l }); const name$k = "sortDefsChildren", description$k = "Sorts children of <defs> to improve compression", fn$k = () => ({ element: { enter: e => { if ("defs" === e.name) { const t = new Map; for (const n of e.children) if ("element" === n.type) { const e = t.get(n.name); null == e ? t.set(n.name, 1) : t.set(n.name, e + 1) } e.children.sort(((e, n) => { if ("element" !== e.type || "element" !== n.type) return 0; const r = t.get(e.name), a = t.get(n.name); if (null != r && null != a) { const e = a - r; if (0 !== e) return e } const o = n.name.length - e.name.length; return 0 !== o ? o : e.name !== n.name ? e.name > n.name ? -1 : 1 : 0 })) } } } }); var sortDefsChildren = Object.freeze({ __proto__: null, description: description$k, fn: fn$k, name: name$k }); const name$j = "removeDesc", description$j = "removes <desc>", standardDescs = /^(Created with|Created using)/, fn$j = (e, t) => { const { removeAny: n = !1 } = t; return { element: { enter: (e, t) => { "desc" === e.name && (n || 0 === e.children.length || "text" === e.children[0].type && standardDescs.test(e.children[0].value)) && detachNodeFromParent(e, t) } } } }; var removeDesc = Object.freeze({ __proto__: null, description: description$j, fn: fn$j, name: name$j }); const presetDefault = createPreset({ name: "preset-default", plugins: [removeDoctype, removeXMLProcInst, removeComments, removeDeprecatedAttrs, removeMetadata, removeEditorsNSData, cleanupAttrs, mergeStyles, inlineStyles, minifyStyles, cleanupIds, removeUselessDefs, cleanupNumericValues, convertColors, removeUnknownsAndDefaults, removeNonInheritableGroupAttrs, removeUselessStrokeAndFill, cleanupEnableBackground, removeHiddenElems, removeEmptyText, convertShapeToPath, convertEllipseToCircle, moveElemsAttrsToGroup, moveGroupAttrsToElems, collapseGroups, convertPathData, convertTransform$1, removeEmptyAttrs, removeEmptyContainers, mergePaths, removeUnusedNS, sortAttrs, sortDefsChildren, removeDesc] }), name$i = "addAttributesToSVGElement", description$i = "adds attributes to an outer <svg> element", ENOCLS$1 = 'Error in plugin "addAttributesToSVGElement": absent parameters.\nIt should have a list of "attributes" or one "attribute".\nConfig example:\n\nplugins: [\n  {\n    name: \'addAttributesToSVGElement\',\n    params: {\n      attribute: "mySvg"\n    }\n  }\n]\n\nplugins: [\n  {\n    name: \'addAttributesToSVGElement\',\n    params: {\n      attributes: ["mySvg", "size-big"]\n    }\n  }\n]\n\nplugins: [\n  {\n    name: \'addAttributesToSVGElement\',\n    params: {\n      attributes: [\n        {\n          focusable: false\n        },\n        {\n          \'data-image\': icon\n        }\n      ]\n    }\n  }\n]\n', fn$i = (e, t) => { if (!Array.isArray(t.attributes) && !t.attribute) return console.error(ENOCLS$1), null; const n = t.attributes || [t.attribute]; return { element: { enter: (e, t) => { if ("svg" === e.name && "root" === t.type) for (const t of n) if ("string" == typeof t && null == e.attributes[t] && (e.attributes[t] = void 0), "object" == typeof t) for (const n of Object.keys(t)) null == e.attributes[n] && (e.attributes[n] = t[n]) } } } }; var addAttributesToSVGElement = Object.freeze({ __proto__: null, description: description$i, fn: fn$i, name: name$i }); const name$h = "addClassesToSVGElement", description$h = "adds classnames to an outer <svg> element", ENOCLS = 'Error in plugin "addClassesToSVGElement": absent parameters.\nIt should have a list of classes in "classNames" or one "className".\nConfig example:\n\nplugins: [\n  {\n    name: "addClassesToSVGElement",\n    params: {\n      className: "mySvg"\n    }\n  }\n]\n\nplugins: [\n  {\n    name: "addClassesToSVGElement",\n    params: {\n      classNames: ["mySvg", "size-big"]\n    }\n  }\n]\n', fn$h = (e, t, n) => { if (!(Array.isArray(t.classNames) && 0 !== t.classNames.length || t.className)) return console.error(ENOCLS), null; const r = t.classNames || [t.className]; return { element: { enter: (e, t) => { if ("svg" === e.name && "root" === t.type) { const t = new Set(null == e.attributes.class ? null : e.attributes.class.split(" ")); for (const a of r) if (null != a) { const r = "string" == typeof a ? a : a(e, n); t.add(r) } e.attributes.class = Array.from(t).join(" ") } } } } }; var addClassesToSVGElement = Object.freeze({ __proto__: null, description: description$h, fn: fn$h, name: name$h }); const name$g = "cleanupListOfValues", description$g = "rounds list of values to the fixed precision", regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/, regSeparator = /\s+,?\s*|,\s*/, absoluteLengths = { cm: 96 / 2.54, mm: 96 / 25.4, in: 96, pt: 4 / 3, pc: 16, px: 1 }, fn$g = (e, t) => { const { floatPrecision: n = 3, leadingZero: r = !0, defaultPx: a = !0, convertToPx: o = !0 } = t, i = e => { const t = []; for (const i of e.split(regSeparator)) { const e = i.match(regNumericValues), s = i.match(/new/); if (e) { let i = Number(Number(e[1]).toFixed(n)); let s, l = e[3] || ""; if (o && l && l in absoluteLengths) { const t = Number((absoluteLengths[l] * Number(e[1])).toFixed(n)); t.toString().length < e[0].length && (i = t, l = "px") } s = r ? removeLeadingZero(i) : i.toString(), a && "px" === l && (l = ""), t.push(s + l) } else s ? t.push("new") : i && t.push(i) } return t.join(" ") }; return { element: { enter: e => { null != e.attributes.points && (e.attributes.points = i(e.attributes.points)), null != e.attributes["enable-background"] && (e.attributes["enable-background"] = i(e.attributes["enable-background"])), null != e.attributes.viewBox && (e.attributes.viewBox = i(e.attributes.viewBox)), null != e.attributes["stroke-dasharray"] && (e.attributes["stroke-dasharray"] = i(e.attributes["stroke-dasharray"])), null != e.attributes.dx && (e.attributes.dx = i(e.attributes.dx)), null != e.attributes.dy && (e.attributes.dy = i(e.attributes.dy)), null != e.attributes.x && (e.attributes.x = i(e.attributes.x)), null != e.attributes.y && (e.attributes.y = i(e.attributes.y)) } } } }; var cleanupListOfValues = Object.freeze({ __proto__: null, description: description$g, fn: fn$g, name: name$g }); const name$f = "convertOneStopGradients", description$f = "converts one-stop (single color) gradients to a plain color", fn$f = e => { const t = collectStylesheet(e), n = new Set, r = new Map, a = new Map; let o = 0; return { element: { enter: (i, s) => { if (null != i.attributes["xlink:href"] && o++, "defs" === i.name) return void r.set(i, s); if ("linearGradient" !== i.name && "radialGradient" !== i.name) return; const l = i.children.filter((e => "element" === e.type && "stop" === e.name)), c = i.attributes["xlink:href"] || i.attributes.href, u = 0 === l.length && null != c && c.startsWith("#") ? querySelector(e, c) : i; if (null == u || "element" !== u.type) return void a.set(i, s); const d = u.children.filter((e => "element" === e.type && "stop" === e.name)); if (1 !== d.length || "element" !== d[0].type) return; let p; "element" === s.type && "defs" === s.name && n.add(s), a.set(i, s); const h = computeStyle(t, d[0])["stop-color"]; null != h && "static" === h.type && (p = h.value); const m = `url(#${i.attributes.id})`, f = [...colorsProps].map((e => `[${e}="${m}"]`)).join(","), g = querySelectorAll(e, f); for (const e of g) if ("element" === e.type) for (const t of colorsProps) e.attributes[t] === m && (null != p ? e.attributes[t] = p : delete e.attributes[t]); const b = querySelectorAll(e, `[style*=${m}]`); for (const e of b) "element" === e.type && (e.attributes.style = e.attributes.style.replace(m, p || attrsGroupsDefaults.presentation["stop-color"])) }, exit: e => { if ("svg" === e.name) { for (const [e, t] of a.entries()) null != e.attributes["xlink:href"] && o--, detachNodeFromParent(e, t); 0 === o && delete e.attributes["xmlns:xlink"]; for (const [e, t] of r.entries()) n.has(e) && 0 === e.children.length && detachNodeFromParent(e, t) } } } } }; var convertOneStopGradients = Object.freeze({ __proto__: null, description: description$f, fn: fn$f, name: name$f }); const name$e = "convertStyleToAttrs", description$e = "converts style to attributes", g = (...e) => "(?:" + e.join("|") + ")", stylingProps = attrsGroups.presentation, rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)", rAttr = "\\s*(" + g("[^:;\\\\]", rEscape) + "*?)\\s*", rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)", rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)', rQuotedString = new RegExp("^" + g(rSingleQuotes, rQuotes) + "$"), rParenthesis = "\\(" + g("[^'\"()\\\\]+", rEscape, rSingleQuotes, rQuotes) + "*?\\)", rValue = "\\s*(" + g("[^!'\"();\\\\]+?", rEscape, rSingleQuotes, rQuotes, rParenthesis, "[^;]*?") + "*?)", rDeclEnd = "\\s*(?:;\\s*|$)", rImportant = "(\\s*!important(?![-(\\w]))?", regDeclarationBlock = new RegExp(rAttr + ":" + rValue + rImportant + rDeclEnd, "ig"), regStripComments = new RegExp(g(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"), "ig"), fn$e = (e, t) => { const { keepImportant: n = !1 } = t; return { element: { enter: e => { if (null != e.attributes.style) { let r = []; const a = {}, o = e.attributes.style.replace(regStripComments, (e => "/" == e[0] ? "" : "\\" == e[0] && /[-g-z]/i.test(e[1]) ? e[1] : e)); regDeclarationBlock.lastIndex = 0; for (var t; t = regDeclarationBlock.exec(o);)n && t[3] || r.push([t[1], t[2]]); r.length && (r = r.filter((function (e) { if (e[0]) { const t = e[0].toLowerCase(); let n = e[1]; if (rQuotedString.test(n) && (n = n.slice(1, -1)), stylingProps.has(t)) return a[t] = n, !1 } return !0 })), Object.assign(e.attributes, a), r.length ? e.attributes.style = r.map((e => e.join(":"))).join(";") : delete e.attributes.style) } } } } }; var convertStyleToAttrs = Object.freeze({ __proto__: null, description: description$e, fn: fn$e, name: name$e }); const name$d = "prefixIds", description$d = "prefix IDs", getBasename = e => { const t = /[/\\]?([^/\\]+)$/.exec(e); return t ? t[1] : "" }, escapeIdentifierName = e => e.replace(/[. ]/g, "_"), unquote = e => e.startsWith('"') && e.endsWith('"') || e.startsWith("'") && e.endsWith("'") ? e.slice(1, -1) : e, prefixId = (e, t) => { const n = e(t); return t.startsWith(n) ? t : n + t }, prefixReference = (e, t) => t.startsWith("#") ? "#" + prefixId(e, t.slice(1)) : null, generatePrefix = (e, t, n, r, a, o) => { if ("function" == typeof r) { let i = o.get(e); return null != i || (i = r(t, n) + a, o.set(e, i)), i } return "string" == typeof r ? r + a : !1 === r ? "" : null != n.path && n.path.length > 0 ? getBasename(n.path).replace(/[. ]/g, "_") + a : "prefix" + a }, fn$d = (e, t, n) => { const { delim: r = "__", prefix: a, prefixIds: o = !0, prefixClassNames: i = !0 } = t, s = new Map; return { element: { enter: e => { const t = t => generatePrefix(t, e, n, a, r, s); if ("style" === e.name) { if (0 === e.children.length) return; for (const n of e.children) { if ("text" !== n.type && "cdata" !== n.type) continue; const e = n.value; let r; try { r = parse$I(e, { parseValue: !0, parseCustomProperty: !1 }) } catch { return } walk$3(r, (e => { var n; if (o && "IdSelector" === e.type || i && "ClassSelector" === e.type) e.name = prefixId(t, e.name); else if ("Url" === e.type && e.value.length > 0) { const r = prefixReference(t, (n = e.value).startsWith('"') && n.endsWith('"') || n.startsWith("'") && n.endsWith("'") ? n.slice(1, -1) : n); null != r && (e.value = r) } })), n.value = generate$I(r) } } o && null != e.attributes.id && 0 !== e.attributes.id.length && (e.attributes.id = prefixId(t, e.attributes.id)), i && null != e.attributes.class && 0 !== e.attributes.class.length && (e.attributes.class = e.attributes.class.split(/\s+/).map((e => prefixId(t, e))).join(" ")); for (const n of ["href", "xlink:href"]) if (null != e.attributes[n] && 0 !== e.attributes[n].length) { const r = prefixReference(t, e.attributes[n]); null != r && (e.attributes[n] = r) } for (const n of referencesProps) null != e.attributes[n] && 0 !== e.attributes[n].length && (e.attributes[n] = e.attributes[n].replace(/\burl\((["'])?(#.+?)\1\)/gi, ((e, n, r) => { const a = prefixReference(t, r); return null == a ? e : `url(${a})` }))); for (const n of ["begin", "end"]) if (null != e.attributes[n] && 0 !== e.attributes[n].length) { const r = e.attributes[n].split(/\s*;\s+/).map((e => { if (e.endsWith(".end") || e.endsWith(".start")) { const [n, r] = e.split("."); return `${prefixId(t, n)}.${r}` } return e })); e.attributes[n] = r.join("; ") } } } } }; var prefixIds = Object.freeze({ __proto__: null, description: "prefix IDs", fn: fn$d, name: name$d }); const name$c = "removeAttributesBySelector", description$c = "removes attributes of elements that match a css selector", fn$c = (e, t) => { const n = Array.isArray(t.selectors) ? t.selectors : [t]; for (const { selector: t, attributes: r } of n) { const n = querySelectorAll(e, t); for (const e of n) if ("element" === e.type) if (Array.isArray(r)) for (const t of r) delete e.attributes[t]; else delete e.attributes[r] } return {} }; var removeAttributesBySelector = Object.freeze({ __proto__: null, description: description$c, fn: fn$c, name: name$c }); const name$b = "removeAttrs", description$b = "removes specified attributes", DEFAULT_SEPARATOR = ":", ENOATTRS = 'Warning: The plugin "removeAttrs" requires the "attrs" parameter.\nIt should have a pattern to remove, otherwise the plugin is a noop.\nConfig example:\n\nplugins: [\n  {\n    name: "removeAttrs",\n    params: {\n      attrs: "(fill|stroke)"\n    }\n  }\n]\n', fn$b = (e, t) => { if (void 0 === t.attrs) return console.warn(ENOATTRS), null; const n = "string" == typeof t.elemSeparator ? t.elemSeparator : ":", r = "boolean" == typeof t.preserveCurrentColor && t.preserveCurrentColor, a = Array.isArray(t.attrs) ? t.attrs : [t.attrs]; return { element: { enter: e => { for (let t of a) { t.includes(n) ? t.split(n).length < 3 && (t = [t, ".*"].join(n)) : t = [".*", t, ".*"].join(n); const a = t.split(n).map((e => ("*" === e && (e = ".*"), new RegExp(["^", e, "$"].join(""), "i")))); if (a[0].test(e.name)) for (const [t, n] of Object.entries(e.attributes)) { const o = "currentcolor" === n.toLowerCase(); !(r && "fill" == t && o) && !(r && "stroke" == t && o) && a[1].test(t) && a[2].test(n) && delete e.attributes[t] } } } } } }; var removeAttrs = Object.freeze({ __proto__: null, description: description$b, fn: fn$b, name: name$b }); const name$a = "removeDimensions", description$a = "removes width and height in presence of viewBox (opposite to removeViewBox)", fn$a = () => ({ element: { enter: e => { if ("svg" === e.name) if (null != e.attributes.viewBox) delete e.attributes.width, delete e.attributes.height; else if (null != e.attributes.width && null != e.attributes.height && !1 === Number.isNaN(Number(e.attributes.width)) && !1 === Number.isNaN(Number(e.attributes.height))) { const t = Number(e.attributes.width), n = Number(e.attributes.height); e.attributes.viewBox = `0 0 ${t} ${n}`, delete e.attributes.width, delete e.attributes.height } } } }); var removeDimensions = Object.freeze({ __proto__: null, description: description$a, fn: fn$a, name: name$a }); const name$9 = "removeElementsByAttr", description$9 = "removes arbitrary elements by ID or className (disabled by default)", fn$9 = (e, t) => { const n = null == t.id ? [] : Array.isArray(t.id) ? t.id : [t.id], r = null == t.class ? [] : Array.isArray(t.class) ? t.class : [t.class]; return { element: { enter: (e, t) => { if (null != e.attributes.id && 0 !== n.length && n.includes(e.attributes.id) && detachNodeFromParent(e, t), e.attributes.class && 0 !== r.length) { const n = e.attributes.class.split(" "); for (const a of r) if (n.includes(a)) { detachNodeFromParent(e, t); break } } } } } }; var removeElementsByAttr = Object.freeze({ __proto__: null, description: description$9, fn: fn$9, name: name$9 }); const name$8 = "removeOffCanvasPaths", description$8 = "removes elements that are drawn outside of the viewBox (disabled by default)", fn$8 = () => { let e = null; return { element: { enter: (t, n) => { if ("svg" === t.name && "root" === n.type) { let n = ""; null != t.attributes.viewBox ? n = t.attributes.viewBox : null != t.attributes.height && null != t.attributes.width && (n = `0 0 ${t.attributes.width} ${t.attributes.height}`), n = n.replace(/[,+]|px/g, " ").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, ""); const r = /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(n); if (null == r) return; const a = Number.parseFloat(r[1]), o = Number.parseFloat(r[2]), i = Number.parseFloat(r[3]), s = Number.parseFloat(r[4]); e = { left: a, top: o, right: a + i, bottom: o + s, width: i, height: s } } if (null != t.attributes.transform) return visitSkip; if ("path" === t.name && null != t.attributes.d && null != e) { const r = parsePathData(t.attributes.d); let a = !1; for (const t of r) if ("M" === t.command) { const [n, r] = t.args; n >= e.left && n <= e.right && r >= e.top && r <= e.bottom && (a = !0) } if (a) return; 2 === r.length && r.push({ command: "z", args: [] }); const { left: o, top: i, width: s, height: l } = e; !1 === intersects([{ command: "M", args: [o, i] }, { command: "h", args: [s] }, { command: "v", args: [l] }, { command: "H", args: [o] }, { command: "z", args: [] }], r) && detachNodeFromParent(t, n) } } } } }; var removeOffCanvasPaths = Object.freeze({ __proto__: null, description: description$8, fn: fn$8, name: name$8 }); const name$7 = "removeRasterImages", description$7 = "removes raster images (disabled by default)", fn$7 = () => ({ element: { enter: (e, t) => { "image" === e.name && null != e.attributes["xlink:href"] && /(\.|image\/)(jpe?g|png|gif)/.test(e.attributes["xlink:href"]) && detachNodeFromParent(e, t) } } }); var removeRasterImages = Object.freeze({ __proto__: null, description: description$7, fn: fn$7, name: name$7 }); const name$6 = "removeScripts", description$6 = "removes scripts (disabled by default)", eventAttrs = [...attrsGroups.animationEvent, ...attrsGroups.documentEvent, ...attrsGroups.documentElementEvent, ...attrsGroups.globalEvent, ...attrsGroups.graphicalEvent], fn$6 = () => ({ element: { enter: (e, t) => { if ("script" !== e.name) for (const t of eventAttrs) null != e.attributes[t] && delete e.attributes[t]; else detachNodeFromParent(e, t) }, exit: (e, t) => { if ("a" === e.name) for (const n of Object.keys(e.attributes)) if ("href" === n || n.endsWith(":href")) { if (null == e.attributes[n] || !e.attributes[n].trimStart().startsWith("javascript:")) continue; const r = t.children.indexOf(e), a = e.children.filter((e => "text" !== e.type)); t.children.splice(r, 1, ...a) } } } }); var removeScripts = Object.freeze({ __proto__: null, description: description$6, fn: fn$6, name: name$6 }); const name$5 = "removeStyleElement", description$5 = "removes <style> element (disabled by default)", fn$5 = () => ({ element: { enter: (e, t) => { "style" === e.name && detachNodeFromParent(e, t) } } }); var removeStyleElement = Object.freeze({ __proto__: null, description: description$5, fn: fn$5, name: name$5 }); const name$4 = "removeTitle", description$4 = "removes <title>", fn$4 = () => ({ element: { enter: (e, t) => { "title" === e.name && detachNodeFromParent(e, t) } } }); var removeTitle = Object.freeze({ __proto__: null, description: description$4, fn: fn$4, name: name$4 }); const name$3 = "removeViewBox", description$3 = "removes viewBox attribute when possible", viewBoxElems = new Set(["pattern", "svg", "symbol"]), fn$3 = () => ({ element: { enter: (e, t) => { if (viewBoxElems.has(e.name) && null != e.attributes.viewBox && null != e.attributes.width && null != e.attributes.height) { if ("svg" === e.name && "root" !== t.type) return; const n = e.attributes.viewBox.split(/[ ,]+/g); "0" === n[0] && "0" === n[1] && e.attributes.width.replace(/px$/, "") === n[2] && e.attributes.height.replace(/px$/, "") === n[3] && delete e.attributes.viewBox } } } }); var removeViewBox = Object.freeze({ __proto__: null, description: description$3, fn: fn$3, name: name$3 }); const name$2 = "removeXlink", description$2 = "remove xlink namespace and replaces attributes with the SVG 2 equivalent where applicable", XLINK_NAMESPACE = "http://www.w3.org/1999/xlink", SHOW_TO_TARGET = { new: "_blank", replace: "_self" }, LEGACY_ELEMENTS = new Set(["cursor", "filter", "font-face-uri", "glyphRef", "tref"]), findPrefixedAttrs = (e, t, n) => t.map((e => `${e}:${n}`)).filter((t => null != e.attributes[t])), fn$2 = (e, t) => { const { includeLegacy: n } = t, r = [], a = [], o = []; return { element: { enter: e => { for (const [t, n] of Object.entries(e.attributes)) if (t.startsWith("xmlns:")) { const e = t.split(":", 2)[1]; if (n === XLINK_NAMESPACE) { r.push(e); continue } r.includes(e) && a.push(e) } if (a.some((e => r.includes(e)))) return; const t = findPrefixedAttrs(e, r, "show"); let i = null != e.attributes.target; for (let n = t.length - 1; n >= 0; n--) { const r = t[n], a = e.attributes[r], o = SHOW_TO_TARGET[a]; i || null == o ? delete e.attributes[r] : (o !== elems[e.name]?.defaults?.target && (e.attributes.target = o), delete e.attributes[r], i = !0) } const s = findPrefixedAttrs(e, r, "title"); for (let t = s.length - 1; t >= 0; t--) { const n = s[t], r = e.attributes[n]; if (e.children.filter((e => "element" === e.type && "title" === e.name)).length > 0) { delete e.attributes[n]; continue } const a = { type: "element", name: "title", attributes: {}, children: [{ type: "text", value: r }] }; Object.defineProperty(a, "parentNode", { writable: !0, value: e }), e.children.unshift(a), delete e.attributes[n] } const l = findPrefixedAttrs(e, r, "href"); if (l.length > 0 && LEGACY_ELEMENTS.has(e.name) && !n) l.map((e => e.split(":", 1)[0])).forEach((e => o.push(e))); else for (let t = l.length - 1; t >= 0; t--) { const n = l[t], r = e.attributes[n]; null == e.attributes.href ? (e.attributes.href = r, delete e.attributes[n]) : delete e.attributes[n] } }, exit: e => { for (const [t, i] of Object.entries(e.attributes)) { const [s, l] = t.split(":", 2); if (!r.includes(s) || a.includes(s) || o.includes(s) || n) { if (t.startsWith("xmlns:") && !o.includes(l)) { if (i === XLINK_NAMESPACE) { const n = r.indexOf(l); r.splice(n, 1), delete e.attributes[t]; continue } if (a.includes(s)) { const e = a.indexOf(l); a.splice(e, 1) } } } else delete e.attributes[t] } } } } }; var removeXlink = Object.freeze({ __proto__: null, description: description$2, fn: fn$2, name: name$2 }); const name$1 = "removeXMLNS", description$1 = "removes xmlns attribute (for inline svg, disabled by default)", fn$1 = () => ({ element: { enter: e => { "svg" === e.name && delete e.attributes.xmlns } } }); var removeXMLNS = Object.freeze({ __proto__: null, description: description$1, fn: fn$1, name: name$1 }); const name = "reusePaths", description = "Finds <path> elements with the same d, fill, and stroke, and converts them to <use> elements referencing a single <path> def.", fn = e => { const t = collectStylesheet(e), n = new Map; let r; const a = new Set; return { element: { enter: (e, t) => { if ("path" === e.name && null != e.attributes.d) { const t = e.attributes.d, r = e.attributes.fill || "", a = t + ";s:" + (e.attributes.stroke || "") + ";f:" + r; let o = n.get(a); null == o && (o = [], n.set(a, o)), o.push(e) } if (null == r && "defs" === e.name && "element" === t.type && "svg" === t.name && (r = e), "use" === e.name) for (const t of ["href", "xlink:href"]) { const n = e.attributes[t]; null != n && n.startsWith("#") && n.length > 1 && a.add(n.slice(1)) } }, exit: (e, o) => { if ("svg" === e.name && "root" === o.type) { let o = r; null == o && (o = { type: "element", name: "defs", attributes: {}, children: [] }); let i = 0; for (const r of n.values()) if (r.length > 1) { const n = { type: "element", name: "path", attributes: {}, children: [] }; for (const e of ["fill", "stroke", "d"]) null != r[0].attributes[e] && (n.attributes[e] = r[0].attributes[e]); const s = r[0].attributes.id; null == s || a.has(s) || t.rules.some((e => e.selector === `#${s}`)) ? n.attributes.id = "reuse-" + i++ : (n.attributes.id = s, delete r[0].attributes.id), o.children.push(n); for (const t of r) { if (delete t.attributes.d, delete t.attributes.stroke, delete t.attributes.fill, o.children.includes(t) && 0 === t.children.length) { if (0 === Object.keys(t.attributes).length) { detachNodeFromParent(t, o); continue } if (1 === Object.keys(t.attributes).length && null != t.attributes.id) { detachNodeFromParent(t, o); const r = `[xlink\\:href=#${t.attributes.id}], [href=#${t.attributes.id}]`; for (const t of querySelectorAll(e, r)) if ("element" === t.type) for (const e of ["href", "xlink:href"]) null != t.attributes[e] && (t.attributes[e] = "#" + n.attributes.id); continue } } t.name = "use", t.attributes["xlink:href"] = "#" + n.attributes.id } } 0 !== o.children.length && (null == e.attributes["xmlns:xlink"] && (e.attributes["xmlns:xlink"] = "http://www.w3.org/1999/xlink"), null == r && e.children.unshift(o)) } } } } }; var reusePaths = Object.freeze({ __proto__: null, description: description, fn: fn, name: name }); const builtinPlugins = Object.freeze([presetDefault, addAttributesToSVGElement, addClassesToSVGElement, cleanupAttrs, cleanupEnableBackground, cleanupIds, cleanupListOfValues, cleanupNumericValues, collapseGroups, convertColors, convertEllipseToCircle, convertOneStopGradients, convertPathData, convertShapeToPath, convertStyleToAttrs, convertTransform$1, inlineStyles, mergePaths, mergeStyles, minifyStyles, moveElemsAttrsToGroup, moveGroupAttrsToElems, prefixIds, removeAttributesBySelector, removeAttrs, removeComments, removeDeprecatedAttrs, removeDesc, removeDimensions, removeDoctype, removeEditorsNSData, removeElementsByAttr, removeEmptyAttrs, removeEmptyContainers, removeEmptyText, removeHiddenElems, removeMetadata, removeNonInheritableGroupAttrs, removeOffCanvasPaths, removeRasterImages, removeScripts, removeStyleElement, removeTitle, removeUnknownsAndDefaults, removeUnusedNS, removeUselessDefs, removeUselessStrokeAndFill, removeViewBox, removeXlink, removeXMLNS, removeXMLProcInst, reusePaths, sortAttrs, sortDefsChildren]); var sax = {}; !function (e) { e.parser = function (e, t) { return new n(e, t) }, e.SAXParser = n, e.MAX_BUFFER_LENGTH = 65536; var t = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"]; function n(r, a) { if (!(this instanceof n)) return new n(r, a); var o = this; !function (e) { for (var n = 0, r = t.length; n < r; n++)e[t[n]] = "" }(o), o.q = o.c = "", o.bufferCheckPosition = e.MAX_BUFFER_LENGTH, o.opt = a || {}, o.opt.lowercase = o.opt.lowercase || o.opt.lowercasetags, o.looseCase = o.opt.lowercase ? "toLowerCase" : "toUpperCase", o.tags = [], o.closed = o.closedRoot = o.sawRoot = !1, o.tag = o.error = null, o.strict = !!r, o.noscript = !(!r && !o.opt.noscript), o.state = k.BEGIN, o.strictEntities = o.opt.strictEntities, o.ENTITIES = o.strictEntities ? Object.create(e.XML_ENTITIES) : Object.create(e.ENTITIES), o.attribList = [], o.opt.xmlns && (o.ns = Object.create(s)), void 0 === o.opt.unquotedAttributeValues && (o.opt.unquotedAttributeValues = !r), o.trackPosition = !1 !== o.opt.position, o.trackPosition && (o.position = o.line = o.column = 0), v(o, "onready") } e.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"], Object.create || (Object.create = function (e) { function t() { } return t.prototype = e, new t }), Object.keys || (Object.keys = function (e) { var t = []; for (var n in e) e.hasOwnProperty(n) && t.push(n); return t }), n.prototype = { end: function () { T(this) }, write: function (n) { var o = this; if (this.error) throw this.error; if (o.closed) return A(o, "Cannot write after close. Assign an onready handler."); if (null === n) return T(o); "object" == typeof n && (n = n.toString()); for (var i = 0, s = ""; s = _(n, i++), o.c = s, s;)switch (o.trackPosition && (o.position++, "\n" === s ? (o.line++, o.column = 0) : o.column++), o.state) { case k.BEGIN: if (o.state = k.BEGIN_WHITESPACE, "\ufeff" === s) continue; M(o, s); continue; case k.BEGIN_WHITESPACE: M(o, s); continue; case k.TEXT: if (o.sawRoot && !o.closedRoot) { for (var b = i - 1; s && "<" !== s && "&" !== s;)(s = _(n, i++)) && o.trackPosition && (o.position++, "\n" === s ? (o.line++, o.column = 0) : o.column++); o.textNode += n.substring(b, i - 1) } "<" !== s || o.sawRoot && o.closedRoot && !o.strict ? (p(s) || o.sawRoot && !o.closedRoot || E(o, "Text data outside of root node."), "&" === s ? o.state = k.TEXT_ENTITY : o.textNode += s) : (o.state = k.OPEN_WAKA, o.startTagPosition = o.position); continue; case k.SCRIPT: "<" === s ? o.state = k.SCRIPT_ENDING : o.script += s; continue; case k.SCRIPT_ENDING: "/" === s ? o.state = k.CLOSE_TAG : (o.script += "<" + s, o.state = k.SCRIPT); continue; case k.OPEN_WAKA: if ("!" === s) o.state = k.SGML_DECL, o.sgmlDecl = ""; else if (p(s)); else if (f(l, s)) o.state = k.OPEN_TAG, o.tagName = s; else if ("/" === s) o.state = k.CLOSE_TAG, o.tagName = ""; else if ("?" === s) o.state = k.PROC_INST, o.procInstName = o.procInstBody = ""; else { if (E(o, "Unencoded <"), o.startTagPosition + 1 < o.position) { var y = o.position - o.startTagPosition; s = new Array(y).join(" ") + s } o.textNode += "<" + s, o.state = k.TEXT } continue; case k.SGML_DECL: if (o.sgmlDecl + s === "--") { o.state = k.COMMENT, o.comment = "", o.sgmlDecl = ""; continue } o.doctype && !0 !== o.doctype && o.sgmlDecl ? (o.state = k.DOCTYPE_DTD, o.doctype += "<!" + o.sgmlDecl + s, o.sgmlDecl = "") : (o.sgmlDecl + s).toUpperCase() === r ? (w(o, "onopencdata"), o.state = k.CDATA, o.sgmlDecl = "", o.cdata = "") : (o.sgmlDecl + s).toUpperCase() === a ? (o.state = k.DOCTYPE, (o.doctype || o.sawRoot) && E(o, "Inappropriately located doctype declaration"), o.doctype = "", o.sgmlDecl = "") : ">" === s ? (w(o, "onsgmldeclaration", o.sgmlDecl), o.sgmlDecl = "", o.state = k.TEXT) : h(s) ? (o.state = k.SGML_DECL_QUOTED, o.sgmlDecl += s) : o.sgmlDecl += s; continue; case k.SGML_DECL_QUOTED: s === o.q && (o.state = k.SGML_DECL, o.q = ""), o.sgmlDecl += s; continue; case k.DOCTYPE: ">" === s ? (o.state = k.TEXT, w(o, "ondoctype", o.doctype), o.doctype = !0) : (o.doctype += s, "[" === s ? o.state = k.DOCTYPE_DTD : h(s) && (o.state = k.DOCTYPE_QUOTED, o.q = s)); continue; case k.DOCTYPE_QUOTED: o.doctype += s, s === o.q && (o.q = "", o.state = k.DOCTYPE); continue; case k.DOCTYPE_DTD: "]" === s ? (o.doctype += s, o.state = k.DOCTYPE) : "<" === s ? (o.state = k.OPEN_WAKA, o.startTagPosition = o.position) : h(s) ? (o.doctype += s, o.state = k.DOCTYPE_DTD_QUOTED, o.q = s) : o.doctype += s; continue; case k.DOCTYPE_DTD_QUOTED: o.doctype += s, s === o.q && (o.state = k.DOCTYPE_DTD, o.q = ""); continue; case k.COMMENT: "-" === s ? o.state = k.COMMENT_ENDING : o.comment += s; continue; case k.COMMENT_ENDING: "-" === s ? (o.state = k.COMMENT_ENDED, o.comment = C(o.opt, o.comment), o.comment && w(o, "oncomment", o.comment), o.comment = "") : (o.comment += "-" + s, o.state = k.COMMENT); continue; case k.COMMENT_ENDED: ">" !== s ? (E(o, "Malformed comment"), o.comment += "--" + s, o.state = k.COMMENT) : o.doctype && !0 !== o.doctype ? o.state = k.DOCTYPE_DTD : o.state = k.TEXT; continue; case k.CDATA: "]" === s ? o.state = k.CDATA_ENDING : o.cdata += s; continue; case k.CDATA_ENDING: "]" === s ? o.state = k.CDATA_ENDING_2 : (o.cdata += "]" + s, o.state = k.CDATA); continue; case k.CDATA_ENDING_2: ">" === s ? (o.cdata && w(o, "oncdata", o.cdata), w(o, "onclosecdata"), o.cdata = "", o.state = k.TEXT) : "]" === s ? o.cdata += "]" : (o.cdata += "]]" + s, o.state = k.CDATA); continue; case k.PROC_INST: "?" === s ? o.state = k.PROC_INST_ENDING : p(s) ? o.state = k.PROC_INST_BODY : o.procInstName += s; continue; case k.PROC_INST_BODY: if (!o.procInstBody && p(s)) continue; "?" === s ? o.state = k.PROC_INST_ENDING : o.procInstBody += s; continue; case k.PROC_INST_ENDING: ">" === s ? (w(o, "onprocessinginstruction", { name: o.procInstName, body: o.procInstBody }), o.procInstName = o.procInstBody = "", o.state = k.TEXT) : (o.procInstBody += "?" + s, o.state = k.PROC_INST_BODY); continue; case k.OPEN_TAG: f(c, s) ? o.tagName += s : (N(o), ">" === s ? L(o) : "/" === s ? o.state = k.OPEN_TAG_SLASH : (p(s) || E(o, "Invalid character in tag name"), o.state = k.ATTRIB)); continue; case k.OPEN_TAG_SLASH: ">" === s ? (L(o, !0), O(o)) : (E(o, "Forward-slash in opening tag not followed by >"), o.state = k.ATTRIB); continue; case k.ATTRIB: if (p(s)) continue; ">" === s ? L(o) : "/" === s ? o.state = k.OPEN_TAG_SLASH : f(l, s) ? (o.attribName = s, o.attribValue = "", o.state = k.ATTRIB_NAME) : E(o, "Invalid attribute name"); continue; case k.ATTRIB_NAME: "=" === s ? o.state = k.ATTRIB_VALUE : ">" === s ? (E(o, "Attribute without value"), o.attribValue = o.attribName, P(o), L(o)) : p(s) ? o.state = k.ATTRIB_NAME_SAW_WHITE : f(c, s) ? o.attribName += s : E(o, "Invalid attribute name"); continue; case k.ATTRIB_NAME_SAW_WHITE: if ("=" === s) o.state = k.ATTRIB_VALUE; else { if (p(s)) continue; E(o, "Attribute without value"), o.tag.attributes[o.attribName] = "", o.attribValue = "", w(o, "onattribute", { name: o.attribName, value: "" }), o.attribName = "", ">" === s ? L(o) : f(l, s) ? (o.attribName = s, o.state = k.ATTRIB_NAME) : (E(o, "Invalid attribute name"), o.state = k.ATTRIB) } continue; case k.ATTRIB_VALUE: if (p(s)) continue; h(s) ? (o.q = s, o.state = k.ATTRIB_VALUE_QUOTED) : (o.opt.unquotedAttributeValues || A(o, "Unquoted attribute value"), o.state = k.ATTRIB_VALUE_UNQUOTED, o.attribValue = s); continue; case k.ATTRIB_VALUE_QUOTED: if (s !== o.q) { "&" === s ? o.state = k.ATTRIB_VALUE_ENTITY_Q : o.attribValue += s; continue } P(o), o.q = "", o.state = k.ATTRIB_VALUE_CLOSED; continue; case k.ATTRIB_VALUE_CLOSED: p(s) ? o.state = k.ATTRIB : ">" === s ? L(o) : "/" === s ? o.state = k.OPEN_TAG_SLASH : f(l, s) ? (E(o, "No whitespace between attributes"), o.attribName = s, o.attribValue = "", o.state = k.ATTRIB_NAME) : E(o, "Invalid attribute name"); continue; case k.ATTRIB_VALUE_UNQUOTED: if (!m(s)) { "&" === s ? o.state = k.ATTRIB_VALUE_ENTITY_U : o.attribValue += s; continue } P(o), ">" === s ? L(o) : o.state = k.ATTRIB; continue; case k.CLOSE_TAG: if (o.tagName) ">" === s ? O(o) : f(c, s) ? o.tagName += s : o.script ? (o.script += "</" + o.tagName, o.tagName = "", o.state = k.SCRIPT) : (p(s) || E(o, "Invalid tagname in closing tag"), o.state = k.CLOSE_TAG_SAW_WHITE); else { if (p(s)) continue; g(l, s) ? o.script ? (o.script += "</" + s, o.state = k.SCRIPT) : E(o, "Invalid tagname in closing tag.") : o.tagName = s } continue; case k.CLOSE_TAG_SAW_WHITE: if (p(s)) continue; ">" === s ? O(o) : E(o, "Invalid characters in closing tag"); continue; case k.TEXT_ENTITY: case k.ATTRIB_VALUE_ENTITY_Q: case k.ATTRIB_VALUE_ENTITY_U: var $, S; switch (o.state) { case k.TEXT_ENTITY: $ = k.TEXT, S = "textNode"; break; case k.ATTRIB_VALUE_ENTITY_Q: $ = k.ATTRIB_VALUE_QUOTED, S = "attribValue"; break; case k.ATTRIB_VALUE_ENTITY_U: $ = k.ATTRIB_VALUE_UNQUOTED, S = "attribValue" }if (";" === s) { var v = R(o); o.opt.unparsedEntities && !Object.values(e.XML_ENTITIES).includes(v) ? (o.entity = "", o.state = $, o.write(v)) : (o[S] += v, o.entity = "", o.state = $) } else f(o.entity.length ? d : u, s) ? o.entity += s : (E(o, "Invalid character in entity name"), o[S] += "&" + o.entity + s, o.entity = "", o.state = $); continue; default: throw new Error(o, "Unknown state: " + o.state) }return o.position >= o.bufferCheckPosition && function (n) { for (var r = Math.max(e.MAX_BUFFER_LENGTH, 10), a = 0, o = 0, i = t.length; o < i; o++) { var s = n[t[o]].length; if (s > r) switch (t[o]) { case "textNode": x(n); break; case "cdata": w(n, "oncdata", n.cdata), n.cdata = ""; break; case "script": w(n, "onscript", n.script), n.script = ""; break; default: A(n, "Max buffer length exceeded: " + t[o]) }a = Math.max(a, s) } var l = e.MAX_BUFFER_LENGTH - a; n.bufferCheckPosition = l + n.position }(o), o }, resume: function () { return this.error = null, this }, close: function () { return this.write(null) }, flush: function () { var e; x(e = this), "" !== e.cdata && (w(e, "oncdata", e.cdata), e.cdata = ""), "" !== e.script && (w(e, "onscript", e.script), e.script = "") } }; var r = "[CDATA[", a = "DOCTYPE", o = "http://www.w3.org/XML/1998/namespace", i = "http://www.w3.org/2000/xmlns/", s = { xml: o, xmlns: i }, l = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, c = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, u = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, d = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/; function p(e) { return " " === e || "\n" === e || "\r" === e || "\t" === e } function h(e) { return '"' === e || "'" === e } function m(e) { return ">" === e || p(e) } function f(e, t) { return e.test(t) } function g(e, t) { return !f(e, t) } var b, y, $, k = 0; for (var S in e.STATE = { BEGIN: k++, BEGIN_WHITESPACE: k++, TEXT: k++, TEXT_ENTITY: k++, OPEN_WAKA: k++, SGML_DECL: k++, SGML_DECL_QUOTED: k++, DOCTYPE: k++, DOCTYPE_QUOTED: k++, DOCTYPE_DTD: k++, DOCTYPE_DTD_QUOTED: k++, COMMENT_STARTING: k++, COMMENT: k++, COMMENT_ENDING: k++, COMMENT_ENDED: k++, CDATA: k++, CDATA_ENDING: k++, CDATA_ENDING_2: k++, PROC_INST: k++, PROC_INST_BODY: k++, PROC_INST_ENDING: k++, OPEN_TAG: k++, OPEN_TAG_SLASH: k++, ATTRIB: k++, ATTRIB_NAME: k++, ATTRIB_NAME_SAW_WHITE: k++, ATTRIB_VALUE: k++, ATTRIB_VALUE_QUOTED: k++, ATTRIB_VALUE_CLOSED: k++, ATTRIB_VALUE_UNQUOTED: k++, ATTRIB_VALUE_ENTITY_Q: k++, ATTRIB_VALUE_ENTITY_U: k++, CLOSE_TAG: k++, CLOSE_TAG_SAW_WHITE: k++, SCRIPT: k++, SCRIPT_ENDING: k++ }, e.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }, e.ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'", AElig: 198, Aacute: 193, Acirc: 194, Agrave: 192, Aring: 197, Atilde: 195, Auml: 196, Ccedil: 199, ETH: 208, Eacute: 201, Ecirc: 202, Egrave: 200, Euml: 203, Iacute: 205, Icirc: 206, Igrave: 204, Iuml: 207, Ntilde: 209, Oacute: 211, Ocirc: 212, Ograve: 210, Oslash: 216, Otilde: 213, Ouml: 214, THORN: 222, Uacute: 218, Ucirc: 219, Ugrave: 217, Uuml: 220, Yacute: 221, aacute: 225, acirc: 226, aelig: 230, agrave: 224, aring: 229, atilde: 227, auml: 228, ccedil: 231, eacute: 233, ecirc: 234, egrave: 232, eth: 240, euml: 235, iacute: 237, icirc: 238, igrave: 236, iuml: 239, ntilde: 241, oacute: 243, ocirc: 244, ograve: 242, oslash: 248, otilde: 245, ouml: 246, szlig: 223, thorn: 254, uacute: 250, ucirc: 251, ugrave: 249, uuml: 252, yacute: 253, yuml: 255, copy: 169, reg: 174, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, deg: 176, plusmn: 177, sup1: 185, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, times: 215, divide: 247, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 }, Object.keys(e.ENTITIES).forEach((function (t) { var n = e.ENTITIES[t], r = "number" == typeof n ? String.fromCharCode(n) : n; e.ENTITIES[t] = r })), e.STATE) e.STATE[e.STATE[S]] = S; function v(e, t, n) { e[t] && e[t](n) } function w(e, t, n) { e.textNode && x(e), v(e, t, n) } function x(e) { e.textNode = C(e.opt, e.textNode), e.textNode && v(e, "ontext", e.textNode), e.textNode = "" } function C(e, t) { return e.trim && (t = t.trim()), e.normalize && (t = t.replace(/\s+/g, " ")), t } function A(e, t) { return x(e), e.trackPosition && (t += "\nLine: " + e.line + "\nColumn: " + e.column + "\nChar: " + e.c), t = new Error(t), e.error = t, v(e, "onerror", t), e } function T(e) { return e.sawRoot && !e.closedRoot && E(e, "Unclosed root tag"), e.state !== k.BEGIN && e.state !== k.BEGIN_WHITESPACE && e.state !== k.TEXT && A(e, "Unexpected end"), x(e), e.c = "", e.closed = !0, v(e, "onend"), n.call(e, e.strict, e.opt), e } function E(e, t) { if ("object" != typeof e || !(e instanceof n)) throw new Error("bad call to strictFail"); e.strict && A(e, t) } function N(e) { e.strict || (e.tagName = e.tagName[e.looseCase]()); var t = e.tags[e.tags.length - 1] || e, n = e.tag = { name: e.tagName, attributes: {} }; e.opt.xmlns && (n.ns = t.ns), e.attribList.length = 0, w(e, "onopentagstart", n) } function I(e, t) { var n = e.indexOf(":") < 0 ? ["", e] : e.split(":"), r = n[0], a = n[1]; return t && "xmlns" === e && (r = "xmlns", a = ""), { prefix: r, local: a } } function P(e) { if (e.strict || (e.attribName = e.attribName[e.looseCase]()), -1 !== e.attribList.indexOf(e.attribName) || e.tag.attributes.hasOwnProperty(e.attribName)) e.attribName = e.attribValue = ""; else { if (e.opt.xmlns) { var t = I(e.attribName, !0), n = t.prefix, r = t.local; if ("xmlns" === n) if ("xml" === r && e.attribValue !== o) E(e, "xml: prefix must be bound to " + o + "\nActual: " + e.attribValue); else if ("xmlns" === r && e.attribValue !== i) E(e, "xmlns: prefix must be bound to " + i + "\nActual: " + e.attribValue); else { var a = e.tag, s = e.tags[e.tags.length - 1] || e; a.ns === s.ns && (a.ns = Object.create(s.ns)), a.ns[r] = e.attribValue } e.attribList.push([e.attribName, e.attribValue]) } else e.tag.attributes[e.attribName] = e.attribValue, w(e, "onattribute", { name: e.attribName, value: e.attribValue }); e.attribName = e.attribValue = "" } } function L(e, t) { if (e.opt.xmlns) { var n = e.tag, r = I(e.tagName); n.prefix = r.prefix, n.local = r.local, n.uri = n.ns[r.prefix] || "", n.prefix && !n.uri && (E(e, "Unbound namespace prefix: " + JSON.stringify(e.tagName)), n.uri = r.prefix); var a = e.tags[e.tags.length - 1] || e; n.ns && a.ns !== n.ns && Object.keys(n.ns).forEach((function (t) { w(e, "onopennamespace", { prefix: t, uri: n.ns[t] }) })); for (var o = 0, i = e.attribList.length; o < i; o++) { var s = e.attribList[o], l = s[0], c = s[1], u = I(l, !0), d = u.prefix, p = u.local, h = "" === d ? "" : n.ns[d] || "", m = { name: l, value: c, prefix: d, local: p, uri: h }; d && "xmlns" !== d && !h && (E(e, "Unbound namespace prefix: " + JSON.stringify(d)), m.uri = d), e.tag.attributes[l] = m, w(e, "onattribute", m) } e.attribList.length = 0 } e.tag.isSelfClosing = !!t, e.sawRoot = !0, e.tags.push(e.tag), w(e, "onopentag", e.tag), t || (e.noscript || "script" !== e.tagName.toLowerCase() ? e.state = k.TEXT : e.state = k.SCRIPT, e.tag = null, e.tagName = ""), e.attribName = e.attribValue = "", e.attribList.length = 0 } function O(e) { if (!e.tagName) return E(e, "Weird empty close tag."), e.textNode += "</>", void (e.state = k.TEXT); if (e.script) { if ("script" !== e.tagName) return e.script += "</" + e.tagName + ">", e.tagName = "", void (e.state = k.SCRIPT); w(e, "onscript", e.script), e.script = "" } var t = e.tags.length, n = e.tagName; e.strict || (n = n[e.looseCase]()); for (var r = n; t-- && e.tags[t].name !== r;)E(e, "Unexpected close tag"); if (t < 0) return E(e, "Unmatched closing tag: " + e.tagName), e.textNode += "</" + e.tagName + ">", void (e.state = k.TEXT); e.tagName = n; for (var a = e.tags.length; a-- > t;) { var o = e.tag = e.tags.pop(); e.tagName = e.tag.name, w(e, "onclosetag", e.tagName); var i = {}; for (var s in o.ns) i[s] = o.ns[s]; var l = e.tags[e.tags.length - 1] || e; e.opt.xmlns && o.ns !== l.ns && Object.keys(o.ns).forEach((function (t) { var n = o.ns[t]; w(e, "onclosenamespace", { prefix: t, uri: n }) })) } 0 === t && (e.closedRoot = !0), e.tagName = e.attribValue = e.attribName = "", e.attribList.length = 0, e.state = k.TEXT } function R(e) { var t, n = e.entity, r = n.toLowerCase(), a = ""; return e.ENTITIES[n] ? e.ENTITIES[n] : e.ENTITIES[r] ? e.ENTITIES[r] : ("#" === (n = r).charAt(0) && ("x" === n.charAt(1) ? (n = n.slice(2), a = (t = parseInt(n, 16)).toString(16)) : (n = n.slice(1), a = (t = parseInt(n, 10)).toString(10))), n = n.replace(/^0+/, ""), isNaN(t) || a.toLowerCase() !== n ? (E(e, "Invalid character entity"), "&" + e.entity + ";") : String.fromCodePoint(t)) } function M(e, t) { "<" === t ? (e.state = k.OPEN_WAKA, e.startTagPosition = e.position) : p(t) || (E(e, "Non-whitespace before first tag."), e.textNode = t, e.state = k.TEXT) } function _(e, t) { var n = ""; return t < e.length && (n = e.charAt(t)), n } k = e.STATE, String.fromCodePoint || (b = String.fromCharCode, y = Math.floor, $ = function () { var e, t, n = [], r = -1, a = arguments.length; if (!a) return ""; for (var o = ""; ++r < a;) { var i = Number(arguments[r]); if (!isFinite(i) || i < 0 || i > 1114111 || y(i) !== i) throw RangeError("Invalid code point: " + i); i <= 65535 ? n.push(i) : (e = 55296 + ((i -= 65536) >> 10), t = i % 1024 + 56320, n.push(e, t)), (r + 1 === a || n.length > 16384) && (o += b.apply(null, n), n.length = 0) } return o }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", { value: $, configurable: !0, writable: !0 }) : String.fromCodePoint = $) }(sax); var SAX = getDefaultExportFromCjs(sax); class SvgoParserError extends Error { constructor(e, t, n, r, a) { super(e), this.name = "SvgoParserError", this.message = `${a || "<input>"}:${t}:${n}: ${e}`, this.reason = e, this.line = t, this.column = n, this.source = r, Error.captureStackTrace && Error.captureStackTrace(this, SvgoParserError) } toString() { const e = this.source.split(/\r?\n/), t = Math.max(this.line - 3, 0), n = Math.min(this.line + 2, e.length), r = String(n).length, a = Math.max(this.column - 54, 0), o = Math.max(this.column + 20, 80), i = e.slice(t, n).map(((e, n) => { const i = e.slice(a, o); let s = "", l = ""; 0 !== a && (s = a > e.length - 1 ? " " : ""), o < e.length - 1 && (l = ""); const c = t + 1 + n, u = ` ${c.toString().padStart(r)} | `; if (c === this.line) { const t = u.replace(/[^|]/g, " "); return `>${u}${s}${i}${l}\n ${t + (s + e.slice(a, this.column - 1)).replace(/[^\t]/g, " ")}^` } return ` ${u}${s}${i}${l}` })).join("\n"); return `${this.name}: ${this.message}\n\n${i}\n` } } const entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g, config = { strict: !0, trim: !1, normalize: !1, lowercase: !0, xmlns: !0, position: !0, unparsedEntities: !0 }, parseSvg = (e, t) => { const n = SAX.parser(config.strict, config), r = { type: "root", children: [] }; let a = r; const o = [r], i = e => { a.children.push(e) }; return n.ondoctype = t => { i({ type: "doctype", name: "svg", data: { doctype: t } }); const r = t.indexOf("["); if (r >= 0) { entityDeclaration.lastIndex = r; let t = entityDeclaration.exec(e); for (; null != t;)n.ENTITIES[t[1]] = t[2] || t[3], t = entityDeclaration.exec(e) } }, n.onprocessinginstruction = e => { const t = { type: "instruction", name: e.name, value: e.body }; i(t) }, n.oncomment = e => { const t = { type: "comment", value: e.trim() }; i(t) }, n.oncdata = e => { i({ type: "cdata", value: e }) }, n.onopentag = e => { const t = { type: "element", name: e.name, attributes: {}, children: [] }; for (const [n, r] of Object.entries(e.attributes)) t.attributes[n] = r.value; i(t), a = t, o.push(t) }, n.ontext = e => { if ("element" === a.type) if (textElems.has(a.name)) { i({ type: "text", value: e }) } else { const t = e.trim(); if ("" !== t) { i({ type: "text", value: t }) } } }, n.onclosetag = () => { o.pop(), a = o[o.length - 1] }, n.onerror = r => { const a = r.message.split("\n")[0], o = new SvgoParserError(a, n.line + 1, n.column, e, t); if (-1 === r.message.indexOf("Unexpected end")) throw o }, n.write(e).close(), r }, encodeEntity = e => entities[e], defaults = { doctypeStart: "<!DOCTYPE", doctypeEnd: ">", procInstStart: "<?", procInstEnd: "?>", tagOpenStart: "<", tagOpenEnd: ">", tagCloseStart: "</", tagCloseEnd: ">", tagShortStart: "<", tagShortEnd: "/>", attrStart: '="', attrEnd: '"', commentStart: "\x3c!--", commentEnd: "--\x3e", cdataStart: "<![CDATA[", cdataEnd: "]]>", textStart: "", textEnd: "", indent: 4, regEntities: /[&'"<>]/g, regValEntities: /[&"<>]/g, encodeEntity: encodeEntity, pretty: !1, useShortTags: !0, eol: "lf", finalNewline: !1 }, entities = { "&": "&amp;", "'": "&apos;", '"': "&quot;", ">": "&gt;", "<": "&lt;" }, stringifySvg = (e, t = {}) => { const n = { ...defaults, ...t }, r = n.indent; let a = "    "; "number" == typeof r && !1 === Number.isNaN(r) ? a = r < 0 ? "\t" : " ".repeat(r) : "string" == typeof r && (a = r); const o = { indent: a, textContext: null, indentLevel: 0 }, i = "crlf" === n.eol ? "\r\n" : "\n"; n.pretty && (n.doctypeEnd += i, n.procInstEnd += i, n.commentEnd += i, n.cdataEnd += i, n.tagShortEnd += i, n.tagOpenEnd += i, n.tagCloseEnd += i, n.textEnd += i); let s = stringifyNode(e, n, o); return n.finalNewline && s.length > 0 && !s.endsWith("\n") && (s += i), s }, stringifyNode = (e, t, n) => { let r = ""; n.indentLevel++; for (const a of e.children) switch (a.type) { case "element": r += stringifyElement(a, t, n); break; case "text": r += stringifyText(a, t, n); break; case "doctype": r += stringifyDoctype(a, t); break; case "instruction": r += stringifyInstruction(a, t); break; case "comment": r += stringifyComment(a, t); break; case "cdata": r += stringifyCdata(a, t, n) }return n.indentLevel--, r }, createIndent = (e, t) => { let n = ""; return e.pretty && null == t.textContext && (n = t.indent.repeat(t.indentLevel - 1)), n }, stringifyDoctype = (e, t) => t.doctypeStart + e.data.doctype + t.doctypeEnd, stringifyInstruction = (e, t) => t.procInstStart + e.name + " " + e.value + t.procInstEnd, stringifyComment = (e, t) => t.commentStart + e.value + t.commentEnd, stringifyCdata = (e, t, n) => createIndent(t, n) + t.cdataStart + e.value + t.cdataEnd, stringifyElement = (e, t, n) => { if (0 === e.children.length) return t.useShortTags ? createIndent(t, n) + t.tagShortStart + e.name + stringifyAttributes(e, t) + t.tagShortEnd : createIndent(t, n) + t.tagShortStart + e.name + stringifyAttributes(e, t) + t.tagOpenEnd + t.tagCloseStart + e.name + t.tagCloseEnd; let r = t.tagOpenStart, a = t.tagOpenEnd, o = t.tagCloseStart, i = t.tagCloseEnd, s = createIndent(t, n), l = createIndent(t, n); n.textContext ? (r = defaults.tagOpenStart, a = defaults.tagOpenEnd, o = defaults.tagCloseStart, i = defaults.tagCloseEnd, s = "") : textElems.has(e.name) && (a = defaults.tagOpenEnd, o = defaults.tagCloseStart, l = "", n.textContext = e); const c = stringifyNode(e, t, n); return n.textContext === e && (n.textContext = null), s + r + e.name + stringifyAttributes(e, t) + a + c + l + o + e.name + i }, stringifyAttributes = (e, t) => { let n = ""; for (const [r, a] of Object.entries(e.attributes)) if (n += " " + r, void 0 !== a) { const e = a.toString().replace(t.regValEntities, t.encodeEntity); n += t.attrStart + e + t.attrEnd } return n }, stringifyText = (e, t, n) => createIndent(t, n) + t.textStart + e.value.replace(t.regEntities, t.encodeEntity) + (n.textContext ? "" : t.textEnd), VERSION = "4.0.0", pluginsMap = new Map; for (const e of builtinPlugins) pluginsMap.set(e.name, e); function getPlugin(e) { return "removeScriptElement" === e ? (console.warn("Warning: removeScriptElement has been renamed to removeScripts, please update your SVGO config"), pluginsMap.get("removeScripts")) : pluginsMap.get(e) } const resolvePluginConfig = e => { if ("string" == typeof e) { const t = getPlugin(e); if (null == t) throw Error(`Unknown builtin plugin "${e}" specified.`); return { name: e, params: {}, fn: t.fn } } if ("object" == typeof e && null != e) { if (null == e.name) throw Error("Plugin name must be specified"); let t = e.fn; if (null == t) { const n = getPlugin(e.name); if (null == n) throw Error(`Unknown builtin plugin "${e.name}" specified.`); t = n.fn } return { name: e.name, params: e.params, fn: t } } return null }, optimize = (e, t) => { if (null == t && (t = {}), "object" != typeof t) throw Error("Config should be an object"); const n = t.multipass ? 10 : 1; let r = Number.POSITIVE_INFINITY, a = ""; const o = {}; null != t.path && (o.path = t.path); for (let i = 0; i < n; i += 1) { o.multipassCount = i; const n = parseSvg(e, t.path), s = t.plugins || ["preset-default"]; if (!Array.isArray(s)) throw Error("malformed config, `plugins` property must be an array.\nSee more info here: https://github.com/svg/svgo#configuration"); const l = s.filter((e => null != e)).map(resolvePluginConfig); l.length < s.length && console.warn("Warning: plugins list includes null or undefined elements, these will be ignored."); const c = {}; if (null != t.floatPrecision && (c.floatPrecision = t.floatPrecision), invokePlugins(n, o, l, null, c), a = stringifySvg(n, t.js2svg), !(a.length < r)) break; e = a, r = a.length } return t.datauri && (a = encodeSVGDatauri(a, t.datauri)), { data: a } }; export { VERSION, _collections, builtinPlugins, mapNodesToParents, optimize, querySelector, querySelectorAll };